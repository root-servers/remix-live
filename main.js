(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"],{

/***/ "../../../dist/libs/remix-analyzer/index.js":
/*!**********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var solidity_analyzer_1 = __webpack_require__(/*! ./solidity-analyzer */ "../../../dist/libs/remix-analyzer/solidity-analyzer/index.js");

exports.CodeAnalysis = solidity_analyzer_1.default;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/index.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const remix_astwalker_1 = __webpack_require__(/*! @remix-project/remix-astwalker */ "../../../dist/libs/remix-astwalker/index.js");

const list_1 = tslib_1.__importDefault(__webpack_require__(/*! ./modules/list */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/list.js"));

class staticAnalysisRunner {
  /**
   * Run analysis (Used by IDE)
   * @param compilationResult contract compilation result
   * @param toRun module indexes (compiled from remix IDE)
   * @param callback callback
   */
  run(compilationResult, toRun, callback) {
    const modules = toRun.map(i => {
      const module = this.modules()[i];
      const m = new module();
      return {
        'name': m.name,
        'mod': m
      };
    });
    this.runWithModuleList(compilationResult, modules, callback);
  }
  /**
   * Run analysis passing list of modules to run
   * @param compilationResult contract compilation result
   * @param modules analysis module
   * @param callback callback
   */


  runWithModuleList(compilationResult, modules, callback) {
    let reports = []; // Also provide convenience analysis via the AST walker.

    const walker = new remix_astwalker_1.AstWalker();

    for (const k in compilationResult.sources) {
      walker.walkFull(compilationResult.sources[k].ast, node => {
        modules.map(item => {
          if (item.mod.visit !== undefined) {
            try {
              item.mod.visit(node);
            } catch (e) {
              reports.push({
                name: item.name,
                report: [{
                  warning: 'INTERNAL ERROR in module ' + item.name + ' ' + e.message,
                  error: e.stack
                }]
              });
            }
          }
        });
        return true;
      });
    } // Here, modules can just collect the results from the AST walk,
    // but also perform new analysis.


    reports = reports.concat(modules.map(item => {
      let report = null;

      try {
        report = item.mod.report(compilationResult);
      } catch (e) {
        report = [{
          warning: 'INTERNAL ERROR in module ' + item.name + ' ' + e.message,
          error: e.stack
        }];
      }

      return {
        name: item.name,
        report: report
      };
    }));
    callback(reports);
  }
  /**
   * Get list of all analysis modules
   */


  modules() {
    return list_1.default;
  }

}

exports.default = staticAnalysisRunner;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js":
/*!**********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const remix_astwalker_1 = __webpack_require__(/*! @remix-project/remix-astwalker */ "../../../dist/libs/remix-astwalker/index.js");

class abstractAstView {
  constructor() {
    this.contracts = [];
    this.currentContractIndex = -1;
    this.currentFunctionIndex = -1;
    this.currentModifierIndex = -1;
    this.isFunctionNotModifier = false;
    /*
      file1: contract c{}
      file2: import "file1" as x; contract c{}
      therefore we have two contracts with the same name c. At the moment this is not handled because alias name "x" is not
      available in the current AST implementation thus can not be resolved.
      Additionally the fullQuallified function names e.g. [contractName].[functionName](param1Type, param2Type, ... ) must be prefixed to
      fully support this and when inheritance is resolved it must include alias resolving e.g x.c = file1.c
    */

    this.multipleContractsWithSameName = false;
  }
  /**
   * Builds a higher level AST view. I creates a list with each contract as an object in it.
   * Example contractsOut:
   *
   * {
   *  "node": {},                     // actual AST Node of the contract
   *  "functions": [
   *    {
   *      "node": {},                // actual AST Node of the function
   *      "relevantNodes": [],       // AST nodes in the function that are relevant for the anlysis of this function
   *      "modifierInvocations": [], // Modifier invocation AST nodes that are applied on this function
   *      "localVariables": [],      // Local variable declaration nodes
   *      "parameters": []           // Parameter types of the function in order of definition
   *      "returns": []              // list of return vars as { type: ... , name: ... }
   *    }
   *  ],
   *  "modifiers": [],              // Modifiers definded by the contract, format similar to functions
   *  "inheritsFrom": [],           // Names of contract this one inherits from in order of definition
   *  "stateVariables": []          // AST nodes of all State variables
   * }
   *
   * @relevantNodeFilter {ASTNode -> bool} function that selects relevant ast nodes for analysis on function level.
   * @contractsOut {list} return list for high level AST view
   * @return {ASTNode -> void} returns a function that can be used as visit function for static analysis modules, to build up a higher level AST view for further analysis.
   */


  build_visit(relevantNodeFilter) {
    return node => {
      if (node.nodeType === "ContractDefinition") {
        this.setCurrentContract({
          node: node,
          functions: [],
          relevantNodes: [],
          modifiers: [],
          inheritsFrom: [],
          stateVariables: staticAnalysisCommon_1.getStateVariableDeclarationsFromContractNode(node)
        });
      } else if (node.nodeType === "InheritanceSpecifier") {
        const currentContract = this.getCurrentContract();
        const inheritsFromName = staticAnalysisCommon_1.getInheritsFromName(node);
        currentContract.inheritsFrom.push(inheritsFromName);
      } else if (node.nodeType === "FunctionDefinition") {
        this.setCurrentFunction({
          node: node,
          relevantNodes: [],
          modifierInvocations: [],
          localVariables: this.getLocalVariables(node),
          parameters: this.getLocalParameters(node),
          returns: this.getReturnParameters(node)
        }); // push back relevant nodes to their the current fn if any

        this.getCurrentContract().relevantNodes.map(item => {
          if (item.referencedDeclaration === node.id) {
            this.getCurrentFunction().relevantNodes.push(item.node);
          }
        });
      } else if (node.nodeType === "ModifierDefinition") {
        this.setCurrentModifier({
          node: node,
          relevantNodes: [],
          localVariables: this.getLocalVariables(node),
          parameters: this.getLocalParameters(node)
        });
      } else if (node.nodeType === "ModifierInvocation") {
        if (!this.isFunctionNotModifier) throw new Error('abstractAstView.js: Found modifier invocation outside of function scope.');
        this.getCurrentFunction().modifierInvocations.push(node);
      } else if (relevantNodeFilter(node)) {
        let scope = this.isFunctionNotModifier ? this.getCurrentFunction() : this.getCurrentModifier();

        if (scope) {
          scope.relevantNodes.push(node);
        } else {
          scope = this.getCurrentContract(); // if we are not in a function scope, add the node to the contract scope

          if (scope && node.referencedDeclaration) {
            scope.relevantNodes.push({
              referencedDeclaration: node.referencedDeclaration,
              node: node
            });
          }
        }
      }
    };
  }

  build_report(wrap) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    return compilationResult => {
      const solVersion = staticAnalysisCommon_1.getCompilerVersion(compilationResult.contracts);
      this.resolveStateVariablesInHierarchy(this.contracts);
      return wrap(this.contracts, this.multipleContractsWithSameName, solVersion);
    };
  }

  resolveStateVariablesInHierarchy(contracts) {
    contracts.map(c => {
      this.resolveStateVariablesInHierarchyForContract(c, contracts);
    });
  }

  resolveStateVariablesInHierarchyForContract(currentContract, contracts) {
    currentContract.inheritsFrom.map(inheritsFromName => {
      // add variables from inherited contracts
      const inheritsFrom = contracts.find(contract => staticAnalysisCommon_1.getContractName(contract.node) === inheritsFromName);

      if (inheritsFrom) {
        currentContract.stateVariables = currentContract.stateVariables.concat(inheritsFrom.stateVariables);
      } else {
        console.log('abstractAstView.js: could not find contract defintion inherited from ' + inheritsFromName);
      }
    });
  }

  setCurrentContract(contract) {
    const name = staticAnalysisCommon_1.getContractName(contract.node);

    if (this.contracts.map(c => staticAnalysisCommon_1.getContractName(c.node)).filter(n => n === name).length > 0) {
      console.log('abstractAstView.js: two or more contracts with the same name dectected, import aliases not supported at the moment');
      this.multipleContractsWithSameName = true;
    }

    this.currentContractIndex = this.contracts.push(contract) - 1;
  }

  setCurrentFunction(func) {
    this.isFunctionNotModifier = true;
    this.currentFunctionIndex = this.getCurrentContract().functions.push(func) - 1;
  }

  setCurrentModifier(modi) {
    this.isFunctionNotModifier = false;
    this.currentModifierIndex = this.getCurrentContract().modifiers.push(modi) - 1;
  }

  getCurrentContract() {
    return this.contracts[this.currentContractIndex];
  }

  getCurrentFunction() {
    return this.getCurrentContract().functions[this.currentFunctionIndex];
  }

  getCurrentModifier() {
    return this.getCurrentContract().modifiers[this.currentModifierIndex];
  }

  getLocalParameters(funcNode) {
    return staticAnalysisCommon_1.getFunctionOrModifierDefinitionParameterPart(funcNode).parameters.map(staticAnalysisCommon_1.getType);
  }

  getReturnParameters(funcNode) {
    return this.getLocalVariables(staticAnalysisCommon_1.getFunctionDefinitionReturnParameterPart(funcNode)).map(n => {
      return {
        type: staticAnalysisCommon_1.getType(n),
        name: staticAnalysisCommon_1.getDeclaredVariableName(n)
      };
    });
  }

  getLocalVariables(funcNode) {
    const locals = [];
    new remix_astwalker_1.AstWalker().walkFull(funcNode, node => {
      if (node.nodeType === "VariableDeclaration") locals.push(node);
      return true;
    });
    return locals;
  }

}

exports.default = abstractAstView;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js":
/*!**************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
  * Should be used to categorize different modules, main reason is to give users feedback if the modules
  * Produce exact results or have false positives and negatives in them
  * A further category could be approximate if some form of approximation is used
*/

exports.default = {
  EXACT: {
    hasFalsePositives: false,
    hasFalseNegatives: false,
    id: 'EXACT'
  },
  HEURISTIC: {
    hasFalsePositives: true,
    hasFalseNegatives: true,
    id: 'HEURI'
  }
};

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/assignAndCompare.js":
/*!***********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/assignAndCompare.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class assignAndCompare {
  constructor() {
    this.warningNodes = [];
    this.name = `Result not used: `;
    this.description = `The result of an operation not used`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if ((node === null || node === void 0 ? void 0 : node.nodeType) && staticAnalysisCommon_1.isSubScopeWithTopLevelUnAssignedBinOp(node)) staticAnalysisCommon_1.getUnAssignedTopLevelBinOps(node).forEach(n => this.warningNodes.push(n));
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    return this.warningNodes.map(item => {
      return {
        warning: 'A binary operation yields a value that is not used further. This is often caused by confusing assignment (=) and comparison (==).',
        location: item.src
      };
    });
  }

}

exports.default = assignAndCompare;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/blockBlockhash.js":
/*!*********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/blockBlockhash.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class blockBlockhash {
  constructor() {
    this.warningNodes = [];
    this.name = `Block hash: `;
    this.description = `Can be influenced by miners`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (node.nodeType === 'FunctionCall' && staticAnalysisCommon_1.isBlockBlockHashAccess(node)) this.warningNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    return this.warningNodes.map(item => {
      return {
        warning: `Use of "blockhash": "blockhash(uint blockNumber)" is used to access the last 256 block hashes. 
                  A miner computes the block hash by "summing up" the information in the current block mined. 
                  By "summing up" the information cleverly, a miner can try to influence the outcome of a transaction in the current block. 
                  This is especially easy if there are only a small number of equally likely outcomes.`,
        location: item.src
      };
    });
  }

}

exports.default = blockBlockhash;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/blockTimestamp.js":
/*!*********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/blockTimestamp.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class blockTimestamp {
  constructor() {
    this.warningNowNodes = [];
    this.warningblockTimestampNodes = [];
    this.name = `Block timestamp: `;
    this.description = `Can be influenced by miners`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (node.nodeType === "Identifier" && staticAnalysisCommon_1.isNowAccess(node)) this.warningNowNodes.push(node);else if (node.nodeType === "MemberAccess" && staticAnalysisCommon_1.isBlockTimestampAccess(node)) this.warningblockTimestampNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.warningNowNodes.map((item, i) => {
      return {
        warning: `Use of "now": "now" does not mean current time. "now" is an alias for "block.timestamp". 
                  "block.timestamp" can be influenced by miners to a certain degree, be careful.`,
        location: item.src,
        more: `https://solidity.readthedocs.io/en/${version}/units-and-global-variables.html?highlight=block.timestamp#block-and-transaction-properties`
      };
    }).concat(this.warningblockTimestampNodes.map(item => {
      return {
        warning: `Use of "block.timestamp": "block.timestamp" can be influenced by miners to a certain degree. 
                  That means that a miner can "choose" the block.timestamp, to a certain degree, to change the outcome of a transaction in the mined block.`,
        location: item.src,
        more: `https://solidity.readthedocs.io/en/${version}/units-and-global-variables.html?highlight=block.timestamp#block-and-transaction-properties`
      };
    }));
  }

}

exports.default = blockTimestamp;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js":
/*!*****************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  SECURITY: {
    displayName: 'Security',
    id: 'SEC'
  },
  GAS: {
    displayName: 'Gas & Economy',
    id: 'GAS'
  },
  MISC: {
    displayName: 'Miscellaneous',
    id: 'MISC'
  },
  ERC: {
    displayName: 'ERC',
    id: 'ERC'
  }
};

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/checksEffectsInteraction.js":
/*!*******************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/checksEffectsInteraction.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const functionCallGraph_1 = __webpack_require__(/*! ./functionCallGraph */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/functionCallGraph.js");

const abstractAstView_1 = tslib_1.__importDefault(__webpack_require__(/*! ./abstractAstView */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js"));

class checksEffectsInteraction {
  constructor() {
    this.name = `Check-effects-interaction: `;
    this.description = `Potential reentrancy bugs`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.HEURISTIC;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default();
    this.visit = this.abstractAst.build_visit(node => node.nodeType === 'FunctionCall' && (staticAnalysisCommon_1.isInteraction(node) || staticAnalysisCommon_1.isLocalCallGraphRelevantNode(node)) || (node.nodeType === 'Assignment' || node.nodeType === 'UnaryOperation' || node.nodeType === 'InlineAssembly') && staticAnalysisCommon_1.isEffect(node));
    this.report = this.abstractAst.build_report(this._report.bind(this));
  }

  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    const hasModifiers = contracts.some(item => item.modifiers.length > 0);
    const callGraph = functionCallGraph_1.buildGlobalFuncCallGraph(contracts);
    contracts.forEach(contract => {
      contract.functions.forEach(func => {
        func['changesState'] = this.checkIfChangesState(staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, func.node, func.parameters), this.getContext(callGraph, contract, func));
      });
      contract.functions.forEach(func => {
        if (this.isPotentialVulnerableFunction(func, this.getContext(callGraph, contract, func))) {
          const funcName = staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, func.node, func.parameters);
          let comments = hasModifiers ? 'Note: Modifiers are currently not considered by this static analysis.' : '';
          comments += multipleContractsWithSameName ? 'Note: Import aliases are currently not supported by this static analysis.' : '';
          warnings.push({
            warning: `Potential violation of Checks-Effects-Interaction pattern in ${funcName}: Could potentially lead to re-entrancy vulnerability. ${comments}`,
            location: func.node['src'],
            more: `https://solidity.readthedocs.io/en/${version}/security-considerations.html#re-entrancy`
          });
        }
      });
    });
    return warnings;
  }

  getContext(callGraph, currentContract, func) {
    return {
      callGraph: callGraph,
      currentContract: currentContract,
      stateVariables: this.getStateVariables(currentContract, func)
    };
  }

  getStateVariables(contract, func) {
    return contract.stateVariables.concat(func.localVariables.filter(staticAnalysisCommon_1.isStorageVariableDeclaration));
  }

  isPotentialVulnerableFunction(func, context) {
    let isPotentialVulnerable = false;
    let interaction = false;
    func.relevantNodes.forEach(node => {
      if (staticAnalysisCommon_1.isInteraction(node)) {
        interaction = true;
      } else if (interaction && (staticAnalysisCommon_1.isWriteOnStateVariable(node, context.stateVariables) || this.isLocalCallWithStateChange(node, context))) {
        isPotentialVulnerable = true;
      }
    });
    return isPotentialVulnerable;
  }

  isLocalCallWithStateChange(node, context) {
    if (staticAnalysisCommon_1.isLocalCallGraphRelevantNode(node)) {
      const func = functionCallGraph_1.resolveCallGraphSymbol(context.callGraph, staticAnalysisCommon_1.getFullQualifiedFunctionCallIdent(context.currentContract.node, node));
      return !func || func && func.node['changesState'];
    }

    return false;
  }

  checkIfChangesState(startFuncName, context) {
    return functionCallGraph_1.analyseCallGraph(context.callGraph, startFuncName, context, (node, context) => staticAnalysisCommon_1.isWriteOnStateVariable(node, context.stateVariables));
  }

}

exports.default = checksEffectsInteraction;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/constantFunctions.js":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/constantFunctions.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const functionCallGraph_1 = __webpack_require__(/*! ./functionCallGraph */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/functionCallGraph.js");

const abstractAstView_1 = tslib_1.__importDefault(__webpack_require__(/*! ./abstractAstView */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js"));

class constantFunctions {
  constructor() {
    this.name = `Constant/View/Pure functions: `;
    this.description = `Potentially constant/view/pure functions`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.HEURISTIC;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default();
    this.visit = this.abstractAst.build_visit(node => staticAnalysisCommon_1.isLowLevelCall(node) || staticAnalysisCommon_1.isTransfer(node) || staticAnalysisCommon_1.isExternalDirectCall(node) || staticAnalysisCommon_1.isEffect(node) || staticAnalysisCommon_1.isLocalCallGraphRelevantNode(node) || node.nodeType === "InlineAssembly" || node.nodeType === "NewExpression" || staticAnalysisCommon_1.isSelfdestructCall(node) || staticAnalysisCommon_1.isDeleteUnaryOperation(node));
    this.report = this.abstractAst.build_report(this._report.bind(this));
  }

  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    const hasModifiers = contracts.some(item => item.modifiers.length > 0);
    const callGraph = functionCallGraph_1.buildGlobalFuncCallGraph(contracts);
    contracts.forEach(contract => {
      contract.functions.forEach(func => {
        if (staticAnalysisCommon_1.isPayableFunction(func.node) || staticAnalysisCommon_1.isConstructor(func.node)) {
          func['potentiallyshouldBeConst'] = false;
        } else {
          func['potentiallyshouldBeConst'] = this.checkIfShouldBeConstant(staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, func.node, func.parameters), this.getContext(callGraph, contract, func));
        }
      });
      contract.functions.filter(func => staticAnalysisCommon_1.hasFunctionBody(func.node)).forEach(func => {
        if (staticAnalysisCommon_1.isConstantFunction(func.node) !== func['potentiallyshouldBeConst']) {
          const funcName = staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, func.node, func.parameters);
          let comments = hasModifiers ? 'Note: Modifiers are currently not considered by this static analysis.' : '';
          comments += multipleContractsWithSameName ? 'Note: Import aliases are currently not supported by this static analysis.' : '';

          if (func['potentiallyshouldBeConst']) {
            warnings.push({
              warning: `${funcName} : Potentially should be constant/view/pure but is not. ${comments}`,
              location: func.node['src'],
              more: `https://solidity.readthedocs.io/en/${version}/contracts.html#view-functions`
            });
          } else {
            warnings.push({
              warning: `${funcName} : Is constant but potentially should not be. ${comments}`,
              location: func.node['src'],
              more: `https://solidity.readthedocs.io/en/${version}/contracts.html#view-functions`
            });
          }
        }
      });
    });
    return warnings;
  }

  getContext(callGraph, currentContract, func) {
    return {
      callGraph: callGraph,
      currentContract: currentContract,
      stateVariables: this.getStateVariables(currentContract, func)
    };
  }

  getStateVariables(contract, func) {
    return contract.stateVariables.concat(func.localVariables.filter(staticAnalysisCommon_1.isStorageVariableDeclaration));
  }

  checkIfShouldBeConstant(startFuncName, context) {
    return !functionCallGraph_1.analyseCallGraph(context.callGraph, startFuncName, context, this.isConstBreaker.bind(this));
  }

  isConstBreaker(node, context) {
    return staticAnalysisCommon_1.isWriteOnStateVariable(node, context.stateVariables) || staticAnalysisCommon_1.isLowLevelCall(node) || staticAnalysisCommon_1.isTransfer(node) || this.isCallOnNonConstExternalInterfaceFunction(node, context) || staticAnalysisCommon_1.isCallToNonConstLocalFunction(node) || node.nodeType === "InlineAssembly" || node.nodeType === "NewExpression" || staticAnalysisCommon_1.isSelfdestructCall(node) || staticAnalysisCommon_1.isDeleteUnaryOperation(node);
  }

  isCallOnNonConstExternalInterfaceFunction(node, context) {
    if (staticAnalysisCommon_1.isExternalDirectCall(node)) {
      const func = functionCallGraph_1.resolveCallGraphSymbol(context.callGraph, staticAnalysisCommon_1.getFullQualifiedFunctionCallIdent(context.currentContract.node, node));
      return !func || func && !staticAnalysisCommon_1.isConstantFunction(func.node.node);
    }

    return false;
  }

}

exports.default = constantFunctions;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/deleteDynamicArrays.js":
/*!**************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/deleteDynamicArrays.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class deleteDynamicArrays {
  constructor() {
    this.rel = [];
    this.name = `Delete dynamic array: `;
    this.description = `Use require/assert to ensure complete deletion`;
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (staticAnalysisCommon_1.isDeleteOfDynamicArray(node)) this.rel.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.rel.map(node => {
      return {
        warning: `The "delete" operation when applied to a dynamically sized array in Solidity generates code to delete each of the elements contained. If the array is large, this operation can surpass the block gas limit and raise an OOG exception. Also nested dynamically sized objects can produce the same results.`,
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/types.html#delete`
      };
    });
  }

}

exports.default = deleteDynamicArrays;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/deleteFromDynamicArray.js":
/*!*****************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/deleteFromDynamicArray.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class deleteFromDynamicArray {
  constructor() {
    this.relevantNodes = [];
    this.name = `Delete from dynamic array: `;
    this.description = `'delete' leaves a gap in array`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (staticAnalysisCommon_1.isDeleteFromDynamicArray(node) && !staticAnalysisCommon_1.isMappingIndexAccess(node.subExpression)) this.relevantNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    return this.relevantNodes.map(node => {
      return {
        warning: `Using "delete" on an array leaves a gap. The length of the array remains the same. If you want to remove the empty position you need to shift items manually and update the "length" property.`,
        location: node.src,
        more: 'https://github.com/miguelmota/solidity-idiosyncrasies#examples'
      };
    });
  }

}

exports.default = deleteFromDynamicArray;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/erc20Decimals.js":
/*!********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/erc20Decimals.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const abstractAstView_1 = tslib_1.__importDefault(__webpack_require__(/*! ./abstractAstView */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js"));

class erc20Decimals {
  constructor() {
    this.name = `ERC20: `;
    this.description = `'decimals' should be 'uint8'`;
    this.category = categories_1.default.ERC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default(); // eslint-disable-next-line @typescript-eslint/no-unused-vars

    this.visit = this.abstractAst.build_visit(node => false);
    this.report = this.abstractAst.build_report(this._report.bind(this));
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _report(contracts, multipleContractsWithSameName) {
    const warnings = [];
    contracts.forEach(contract => {
      const contractAbiSignatures = contract.functions.map(f => staticAnalysisCommon_1.helpers.buildAbiSignature(staticAnalysisCommon_1.getFunctionDefinitionName(f.node), f.parameters));

      if (this.isERC20(contractAbiSignatures)) {
        const decimalsVar = contract.stateVariables.filter(stateVar => staticAnalysisCommon_1.getDeclaredVariableName(stateVar) === 'decimals' && (staticAnalysisCommon_1.getDeclaredVariableType(stateVar) !== 'uint8' || stateVar.visibility !== 'public'));
        const decimalsFun = contract.functions.filter(f => staticAnalysisCommon_1.getFunctionDefinitionName(f.node) === 'decimals' && (f.returns.length === 0 || f.returns.length > 1 || f.returns.length === 1 && (f.returns[0].type !== 'uint8' || f.node.visibility !== 'public')));

        if (decimalsVar.length > 0) {
          for (const node of decimalsVar) {
            warnings.push({
              warning: `ERC20 contract's "decimals" variable should be "uint8" type`,
              location: node.src,
              more: 'https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#decimals'
            });
          }
        } else if (decimalsFun.length > 0) {
          for (const fn of decimalsFun) {
            warnings.push({
              warning: `ERC20 contract's "decimals" function should have "uint8" as return type`,
              location: fn.node.src,
              more: 'https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#decimals'
            });
          }
        }
      }
    });
    return warnings;
  }

  isERC20(funSignatures) {
    return funSignatures.includes('totalSupply()') && funSignatures.includes('balanceOf(address)') && funSignatures.includes('transfer(address,uint256)') && funSignatures.includes('transferFrom(address,address,uint256)') && funSignatures.includes('approve(address,uint256)') && funSignatures.includes('allowance(address,address)');
  }

}

exports.default = erc20Decimals;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/etherTransferInLoop.js":
/*!**************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/etherTransferInLoop.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class etherTransferInLoop {
  constructor() {
    this.relevantNodes = [];
    this.name = `Ether transfer in loop: `;
    this.description = `Transferring Ether in a for/while/do-while loop`;
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    let transferNodes = [];

    if (staticAnalysisCommon_1.isLoop(node)) {
      if (node.body && node.body.nodeType === 'Block') transferNodes = node.body.statements.filter(child => child.nodeType === 'ExpressionStatement' && child.expression.nodeType === 'FunctionCall' && staticAnalysisCommon_1.isTransfer(child.expression.expression)); // When loop body is described without braces
      else if (node.body && node.body.nodeType === 'ExpressionStatement' && node.body.expression.nodeType === 'FunctionCall' && staticAnalysisCommon_1.isTransfer(node.body.expression.expression)) transferNodes.push(node.body);

      if (transferNodes.length > 0) {
        this.relevantNodes.push(...transferNodes);
      }
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.relevantNodes.map(node => {
      return {
        warning: `Ether payout should not be done in a loop: Due to the block gas limit, transactions can only consume a certain amount of gas. The number of iterations in a loop can grow beyond the block gas limit which can cause the complete contract to be stalled at a certain point. If required then make sure that number of iterations are low and you trust each address involved.`,
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/security-considerations.html#gas-limit-and-loops`
      };
    });
  }

}

exports.default = etherTransferInLoop;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/forLoopIteratesOverDynamicArray.js":
/*!**************************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/forLoopIteratesOverDynamicArray.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class forLoopIteratesOverDynamicArray {
  constructor() {
    this.relevantNodes = [];
    this.name = `For loop over dynamic array: `;
    this.description = `Iterations depend on dynamic array's size`;
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    const {
      condition
    } = node; // Check if condition is `i < array.length - 1`

    if (condition && condition.nodeType === "BinaryOperation" && condition.rightExpression.nodeType === "BinaryOperation" && staticAnalysisCommon_1.isDynamicArrayLengthAccess(condition.rightExpression.leftExpression) || // or condition is `i < array.length`
    condition && condition.nodeType === "BinaryOperation" && staticAnalysisCommon_1.isDynamicArrayLengthAccess(condition.rightExpression)) {
      this.relevantNodes.push(node);
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.relevantNodes.map(node => {
      return {
        warning: `Loops that do not have a fixed number of iterations, for example, loops that depend on storage values, have to be used carefully. Due to the block gas limit, transactions can only consume a certain amount of gas. The number of iterations in a loop can grow beyond the block gas limit which can cause the complete contract to be stalled at a certain point. \n Additionally, using unbounded loops incurs in a lot of avoidable gas costs. Carefully test how many items at maximum you can pass to such functions to make it successful.`,
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/security-considerations.html#gas-limit-and-loops`
      };
    });
  }

}

exports.default = forLoopIteratesOverDynamicArray;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/functionCallGraph.js":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/functionCallGraph.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

function buildLocalFuncCallGraphInternal(functions, nodeFilter, extractNodeIdent, extractFuncDefIdent) {
  const callGraph = {};
  functions.forEach(func => {
    const calls = func.relevantNodes.filter(nodeFilter).map(extractNodeIdent).filter(name => name !== extractFuncDefIdent(func)); // filter self recursive call

    callGraph[extractFuncDefIdent(func)] = {
      node: func,
      calls: calls
    };
  });
  return callGraph;
}
/**
 * Builds a function call graph for the current contracts.
 * Example Contract call graph:
 *
 * {
 *  "KingOfTheEtherThrone": {
 *    "contracts": {...},                                        // Contract node as defined in abstractAstView.js
 *    "functions": {
 *      "KingOfTheEtherThrone.claimThrone(string memory)": {    // function in KingOfEtherThrone
 *        "node": {...},                                        // function node as defined in abstractAstView.js
 *        "calls": {                                            // list of full qualified function names which are called form this function
 *        }
 *      }
 *    }
 *  },
 *  "foo": {
 *    "contract": {...},           // Contract node as definded in abstractAstView.js
 *    "functions": {}             // map from full qualified function name to func node
 *  }
 * }
 *
 * @contracts {list contracts} Expects as input the contract structure defined in abstractAstView.js
 * @return {map (string -> Contract Call Graph)} returns map from contract name to contract call graph
 */


function buildGlobalFuncCallGraph(contracts) {
  const callGraph = {};
  contracts.forEach(contract => {
    const filterNodes = node => {
      return staticAnalysisCommon_1.isLocalCallGraphRelevantNode(node) || staticAnalysisCommon_1.isExternalDirectCall(node);
    };

    const getNodeIdent = node => {
      return staticAnalysisCommon_1.getFullQualifiedFunctionCallIdent(contract.node, node);
    };

    const getFunDefIdent = funcDef => {
      return staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, funcDef.node, funcDef.parameters);
    };

    callGraph[staticAnalysisCommon_1.getContractName(contract.node)] = {
      contract: contract,
      functions: buildLocalFuncCallGraphInternal(contract.functions, filterNodes, getNodeIdent, getFunDefIdent)
    };
  });
  return callGraph;
}

exports.buildGlobalFuncCallGraph = buildGlobalFuncCallGraph;
/**
 * Walks through the call graph from a defined starting function, true if nodeCheck holds for every relevant node in the callgraph
 * @callGraph {callGraph} As returned by buildGlobalFuncCallGraph
 * @funcName {string} full qualified name of the starting function
 * @context {Object} provides additional context information that can be used by the nodeCheck function
 * @nodeCheck {(ASTNode, context) -> bool} applied on every relevant node in the call graph
 * @return {bool} returns map from contract name to contract call graph
 */

function analyseCallGraph(callGraph, funcName, context, nodeCheck) {
  return analyseCallGraphInternal(callGraph, funcName, context, (a, b) => a || b, nodeCheck, {});
}

exports.analyseCallGraph = analyseCallGraph;

function analyseCallGraphInternal(callGraph, funcName, context, combinator, nodeCheck, visited) {
  const current = resolveCallGraphSymbol(callGraph, funcName);
  if (current === undefined || visited[funcName] === true) return true;
  visited[funcName] = true;
  return combinator(current.node.relevantNodes.reduce((acc, val) => combinator(acc, nodeCheck(val, context)), false), current.calls.reduce((acc, val) => combinator(acc, analyseCallGraphInternal(callGraph, val, context, combinator, nodeCheck, visited)), false));
}

function resolveCallGraphSymbol(callGraph, funcName) {
  return resolveCallGraphSymbolInternal(callGraph, funcName, false);
}

exports.resolveCallGraphSymbol = resolveCallGraphSymbol;

function resolveCallGraphSymbolInternal(callGraph, funcName, silent) {
  let current = null;

  if (funcName.includes('.')) {
    const parts = funcName.split('.');
    const contractPart = parts[0];
    const functionPart = parts[1];
    const currentContract = callGraph[contractPart];

    if (!(currentContract === undefined)) {
      current = currentContract.functions[funcName]; // resolve inheritance hierarchy

      if (current === undefined) {
        // resolve inheritance lookup in linearized fashion
        const inheritsFromNames = currentContract.contract.inheritsFrom.reverse();

        for (let i = 0; i < inheritsFromNames.length; i++) {
          const res = resolveCallGraphSymbolInternal(callGraph, inheritsFromNames[i] + '.' + functionPart, true);
          if (!(res === undefined)) return res;
        }
      }
    } else {
      if (!silent) console.log(`static analysis functionCallGraph.js: Contract ${contractPart} not found in function call graph.`);
    }
  } else {
    throw new Error('functionCallGraph.js: function does not have full qualified name.');
  }

  if (current === undefined && !silent) console.log(`static analysis functionCallGraph.js: ${funcName} not found in function call graph.`);
  if (current !== null) return current;
}

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/gasCosts.js":
/*!***************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/gasCosts.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class gasCosts {
  constructor() {
    this.name = `Gas costs: `;
    this.description = `Too high gas requirement of functions`;
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.warningNodes = [];
  }

  visit(node) {
    if (node.nodeType === 'FunctionDefinition' && node.kind !== 'constructor' && node.implemented || node.nodeType === 'VariableDeclaration' && staticAnalysisCommon_1.isVariableTurnedIntoGetter(node)) this.warningNodes.push(node);
  }

  report(compilationResults) {
    const report = [];
    const methodsWithSignature = this.warningNodes.map(node => {
      let signature;

      if (node.nodeType === 'FunctionDefinition') {
        const functionName = staticAnalysisCommon_1.getFunctionDefinitionName(node);
        signature = staticAnalysisCommon_1.helpers.buildAbiSignature(functionName, staticAnalysisCommon_1.getMethodParamsSplittedTypeDesc(node, compilationResults.contracts));
      } else signature = node.name + '()';

      return {
        name: node.name,
        src: node.src,
        signature: signature
      };
    });

    for (const method of methodsWithSignature) {
      for (const filename in compilationResults.contracts) {
        for (const contractName in compilationResults.contracts[filename]) {
          const contract = compilationResults.contracts[filename][contractName];
          const methodGas = this.checkMethodGas(contract, method.signature);

          if (methodGas && methodGas.isInfinite) {
            if (methodGas.isFallback) {
              report.push({
                warning: `Fallback function of contract ${contractName} requires too much gas (${methodGas.msg}). 
                If the fallback function requires more than 2300 gas, the contract cannot receive Ether.`,
                location: method.src
              });
            } else {
              report.push({
                warning: `Gas requirement of function ${contractName}.${method.name} ${methodGas.msg}: 
                If the gas requirement of a function is higher than the block gas limit, it cannot be executed.
                Please avoid loops in your functions or actions that modify large areas of storage
                (this includes clearing or copying arrays in storage)`,
                location: method.src
              });
            }
          } else continue;
        }
      }
    }

    return report;
  }

  checkMethodGas(contract, methodSignature) {
    if (contract.evm && contract.evm.gasEstimates && contract.evm.gasEstimates.external) {
      if (methodSignature === '()') {
        const fallback = contract.evm.gasEstimates.external[''];

        if (fallback !== undefined && (fallback === null || parseInt(fallback) >= 2100 || fallback === 'infinite')) {
          return {
            isInfinite: true,
            isFallback: true,
            msg: fallback
          };
        }
      } else {
        const gas = contract.evm.gasEstimates.external[methodSignature];
        const gasString = gas === null ? 'unknown or not constant' : 'is ' + gas;

        if (gas === null || parseInt(gas) >= 3000000 || gas === 'infinite') {
          return {
            isInfinite: true,
            isFallback: false,
            msg: gasString
          };
        }
      }
    }
  }

}

exports.default = gasCosts;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/guardConditions.js":
/*!**********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/guardConditions.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class guardConditions {
  constructor() {
    this.guards = [];
    this.name = `Guard conditions: `;
    this.description = `Ensure appropriate use of require/assert`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (staticAnalysisCommon_1.isRequireCall(node) || staticAnalysisCommon_1.isAssertCall(node)) this.guards.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.guards.map(node => {
      return {
        warning: `Use "assert(x)" if you never ever want x to be false, not in any circumstance (apart from a bug in your code). Use "require(x)" if x can be false, due to e.g. invalid input or a failing external component.`,
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/control-structures.html#error-handling-assert-require-revert-and-exceptions`
      };
    });
  }

}

exports.default = guardConditions;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/inlineAssembly.js":
/*!*********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/inlineAssembly.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class inlineAssembly {
  constructor() {
    this.inlineAssNodes = [];
    this.name = `Inline assembly: `;
    this.description = `Inline assembly used`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (node.nodeType === 'InlineAssembly') this.inlineAssNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.inlineAssNodes.map(node => {
      return {
        warning: `The Contract uses inline assembly, this is only advised in rare cases. 
                  Additionally static analysis modules do not parse inline Assembly, this can lead to wrong analysis results.`,
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/assembly.html`
      };
    });
  }

}

exports.default = inlineAssembly;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/intDivisionTruncate.js":
/*!**************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/intDivisionTruncate.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class intDivisionTruncate {
  constructor() {
    this.warningNodes = [];
    this.name = `Data truncated: `;
    this.description = `Division on int/uint values truncates the result`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (staticAnalysisCommon_1.isIntDivision(node)) this.warningNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    return this.warningNodes.map(item => {
      return {
        warning: 'Division of integer values yields an integer value again. That means e.g. 10 / 100 = 0 instead of 0.1 since the result is an integer again. This does not hold for division of (only) literal values since those yield rational constants.',
        location: item.src
      };
    });
  }

}

exports.default = intDivisionTruncate;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/list.js":
/*!***********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/list.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const txOrigin_1 = tslib_1.__importDefault(__webpack_require__(/*! ./txOrigin */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/txOrigin.js"));

const gasCosts_1 = tslib_1.__importDefault(__webpack_require__(/*! ./gasCosts */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/gasCosts.js"));

const thisLocal_1 = tslib_1.__importDefault(__webpack_require__(/*! ./thisLocal */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/thisLocal.js"));

const checksEffectsInteraction_1 = tslib_1.__importDefault(__webpack_require__(/*! ./checksEffectsInteraction */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/checksEffectsInteraction.js"));

const constantFunctions_1 = tslib_1.__importDefault(__webpack_require__(/*! ./constantFunctions */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/constantFunctions.js"));

const similarVariableNames_1 = tslib_1.__importDefault(__webpack_require__(/*! ./similarVariableNames */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/similarVariableNames.js"));

const inlineAssembly_1 = tslib_1.__importDefault(__webpack_require__(/*! ./inlineAssembly */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/inlineAssembly.js"));

const blockTimestamp_1 = tslib_1.__importDefault(__webpack_require__(/*! ./blockTimestamp */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/blockTimestamp.js"));

const lowLevelCalls_1 = tslib_1.__importDefault(__webpack_require__(/*! ./lowLevelCalls */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/lowLevelCalls.js"));

const blockBlockhash_1 = tslib_1.__importDefault(__webpack_require__(/*! ./blockBlockhash */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/blockBlockhash.js"));

const noReturn_1 = tslib_1.__importDefault(__webpack_require__(/*! ./noReturn */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/noReturn.js"));

const selfdestruct_1 = tslib_1.__importDefault(__webpack_require__(/*! ./selfdestruct */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/selfdestruct.js"));

const guardConditions_1 = tslib_1.__importDefault(__webpack_require__(/*! ./guardConditions */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/guardConditions.js"));

const deleteDynamicArrays_1 = tslib_1.__importDefault(__webpack_require__(/*! ./deleteDynamicArrays */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/deleteDynamicArrays.js"));

const assignAndCompare_1 = tslib_1.__importDefault(__webpack_require__(/*! ./assignAndCompare */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/assignAndCompare.js"));

const erc20Decimals_1 = tslib_1.__importDefault(__webpack_require__(/*! ./erc20Decimals */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/erc20Decimals.js"));

const stringBytesLength_1 = tslib_1.__importDefault(__webpack_require__(/*! ./stringBytesLength */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/stringBytesLength.js"));

const deleteFromDynamicArray_1 = tslib_1.__importDefault(__webpack_require__(/*! ./deleteFromDynamicArray */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/deleteFromDynamicArray.js"));

const forLoopIteratesOverDynamicArray_1 = tslib_1.__importDefault(__webpack_require__(/*! ./forLoopIteratesOverDynamicArray */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/forLoopIteratesOverDynamicArray.js"));

const etherTransferInLoop_1 = tslib_1.__importDefault(__webpack_require__(/*! ./etherTransferInLoop */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/etherTransferInLoop.js"));

const intDivisionTruncate_1 = tslib_1.__importDefault(__webpack_require__(/*! ./intDivisionTruncate */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/intDivisionTruncate.js"));

exports.default = [txOrigin_1.default, gasCosts_1.default, thisLocal_1.default, checksEffectsInteraction_1.default, erc20Decimals_1.default, constantFunctions_1.default, similarVariableNames_1.default, inlineAssembly_1.default, blockTimestamp_1.default, lowLevelCalls_1.default, blockBlockhash_1.default, noReturn_1.default, selfdestruct_1.default, guardConditions_1.default, deleteDynamicArrays_1.default, assignAndCompare_1.default, stringBytesLength_1.default, deleteFromDynamicArray_1.default, forLoopIteratesOverDynamicArray_1.default, etherTransferInLoop_1.default, intDivisionTruncate_1.default];

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/lowLevelCalls.js":
/*!********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/lowLevelCalls.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class lowLevelCalls {
  constructor() {
    this.llcNodes = [];
    this.name = `Low level calls: `;
    this.description = `Should only be used by experienced devs`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (staticAnalysisCommon_1.isLLCall(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.CALL
      });
    } else if (staticAnalysisCommon_1.isLLDelegatecall(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.DELEGATECALL
      });
    } else if (staticAnalysisCommon_1.isLLSend(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.SEND
      });
    } else if (staticAnalysisCommon_1.isLLDelegatecall04(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.DELEGATECALL
      });
    } else if (staticAnalysisCommon_1.isLLSend04(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.SEND
      });
    } else if (staticAnalysisCommon_1.isLLCall04(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.CALL
      });
    } else if (staticAnalysisCommon_1.isLLCallcode(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.CALLCODE
      });
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.llcNodes.map((item, i) => {
      let text = '';
      let morehref = '';

      switch (item.type) {
        case staticAnalysisCommon_1.lowLevelCallTypes.CALL:
          text = `Use of "call": should be avoided whenever possible. 
                  It can lead to unexpected behavior if return value is not handled properly. 
                  Please use Direct Calls via specifying the called contract's interface.`;
          morehref = `https://solidity.readthedocs.io/en/${version}/control-structures.html?#external-function-calls`;
          break;

        case staticAnalysisCommon_1.lowLevelCallTypes.CALLCODE:
          text = `Use of "callcode": should be avoided whenever possible. 
                  External code, that is called can change the state of the calling contract and send ether from the caller's balance. 
                  If this is wanted behaviour, use the Solidity library feature if possible.`;
          morehref = `https://solidity.readthedocs.io/en/${version}/contracts.html#libraries`;
          break;

        case staticAnalysisCommon_1.lowLevelCallTypes.DELEGATECALL:
          text = `Use of "delegatecall": should be avoided whenever possible. 
                  External code, that is called can change the state of the calling contract and send ether from the caller's balance. 
                  If this is wanted behaviour, use the Solidity library feature if possible.`;
          morehref = `https://solidity.readthedocs.io/en/${version}/contracts.html#libraries`;
          break;

        case staticAnalysisCommon_1.lowLevelCallTypes.SEND:
          text = `Use of "send": "send" does not throw an exception when not successful, make sure you deal with the failure case accordingly. 
                  Use "transfer" whenever failure of the ether transfer should rollback the whole transaction. 
                  Note: if you "send/transfer" ether to a contract the fallback function is called, the callees fallback function is very limited due to the limited amount of gas provided by "send/transfer". 
                  No state changes are possible but the callee can log the event or revert the transfer. "send/transfer" is syntactic sugar for a "call" to the fallback function with 2300 gas and a specified ether value.`;
          morehref = `https://solidity.readthedocs.io/en/${version}/security-considerations.html#sending-and-receiving-ether`;
          break;
      }

      return {
        warning: text,
        more: morehref,
        location: item.node.src
      };
    });
  }

}

exports.default = lowLevelCalls;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/noReturn.js":
/*!***************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/noReturn.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const abstractAstView_1 = tslib_1.__importDefault(__webpack_require__(/*! ./abstractAstView */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js"));

class noReturn {
  constructor() {
    this.name = `No return: `;
    this.description = `Function with 'returns' not returning`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default();
    this.visit = this.abstractAst.build_visit(node => node.nodeType === "Return" || node.nodeType === "Assignment");
    this.report = this.abstractAst.build_report(this._report.bind(this));
  }

  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    contracts.forEach(contract => {
      contract.functions.filter(func => staticAnalysisCommon_1.hasFunctionBody(func.node)).forEach(func => {
        const funcName = staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, func.node, func.parameters);

        if (this.hasNamedAndUnnamedReturns(func)) {
          warnings.push({
            warning: `${funcName}: Mixing of named and unnamed return parameters is not advised.`,
            location: func.node['src']
          });
        } else if (this.shouldReturn(func) && !(this.hasReturnStatement(func) || this.hasNamedReturns(func) && this.hasAssignToAllNamedReturns(func))) {
          warnings.push({
            warning: `${funcName}: Defines a return type but never explicitly returns a value.`,
            location: func.node['src']
          });
        }
      });
    });
    return warnings;
  }

  shouldReturn(func) {
    return func.returns.length > 0;
  }

  hasReturnStatement(func) {
    return func.relevantNodes.filter(n => n.nodeType === "Return").length > 0;
  }

  hasAssignToAllNamedReturns(func) {
    const namedReturns = func.returns.filter(n => n.name.length > 0).map(n => n.name);
    const assignedVars = func.relevantNodes.filter(n => n.nodeType === "Assignment").map(staticAnalysisCommon_1.getEffectedVariableName);
    const diff = namedReturns.filter(e => !assignedVars.includes(e));
    return diff.length === 0;
  }

  hasNamedReturns(func) {
    return func.returns.filter(n => n.name.length > 0).length > 0;
  }

  hasNamedAndUnnamedReturns(func) {
    return func.returns.filter(n => n.name.length === 0).length > 0 && this.hasNamedReturns(func);
  }

}

exports.default = noReturn;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/selfdestruct.js":
/*!*******************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/selfdestruct.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const abstractAstView_1 = tslib_1.__importDefault(__webpack_require__(/*! ./abstractAstView */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js"));

class selfdestruct {
  constructor() {
    this.name = `Selfdestruct: `;
    this.description = `Contracts using destructed contract can be broken`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.HEURISTIC;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default();
    this.visit = this.abstractAst.build_visit(node => staticAnalysisCommon_1.isStatement(node) || node.nodeType === 'FunctionCall' && staticAnalysisCommon_1.isSelfdestructCall(node));
    this.report = this.abstractAst.build_report(this._report.bind(this));
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    contracts.forEach(contract => {
      contract.functions.forEach(func => {
        let hasSelf = false;
        func.relevantNodes.forEach(node => {
          if (staticAnalysisCommon_1.isSelfdestructCall(node)) {
            warnings.push({
              warning: `Use of selfdestruct: Can block calling contracts unexpectedly. Be especially careful if this contract is planned to be used by other contracts (i.e. library contracts, interactions). Selfdestruction of the callee contract can leave callers in an inoperable state.`,
              location: node.src,
              more: 'https://paritytech.io/blog/security-alert.html'
            });
            hasSelf = true;
          }

          if (staticAnalysisCommon_1.isStatement(node) && hasSelf) {
            warnings.push({
              warning: `Use of selfdestruct: No code after selfdestruct is executed. Selfdestruct is a terminal.`,
              location: node.src,
              more: `https://solidity.readthedocs.io/en/${version}/introduction-to-smart-contracts.html#deactivate-and-self-destruct`
            });
            hasSelf = false;
          }
        });
      });
    });
    return warnings;
  }

}

exports.default = selfdestruct;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/similarVariableNames.js":
/*!***************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/similarVariableNames.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const abstractAstView_1 = tslib_1.__importDefault(__webpack_require__(/*! ./abstractAstView */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/abstractAstView.js"));

const fast_levenshtein_1 = __webpack_require__(/*! fast-levenshtein */ "../../../node_modules/fast-levenshtein/levenshtein.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

class similarVariableNames {
  constructor() {
    this.name = `Similar variable names: `;
    this.description = `Variable names are too similar`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default(); // eslint-disable-next-line @typescript-eslint/no-unused-vars

    this.visit = this.abstractAst.build_visit(node => false);
    this.report = this.abstractAst.build_report(this._report.bind(this));
  }

  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    const hasModifiers = contracts.some(item => item.modifiers.length > 0);
    contracts.forEach(contract => {
      contract.functions.forEach(func => {
        const funcName = staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent(contract.node, func.node, func.parameters);
        let hasModifiersComments = '';

        if (hasModifiers) {
          hasModifiersComments = 'Note: Modifiers are currently not considered by this static analysis.';
        }

        let multipleContractsWithSameNameComments = '';

        if (multipleContractsWithSameName) {
          multipleContractsWithSameNameComments = 'Note: Import aliases are currently not supported by this static analysis.';
        }

        const vars = this.getFunctionVariables(contract, func).map(staticAnalysisCommon_1.getDeclaredVariableName);
        this.findSimilarVarNames(vars).map(sim => {
          warnings.push({
            warning: `${funcName} : Variables have very similar names "${sim.var1}" and "${sim.var2}". ${hasModifiersComments} ${multipleContractsWithSameNameComments}`,
            location: func.node['src']
          });
        });
      });
    });
    return warnings;
  }

  findSimilarVarNames(vars) {
    const similar = [];
    const comb = {};
    vars.map(varName1 => vars.map(varName2 => {
      if (varName1.length > 1 && varName2.length > 1 && varName2 !== varName1 && !this.isCommonPrefixedVersion(varName1, varName2) && !this.isCommonNrSuffixVersion(varName1, varName2) && !(comb[varName1 + ';' + varName2] || comb[varName2 + ';' + varName1])) {
        comb[varName1 + ';' + varName2] = true;
        const distance = fast_levenshtein_1.get(varName1, varName2);
        if (distance <= 2) similar.push({
          var1: varName1,
          var2: varName2,
          distance: distance
        });
      }
    }));
    return similar;
  }

  isCommonPrefixedVersion(varName1, varName2) {
    return varName1.startsWith('_') && varName1.slice(1) === varName2 || varName2.startsWith('_') && varName2.slice(1) === varName1;
  }

  isCommonNrSuffixVersion(varName1, varName2) {
    const ref = '^' + remix_lib_1.util.escapeRegExp(varName1.slice(0, -1)) + '[0-9]*$';
    return varName2.match(ref) != null;
  }

  getFunctionVariables(contract, func) {
    return contract.stateVariables.concat(func.localVariables);
  }

}

exports.default = similarVariableNames;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js":
/*!***************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const nodeTypes = {
  SOURCEUNIT: 'SourceUnit',
  PRAGMADIRECTIVE: 'PragmaDirective',
  IMPORTDIRECTIVE: 'ImportDirective',
  CONTRACTDEFINITION: 'ContractDefinition',
  INHERITANCESPECIFIER: 'InheritanceSpecifier',
  USINGFORDIRECTIVE: 'UsingForDirective',
  STRUCTDEFINITION: 'StructDefinition',
  ENUMDEFINITION: 'EnumDefinition',
  ENUMVALUE: 'EnumValue',
  PARAMETERLIST: 'ParameterList',
  OVERRIDESPECIFIER: 'OverrideSpecifier',
  FUNCTIONDEFINITION: 'FunctionDefinition',
  VARIABLEDECLARATION: 'VariableDeclaration',
  MODIFIERDEFINITION: 'ModifierDefinition',
  MODIFIERINVOCATION: 'ModifierInvocation',
  EVENTDEFINITION: 'EventDefinition',
  ELEMENTARYTYPENAME: 'ElementaryTypeName',
  USERDEFINEDTYPENAME: 'UserDefinedTypeName',
  FUNCTIONTYPENAME: 'FunctionTypeName',
  MAPPING: 'Mapping',
  ARRAYTYPENAME: 'ArrayTypeName',
  INLINEASSEMBLY: 'InlineAssembly',
  BLOCK: 'Block',
  PLACEHOLDERSTATEMENT: 'PlaceholderStatement',
  IFSTATEMENT: 'IfStatement',
  TRYCATCHCLAUSE: 'TryCatchClause',
  TRYSTATEMENT: 'TryStatement',
  WHILESTATEMENT: 'WhileStatement',
  DOWHILESTATEMENT: 'DoWhileStatement',
  FORSTATEMENT: 'ForStatement',
  CONTINUE: 'Continue',
  BREAK: 'Break',
  RETURN: 'Return',
  THROW: 'Throw',
  EMITSTATEMENT: 'EmitStatement',
  VARIABLEDECLARATIONSTATEMENT: 'VariableDeclarationStatement',
  EXPRESSIONSTATEMENT: 'ExpressionStatement',
  CONDITIONAL: 'Conditional',
  ASSIGNMENT: 'Assignment',
  TUPLEEXPRESSION: 'TupleExpression',
  UNARYOPERATION: 'UnaryOperation',
  BINARYOPERATION: 'BinaryOperation',
  FUNCTIONCALL: 'FunctionCall',
  FUNCTIONCALLOPTIONS: 'FunctionCallOptions',
  NEWEXPRESSION: 'NewExpression',
  MEMBERACCESS: 'MemberAccess',
  INDEXACCESS: 'IndexAccess',
  INDEXRANGEACCESS: 'IndexRangeAccess',
  ELEMENTARYTYPENAMEEXPRESSION: 'ElementaryTypeNameExpression',
  LITERAL: 'Literal',
  IDENTIFIER: 'Identifier',
  STRUCTUREDDOCUMENTATION: 'StructuredDocumentation'
};
exports.nodeTypes = nodeTypes;
const basicTypes = {
  UINT: 'uint256',
  BOOL: 'bool',
  ADDRESS: 'address',
  PAYABLE_ADDRESS: 'address payable',
  BYTES32: 'bytes32',
  STRING_MEM: 'string memory',
  BYTES_MEM: 'bytes memory',
  BYTES4: 'bytes4'
};
exports.basicTypes = basicTypes;
const basicRegex = {
  CONTRACTTYPE: '^contract ',
  FUNCTIONTYPE: '^function \\(',
  EXTERNALFUNCTIONTYPE: '^function \\(.*\\).* external',
  CONSTANTFUNCTIONTYPE: '^function \\(.*\\).* (view|pure)',
  REFTYPE: '(storage)|(mapping\\()|(\\[\\])',
  FUNCTIONSIGNATURE: '^function \\(([^\\(]*)\\)',
  LIBRARYTYPE: '^type\\(library (.*)\\)'
};
const basicFunctionTypes = {
  SEND: buildFunctionSignature([basicTypes.UINT], [basicTypes.BOOL], false),
  'CALL-0.4': buildFunctionSignature([], [basicTypes.BOOL], true),
  CALL: buildFunctionSignature([basicTypes.BYTES_MEM], [basicTypes.BOOL, basicTypes.BYTES_MEM], true),
  'DELEGATECALL-0.4': buildFunctionSignature([], [basicTypes.BOOL], false),
  DELEGATECALL: buildFunctionSignature([basicTypes.BYTES_MEM], [basicTypes.BOOL, basicTypes.BYTES_MEM], false),
  TRANSFER: buildFunctionSignature([basicTypes.UINT], [], false)
};
exports.basicFunctionTypes = basicFunctionTypes;
const builtinFunctions = {
  'keccak256()': true,
  'sha3()': true,
  'sha256()': true,
  'ripemd160()': true,
  'ecrecover(bytes32,uint8,bytes32,bytes32)': true,
  'addmod(uint256,uint256,uint256)': true,
  'mulmod(uint256,uint256,uint256)': true,
  'selfdestruct(address)': true,
  'selfdestruct(address payable)': true,
  'revert()': true,
  'revert(string memory)': true,
  'assert(bool)': true,
  'require(bool)': true,
  'require(bool,string memory)': true,
  'gasleft()': true,
  'blockhash(uint256)': true,
  'address(address)': true
};
const lowLevelCallTypes = {
  'CALL-0.4': {
    ident: 'call',
    type: basicFunctionTypes['CALL-0.4']
  },
  CALL: {
    ident: 'call',
    type: basicFunctionTypes.CALL
  },
  CALLCODE: {
    ident: 'callcode',
    type: basicFunctionTypes['CALL-0.4']
  },
  'DELEGATECALL-0.4': {
    ident: 'delegatecall',
    type: basicFunctionTypes['DELEGATECALL-0.4']
  },
  DELEGATECALL: {
    ident: 'delegatecall',
    type: basicFunctionTypes.DELEGATECALL
  },
  SEND: {
    ident: 'send',
    type: basicFunctionTypes.SEND
  },
  TRANSFER: {
    ident: 'transfer',
    type: basicFunctionTypes.TRANSFER
  }
};
exports.lowLevelCallTypes = lowLevelCallTypes;
const specialVariables = {
  BLOCKTIMESTAMP: {
    obj: 'block',
    member: 'timestamp',
    type: basicTypes.UINT
  },
  BLOCKHASH: {
    obj: 'block',
    member: 'blockhash',
    type: buildFunctionSignature([basicTypes.UINT], [basicTypes.BYTES32], false, 'view')
  }
};
exports.specialVariables = specialVariables;
const abiNamespace = {
  ENCODE: {
    obj: 'abi',
    member: 'encode',
    type: buildFunctionSignature([], [basicTypes.BYTES_MEM], false, 'pure')
  },
  ENCODEPACKED: {
    obj: 'abi',
    member: 'encodePacked',
    type: buildFunctionSignature([], [basicTypes.BYTES_MEM], false, 'pure')
  },
  ENCODE_SELECT: {
    obj: 'abi',
    member: 'encodeWithSelector',
    type: buildFunctionSignature([basicTypes.BYTES4], [basicTypes.BYTES_MEM], false, 'pure')
  },
  ENCODE_SIG: {
    obj: 'abi',
    member: 'encodeWithSignature',
    type: buildFunctionSignature([basicTypes.STRING_MEM], [basicTypes.BYTES_MEM], false, 'pure')
  }
}; // #################### Trivial Getters
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function getType(node) {
  return node.typeDescriptions.typeString;
}

exports.getType = getType; // #################### Complex Getters

/**
 * Returns the type parameter of function call AST nodes. Throws if not a function call node
 * @func {ASTNode} Function call node
 * @return {string} type of function call
 */

function getFunctionCallType(func) {
  return getType(func.expression);
}

exports.getFunctionCallType = getFunctionCallType;
/**
 * Get the variable name written to by a effect node, except for inline assembly because there is no information to find out where we write to. Trows if not a effect node or is inlineassmbly.
 * Example: x = 10; => x
 * @effectNode {ASTNode} Assignmnet node
 * @return {string} variable name written to
 */

function getEffectedVariableName(effectNode) {
  if (!isEffect(effectNode)) throw new Error('staticAnalysisCommon.js: not an effect Node');

  if (effectNode.nodeType === 'Assignment' || effectNode.nodeType === 'UnaryOperation') {
    const IdentNode = findFirstSubNodeLTR(effectNode, exactMatch(nodeTypes.IDENTIFIER));
    return IdentNode.name;
  } else throw new Error('staticAnalysisCommon.js: wrong node type');
}

exports.getEffectedVariableName = getEffectedVariableName;
/**
 * Returns the identifier of a local call, Throws on wrong node.
 * Example: f(103) => f
 * @localCallNode {ASTNode} Function call node
 * @return {string} name of the function called
 */

function getLocalCallName(localCallNode) {
  if (!isLocalCall(localCallNode) && !isAbiNamespaceCall(localCallNode)) throw new Error('staticAnalysisCommon.js: not a local call Node');
  return localCallNode.expression.name;
}

exports.getLocalCallName = getLocalCallName;
/**
 * Returns the identifier of a this local call, Throws on wrong node.
 * Example: this.f(103) => f
 * @localCallNode {ASTNode} Function call node
 * @return {string} name of the function called
 */

function getThisLocalCallName(thisLocalCallNode) {
  if (!isThisLocalCall(thisLocalCallNode.expression)) throw new Error('staticAnalysisCommon.js: not a this local call Node');
  return thisLocalCallNode.expression.memberName;
}

exports.getThisLocalCallName = getThisLocalCallName;
/**
 * Returns the identifier of a super local call, Throws on wrong node.
 * Example: super.f(103) => f
 * @localCallNode {ASTNode} Function call node
 * @return {string} name of the function called
 */

function getSuperLocalCallName(superLocalCallNode) {
  if (!isSuperLocalCall(superLocalCallNode.expression)) throw new Error('staticAnalysisCommon.js: not a super local call Node');
  return superLocalCallNode.expression.memberName;
}

exports.getSuperLocalCallName = getSuperLocalCallName;
/**
 * Returns the contract type of a external direct call, Throws on wrong node.
 * Example:
 *  foo x = foo(0xdeadbeef...);
 *  x.f(103) => foo
 * @extDirectCall {ASTNode} Function call node
 * @return {string} name of the contract the function is defined in
 */

function getExternalDirectCallContractName(extDirectCall) {
  if (!isExternalDirectCall(extDirectCall)) throw new Error('staticAnalysisCommon.js: not an external direct call Node');
  return extDirectCall.expression.expression.typeDescriptions.typeString.replace(new RegExp(basicRegex.CONTRACTTYPE), '');
}

exports.getExternalDirectCallContractName = getExternalDirectCallContractName;
/**
 * Returns the name of the contract of a this local call (current contract), Throws on wrong node.
 * Example:
 * Contract foo {
 *    ...
 *    this.f(103) => foo
 *    ...
 * @thisLocalCall {ASTNode} Function call node
 * @return {string} name of the contract the function is defined in
 */

function getThisLocalCallContractName(thisLocalCall) {
  if (!isThisLocalCall(thisLocalCall.expression)) throw new Error('staticAnalysisCommon.js: not a this local call Node');
  return thisLocalCall.expression.expression.typeDescriptions.typeString.replace(new RegExp(basicRegex.CONTRACTTYPE), '');
}

exports.getThisLocalCallContractName = getThisLocalCallContractName;
/**
 * Returns the function identifier of a external direct call, Throws on wrong node.
 * Example:
 *  foo x = foo(0xdeadbeef...);
 *  x.f(103) => f
 * @extDirectCall {ASTNode} Function call node
 * @return {string} name of the function called
 */

function getExternalDirectCallMemberName(extDirectCall) {
  if (!isExternalDirectCall(extDirectCall)) throw new Error('staticAnalysisCommon.js: not an external direct call Node');
  return extDirectCall.expression.memberName;
}

exports.getExternalDirectCallMemberName = getExternalDirectCallMemberName;
/**
 * Returns the name of a contract, Throws on wrong node.
 * Example:
 *   Contract foo { => foo
 * @contract {ASTNode} Contract Definition node
 * @return {string} name of a contract defined
 */

function getContractName(contract) {
  if (!nodeType(contract, exactMatch(nodeTypes.CONTRACTDEFINITION))) throw new Error('staticAnalysisCommon.js: not a ContractDefinition Node');
  return contract.name;
}

exports.getContractName = getContractName;
/**
 * Returns the name of a function definition, Throws on wrong node.
 * Example:
 *   func foo(uint bla) { => foo
 * @funcDef {ASTNode} Function Definition node
 * @return {string} name of a function defined
 */

function getFunctionDefinitionName(funcDef) {
  if (!nodeType(funcDef, exactMatch(nodeTypes.FUNCTIONDEFINITION))) throw new Error('staticAnalysisCommon.js: not a FunctionDefinition Node');
  return funcDef.name;
}

exports.getFunctionDefinitionName = getFunctionDefinitionName;
/**
 * Returns the identifier of an inheritance specifier, Throws on wrong node.
 * Example:
 *   contract KingOfTheEtherThrone is b { => b
 * @func {ASTNode} Inheritance specifier
 * @return {string} name of contract inherited from
 */

function getInheritsFromName(inheritsNode) {
  if (!nodeType(inheritsNode, exactMatch(nodeTypes.INHERITANCESPECIFIER))) throw new Error('staticAnalysisCommon.js: not an InheritanceSpecifier Node');
  return inheritsNode.baseName.name;
}

exports.getInheritsFromName = getInheritsFromName;
/**
 * Returns the identifier of a variable definition, Throws on wrong node.
 * Example:
 *   var x = 10; => x
 * @varDeclNode {ASTNode} Variable declaration node
 * @return {string} variable name
 */

function getDeclaredVariableName(varDeclNode) {
  if (!nodeType(varDeclNode, exactMatch(nodeTypes.VARIABLEDECLARATION))) throw new Error('staticAnalysisCommon.js: not a VariableDeclaration Node');
  return varDeclNode.name;
}

exports.getDeclaredVariableName = getDeclaredVariableName;
/**
 * Returns the type of a variable definition, Throws on wrong node.
 * Example:
 *   var x = 10; => x
 * @varDeclNode {ASTNode} Variable declaration node
 * @return {string} variable type
 */

function getDeclaredVariableType(varDeclNode) {
  return varDeclNode.typeName.name;
}

exports.getDeclaredVariableType = getDeclaredVariableType;
/**
 * Returns state variable declaration nodes for a contract, Throws on wrong node.
 * Example:
 * contract foo {
 *     ...
 *   var y = true;
 *   var x = 10; => [y,x]
 * @contractNode {ASTNode} Contract Definition node
 * @return {list variable declaration} state variable node list
 */

function getStateVariableDeclarationsFromContractNode(contractNode) {
  return contractNode.nodes.filter(el => el.nodeType === "VariableDeclaration");
}

exports.getStateVariableDeclarationsFromContractNode = getStateVariableDeclarationsFromContractNode;
/**
 * Returns parameter node for a function or modifier definition, Throws on wrong node.
 * Example:
 * function bar(uint a, uint b) => uint a, uint b
 * @funcNode {ASTNode} Contract Definition node
 * @return {parameterlist node} parameterlist node
 */

function getFunctionOrModifierDefinitionParameterPart(funcNode) {
  if (!nodeTypeIn(funcNode, [exactMatch(nodeTypes.FUNCTIONDEFINITION), exactMatch(nodeTypes.MODIFIERDEFINITION)])) throw new Error('staticAnalysisCommon.js: not a FunctionDefinition or ModifierDefinition Node');
  return funcNode.parameters;
}

exports.getFunctionOrModifierDefinitionParameterPart = getFunctionOrModifierDefinitionParameterPart;
/**
 * Returns return parameter node for a function or modifier definition, Throws on wrong node.
 * Example:
 * function bar(uint a, uint b) returns (bool a, bool b) => bool a, bool b
 * @funcNode {ASTNode} Contract Definition node
 * @return {parameterlist node} parameterlist node
 */

function getFunctionDefinitionReturnParameterPart(funcNode) {
  return funcNode.returnParameters;
}

exports.getFunctionDefinitionReturnParameterPart = getFunctionDefinitionReturnParameterPart;
/**
 * Extracts the parameter types for a function type signature
 * Example:
 * function(uint a, uint b) returns (bool) => uint a, uint b
 * @func {ASTNode} function call node
 * @return {string} parameter signature
 */

function getFunctionCallTypeParameterType(func) {
  const type = getFunctionCallType(func);

  if (type.startsWith('function (')) {
    let paramTypes = '';
    let openPar = 1;

    for (let x = 10; x < type.length; x++) {
      const c = type.charAt(x);
      if (c === '(') openPar++;else if (c === ')') openPar--;
      if (openPar === 0) return paramTypes;
      paramTypes += c;
    }
  } else {
    throw new Error('staticAnalysisCommon.js: cannot extract parameter types from function call');
  }
}

exports.getFunctionCallTypeParameterType = getFunctionCallTypeParameterType;
/**
 * Returns the name of the library called, Throws on wrong node.
 * Example:
 *  library set{...}
 *  contract foo {
 *    ...
 *    function () { set.union() => set}
 * @funcCall {ASTNode} function call node
 * @return {string} name of the lib defined
 */

function getLibraryCallContractName(node) {
  if (!isLibraryCall(node.expression)) throw new Error('staticAnalysisCommon.js: not a library call Node');
  const types = new RegExp(basicRegex.LIBRARYTYPE).exec(node.expression.expression.typeDescriptions.typeString);
  if (types) return types[1];
}

exports.getLibraryCallContractName = getLibraryCallContractName;
/**
 * Returns the name of the function of a library call, Throws on wrong node.
 * Example:
 *  library set{...}
 *  contract foo {
 *    ...
 *    function () { set.union() => uinion}
 * @func {ASTNode} function call node
 * @return {string} name of function called on the library
 */

function getLibraryCallMemberName(funcCall) {
  if (!isLibraryCall(funcCall.expression)) throw new Error('staticAnalysisCommon.js: not a library call Node');
  return funcCall.expression.memberName;
}

exports.getLibraryCallMemberName = getLibraryCallMemberName;
/**
 * Returns full qualified name for a function call, Throws on wrong node.
 * Example:
 *  contract foo {
 *    ...
 *    function bar(uint b) { }
 *    function baz() {
 *      bar(10) => foo.bar(uint)
 * @func {ASTNode} function call node
 * @func {ASTNode} contract defintion
 * @return {string} full qualified identifier for the function call
 */

function getFullQualifiedFunctionCallIdent(contract, func) {
  if (isLocalCall(func)) return getContractName(contract) + '.' + getLocalCallName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else if (isThisLocalCall(func.expression)) return getThisLocalCallContractName(func) + '.' + getThisLocalCallName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else if (isSuperLocalCall(func.expression)) return getContractName(contract) + '.' + getSuperLocalCallName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else if (isExternalDirectCall(func)) return getExternalDirectCallContractName(func) + '.' + getExternalDirectCallMemberName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else if (isLibraryCall(func.expression)) return getLibraryCallContractName(func) + '.' + getLibraryCallMemberName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else throw new Error('staticAnalysisCommon.js: Can not get function name from non function call node');
}

exports.getFullQualifiedFunctionCallIdent = getFullQualifiedFunctionCallIdent;

function getFullQuallyfiedFuncDefinitionIdent(contract, func, paramTypes) {
  return getContractName(contract) + '.' + getFunctionDefinitionName(func) + '(' + remix_lib_1.util.concatWithSeperator(paramTypes, ',') + ')';
}

exports.getFullQuallyfiedFuncDefinitionIdent = getFullQuallyfiedFuncDefinitionIdent;

function getUnAssignedTopLevelBinOps(subScope) {
  let result = [];
  if (subScope && subScope.nodeType === 'Block') result = subScope.statements.filter(isBinaryOpInExpression); // for 'without braces' loops
  else if (subScope && subScope.nodeType && subScope.nodeType !== 'Block' && isSubScopeStatement(subScope)) {
      if (subScope.nodeType === 'IfStatement') {
        if (subScope.trueBody && subScope.trueBody.nodeType === "ExpressionStatement" && isBinaryOpInExpression(subScope.trueBody)) result.push(subScope.trueBody);
        if (subScope.falseBody && subScope.falseBody.nodeType === "ExpressionStatement" && isBinaryOpInExpression(subScope.falseBody)) result.push(subScope.falseBody);
      } else {
        if (subScope.body && subScope.body.nodeType === "ExpressionStatement" && isBinaryOpInExpression(subScope.body)) result.push(subScope.body);
      }
    }
  return result;
}

exports.getUnAssignedTopLevelBinOps = getUnAssignedTopLevelBinOps; // #################### Trivial Node Identification
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function isStatement(node) {
  return nodeType(node, 'Statement$') || node.nodeType === "Block" || node.nodeType === "Return";
}

exports.isStatement = isStatement; // #################### Complex Node Identification

/**
 * True if function defintion has function body
 * @funcNode {ASTNode} function defintion node
 * @return {bool}
 */

function hasFunctionBody(funcNode) {
  return funcNode.body !== null;
}

exports.hasFunctionBody = hasFunctionBody;
/**
 * True if node is a delete instruction of a dynamic array
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isDeleteOfDynamicArray(node) {
  return isDeleteUnaryOperation(node) && isDynamicArrayAccess(node.subExpression);
}

exports.isDeleteOfDynamicArray = isDeleteOfDynamicArray;
/**
 * True if node is node is a ref to a dynamic array
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isDynamicArrayAccess(node) {
  return getType(node).endsWith('[] storage ref') || typeDescription(node, 'bytes storage ref') || typeDescription(node, 'string storage ref');
}

exports.isDynamicArrayAccess = isDynamicArrayAccess;
/**
 * True if node accesses 'length' member of dynamic array
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isDynamicArrayLengthAccess(node) {
  return node.memberName === 'length' && // accessing 'length' member
  node.expression['typeDescriptions']['typeString'].indexOf('[]') !== -1; // member is accessed from dynamic array, notice [] without any number
}

exports.isDynamicArrayLengthAccess = isDynamicArrayLengthAccess;
/**
 * True if node is a delete instruction for an element from a dynamic array
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isDeleteFromDynamicArray(node) {
  return isDeleteUnaryOperation(node) && node.subExpression.nodeType === 'IndexAccess';
}

exports.isDeleteFromDynamicArray = isDeleteFromDynamicArray;
/**
 * True if node is the access of a mapping index
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isMappingIndexAccess(node) {
  return node.typeDescriptions.typeString.startsWith('mapping');
}

exports.isMappingIndexAccess = isMappingIndexAccess;
/**
 * True if call to code within the current contracts context including (delegate) library call
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLocalCallGraphRelevantNode(node) {
  return (isLocalCall(node) || isSuperLocalCall(node.expression) || isLibraryCall(node.expression)) && !isBuiltinFunctionCall(node);
}

exports.isLocalCallGraphRelevantNode = isLocalCallGraphRelevantNode;
/**
 * True if is builtin function like assert, sha3, erecover, ...
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isBuiltinFunctionCall(node) {
  return node.nodeType === 'FunctionCall' && isLocalCall(node) && builtinFunctions[getLocalCallName(node) + '(' + getFunctionCallTypeParameterType(node) + ')'] === true || isAbiNamespaceCall(node);
}

exports.isBuiltinFunctionCall = isBuiltinFunctionCall;
/**
 * True if is builtin function like assert, sha3, erecover, ...
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isAbiNamespaceCall(node) {
  return Object.keys(abiNamespace).some(key => Object.prototype.hasOwnProperty.call(abiNamespace, key) && node.expression && isSpecialVariableAccess(node.expression, abiNamespace[key]));
}

exports.isAbiNamespaceCall = isAbiNamespaceCall;
/**
 * True if node is a call to selfdestruct
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isSelfdestructCall(node) {
  return isBuiltinFunctionCall(node) && getLocalCallName(node) === 'selfdestruct';
}

exports.isSelfdestructCall = isSelfdestructCall;
/**
 * True if node is a call to builtin assert(bool)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isAssertCall(node) {
  return isBuiltinFunctionCall(node) && getLocalCallName(node) === 'assert';
}

exports.isAssertCall = isAssertCall;
/**
 * True if node is a call to builtin require(bool)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isRequireCall(node) {
  return isBuiltinFunctionCall(node) && getLocalCallName(node) === 'require';
}

exports.isRequireCall = isRequireCall;
/**
 * True if is storage variable declaration
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isStorageVariableDeclaration(node) {
  return node.storageLocation === 'storage' && new RegExp(basicRegex.REFTYPE).test(node.typeDescriptions.typeIdentifier);
}

exports.isStorageVariableDeclaration = isStorageVariableDeclaration;
/**
 * True if is interaction with external contract (change in context, no delegate calls) (send, call of other contracts)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isInteraction(node) {
  return isLLCall(node.expression) || isLLSend(node.expression) || isExternalDirectCall(node) || isTransfer(node.expression) || isLLCall04(node.expression) || isLLSend04(node.expression) || // to cover case of address.call.value.gas , See: inheritance.sol  
  node.expression && node.expression.expression && isLLCall(node.expression.expression) || node.expression && node.expression.expression && isLLCall04(node.expression.expression);
}

exports.isInteraction = isInteraction;
/**
 * True if node changes state of a variable or is inline assembly (does not include check if it is a global state change, on a state variable)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isEffect(node) {
  return node.nodeType === "Assignment" || node.nodeType === "UnaryOperation" && (isPlusPlusUnaryOperation(node) || isMinusMinusUnaryOperation(node)) || node.nodeType === "InlineAssembly";
}

exports.isEffect = isEffect;
/**
 * True if node changes state of a variable or is inline assembly (Checks if variable is a state variable via provided list)
 * @node {ASTNode} some AstNode
 * @node {list Variable declaration} state variable declaration currently in scope
 * @return {bool}
 */

function isWriteOnStateVariable(effectNode, stateVariables) {
  return effectNode.nodeType === "InlineAssembly" || isEffect(effectNode) && isStateVariable(getEffectedVariableName(effectNode), stateVariables);
}

exports.isWriteOnStateVariable = isWriteOnStateVariable;
/**
 * True if there is a variable with name, name in stateVariables
 * @node {ASTNode} some AstNode
 * @node {list Variable declaration} state variable declaration currently in scope
 * @return {bool}
 */

function isStateVariable(name, stateVariables) {
  return stateVariables.some(item => item.stateVariable && name === getDeclaredVariableName(item));
}

exports.isStateVariable = isStateVariable;
/**
 * True if is function defintion that is flaged as constant
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isConstantFunction(node) {
  return node.stateMutability === 'view' || node.stateMutability === 'pure';
}

exports.isConstantFunction = isConstantFunction;
/**
* True if variable decalaration is converted into a getter method
 * @node {ASTNode} variable declaration AstNode
 * @return {bool}
 */

function isVariableTurnedIntoGetter(varDeclNode) {
  return varDeclNode.stateVariable && varDeclNode.visibility === 'public';
}

exports.isVariableTurnedIntoGetter = isVariableTurnedIntoGetter;
/**
 * True if is function defintion has payable modifier
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isPayableFunction(node) {
  return node.stateMutability === 'payable';
}

exports.isPayableFunction = isPayableFunction;
/**
 * True if is constructor
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isConstructor(node) {
  return node.kind === "constructor";
}

exports.isConstructor = isConstructor;
/**
 * True if node is integer division that truncates (not only int literals since those yield a rational value)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isIntDivision(node) {
  return operator(node, exactMatch(remix_lib_1.util.escapeRegExp('/'))) && typeDescription(node.rightExpression, remix_lib_1.util.escapeRegExp('int'));
}

exports.isIntDivision = isIntDivision;
/**
 * True if is block / SubScope has top level binops (e.g. that are not assigned to anything, most of the time confused compare instead of assign)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isSubScopeWithTopLevelUnAssignedBinOp(node) {
  if (node.nodeType === 'Block') return node.statements.some(isBinaryOpInExpression); // for 'without braces' loops
  else if (node && node.nodeType && isSubScopeStatement(node)) {
      if (node.nodeType === 'IfStatement') return node.trueBody && node.trueBody.nodeType === "ExpressionStatement" && isBinaryOpInExpression(node.trueBody) || node.falseBody && node.falseBody.nodeType === "ExpressionStatement" && isBinaryOpInExpression(node.falseBody);else return node.body && node.body.nodeType === "ExpressionStatement" && isBinaryOpInExpression(node.body);
    }
}

exports.isSubScopeWithTopLevelUnAssignedBinOp = isSubScopeWithTopLevelUnAssignedBinOp;

function isSubScopeStatement(node) {
  if (node.nodeType === 'IfStatement') return node.trueBody && node.trueBody.nodeType && !nodeType(node.trueBody, exactMatch(nodeTypes.BLOCK)) || node.falseBody && node.falseBody.nodeType && !nodeType(node.falseBody, exactMatch(nodeTypes.BLOCK));else return node.body && node.body.nodeType && !nodeType(node.body, exactMatch(nodeTypes.BLOCK));
}
/**
 * True if binary operation inside of expression statement
 * @node {ASTNode} some AstNode
 * @return {bool}
 */


function isBinaryOpInExpression(node) {
  return node.nodeType === "ExpressionStatement" && node.expression.nodeType === "BinaryOperation";
}
/**
 * True if unary increment operation
 * @node {ASTNode} some AstNode
 * @return {bool}
 */


function isPlusPlusUnaryOperation(node) {
  return node.operator === '++';
}

exports.isPlusPlusUnaryOperation = isPlusPlusUnaryOperation;
/**
 * True if unary delete operation
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isDeleteUnaryOperation(node) {
  return node.operator === 'delete';
}

exports.isDeleteUnaryOperation = isDeleteUnaryOperation;
/**
 * True if unary decrement operation
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isMinusMinusUnaryOperation(node) {
  return node.operator === '--';
}

exports.isMinusMinusUnaryOperation = isMinusMinusUnaryOperation;
/**
 * True if all functions on a contract are implemented
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isFullyImplementedContract(node) {
  return node.fullyImplemented === true;
}

exports.isFullyImplementedContract = isFullyImplementedContract;
/**
 * True if it is a library contract defintion
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLibrary(node) {
  return node.contractKind === 'library';
}

exports.isLibrary = isLibrary;
/**
 * True if it is a local call to non const function
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isCallToNonConstLocalFunction(node) {
  return isLocalCall(node) && !expressionTypeDescription(node, basicRegex.CONSTANTFUNCTIONTYPE);
}

exports.isCallToNonConstLocalFunction = isCallToNonConstLocalFunction;
/**
 * True if it is a call to a library
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLibraryCall(node) {
  return isMemberAccess(node, basicRegex.FUNCTIONTYPE, undefined, basicRegex.LIBRARYTYPE, undefined);
}

exports.isLibraryCall = isLibraryCall;
/**
 * True if it is an external call via defined interface (not low level call)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isExternalDirectCall(node) {
  return isMemberAccess(node.expression, basicRegex.EXTERNALFUNCTIONTYPE, undefined, basicRegex.CONTRACTTYPE, undefined) && !isThisLocalCall(node.expression) && !isSuperLocalCall(node.expression);
}

exports.isExternalDirectCall = isExternalDirectCall;
/**
 * True if access to block.timestamp via now alias
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isNowAccess(node) {
  return node.name === "now" && typeDescription(node, exactMatch(basicTypes.UINT));
}

exports.isNowAccess = isNowAccess;
/**
 * True if access to block.timestamp via now alias
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isTxOriginAccess(node) {
  return isMemberAccess(node, 'address', 'tx', 'tx', 'origin');
}

exports.isTxOriginAccess = isTxOriginAccess;
/**
 * True if access to block.timestamp
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isBlockTimestampAccess(node) {
  return isSpecialVariableAccess(node, specialVariables.BLOCKTIMESTAMP);
}

exports.isBlockTimestampAccess = isBlockTimestampAccess;
/**
 * True if access to block.blockhash
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isBlockBlockHashAccess(node) {
  return isBuiltinFunctionCall(node) && getLocalCallName(node) === 'blockhash' || isSpecialVariableAccess(node.expression, specialVariables.BLOCKHASH);
}

exports.isBlockBlockHashAccess = isBlockBlockHashAccess;
/**
 * True if call to local function via this keyword
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isThisLocalCall(node) {
  return isMemberAccess(node, basicRegex.FUNCTIONTYPE, exactMatch('this'), basicRegex.CONTRACTTYPE, undefined);
}

exports.isThisLocalCall = isThisLocalCall;
/**
 * True if access to local function via super keyword
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isSuperLocalCall(node) {
  return isMemberAccess(node, basicRegex.FUNCTIONTYPE, exactMatch('super'), basicRegex.CONTRACTTYPE, undefined);
}

exports.isSuperLocalCall = isSuperLocalCall;
/**
 * True if call to local function
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLocalCall(node) {
  return node.nodeType === 'FunctionCall' && node.kind === 'functionCall' && node.expression.nodeType === 'Identifier' && expressionTypeDescription(node, basicRegex.FUNCTIONTYPE) && !expressionTypeDescription(node, basicRegex.EXTERNALFUNCTIONTYPE);
}

exports.isLocalCall = isLocalCall;
/**
 * True if low level call (send, call, delegatecall, callcode)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLowLevelCall(node) {
  return isLLCall(node) || isLLDelegatecall(node) || isLLSend(node) || isLLSend04(node) || isLLCallcode(node) || isLLCall04(node) || isLLDelegatecall04(node);
}

exports.isLowLevelCall = isLowLevelCall;
/**
 * True if low level send (solidity < 0.5)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLSend04(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.SEND.type)), undefined, exactMatch(basicTypes.ADDRESS), exactMatch(lowLevelCallTypes.SEND.ident));
}

exports.isLLSend04 = isLLSend04;
/**
 * True if low level send (solidity >= 0.5)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLSend(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.SEND.type)), undefined, exactMatch(basicTypes.PAYABLE_ADDRESS), exactMatch(lowLevelCallTypes.SEND.ident));
}

exports.isLLSend = isLLSend;
/**
 * True if low level call
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLCall(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.CALL.type)), undefined, exactMatch(basicTypes.ADDRESS), exactMatch(lowLevelCallTypes.CALL.ident)) || isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.CALL.type)), undefined, exactMatch(basicTypes.PAYABLE_ADDRESS), exactMatch(lowLevelCallTypes.CALL.ident));
}

exports.isLLCall = isLLCall;
/**
 * True if low level payable call (solidity < 0.5)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLCall04(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes['CALL-0.4'].type)), undefined, exactMatch(basicTypes.ADDRESS), exactMatch(lowLevelCallTypes['CALL-0.4'].ident));
}

exports.isLLCall04 = isLLCall04;
/**
 * True if low level callcode
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLCallcode(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.CALLCODE.type)), undefined, exactMatch(basicTypes.ADDRESS), exactMatch(lowLevelCallTypes.CALLCODE.ident));
}

exports.isLLCallcode = isLLCallcode;
/**
 * True if low level delegatecall
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLDelegatecall(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.DELEGATECALL.type)), undefined, matches(basicTypes.PAYABLE_ADDRESS, basicTypes.ADDRESS), exactMatch(lowLevelCallTypes.DELEGATECALL.ident));
}

exports.isLLDelegatecall = isLLDelegatecall;
/**
 * True if low level delegatecall (solidity < 0.5)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLDelegatecall04(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes['DELEGATECALL-0.4'].type)), undefined, matches(basicTypes.PAYABLE_ADDRESS, basicTypes.ADDRESS), exactMatch(lowLevelCallTypes['DELEGATECALL-0.4'].ident));
}

exports.isLLDelegatecall04 = isLLDelegatecall04;
/**
 * True if transfer call
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isTransfer(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.TRANSFER.type)), undefined, matches(basicTypes.ADDRESS, basicTypes.PAYABLE_ADDRESS), exactMatch(lowLevelCallTypes.TRANSFER.ident));
}

exports.isTransfer = isTransfer;

function isStringToBytesConversion(node) {
  return isExplicitCast(node, remix_lib_1.util.escapeRegExp('string *'), remix_lib_1.util.escapeRegExp('bytes'));
}

exports.isStringToBytesConversion = isStringToBytesConversion;

function isExplicitCast(node, castFromType, castToType) {
  return node.kind === "typeConversion" && nodeType(node.expression, exactMatch(nodeTypes.ELEMENTARYTYPENAMEEXPRESSION)) && node.expression.typeName === castToType && nodeType(node.arguments[0], exactMatch(nodeTypes.IDENTIFIER)) && typeDescription(node.arguments[0], castFromType);
}

function isBytesLengthCheck(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(basicTypes.UINT)), undefined, remix_lib_1.util.escapeRegExp('bytes *'), 'length');
}

exports.isBytesLengthCheck = isBytesLengthCheck;
/**
 * True if it is a loop
 * @node {ASTNode} some AstNode
 * @return {bool}
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function isLoop(node) {
  return nodeType(node, exactMatch(nodeTypes.FORSTATEMENT)) || nodeType(node, exactMatch(nodeTypes.WHILESTATEMENT)) || nodeType(node, exactMatch(nodeTypes.DOWHILESTATEMENT));
}

exports.isLoop = isLoop; // #################### Complex Node Identification - Private

function isMemberAccess(node, retType, accessor, accessorType, memberName) {
  if (node && nodeType(node, exactMatch('MemberAccess'))) {
    const nodeTypeDef = typeDescription(node, retType);
    const nodeMemName = memName(node, memberName);
    const nodeExpMemName = memName(node.expression, accessor);
    const nodeExpTypeDef = expressionTypeDescription(node, accessorType);
    return nodeTypeDef && nodeMemName && nodeExpTypeDef && nodeExpMemName;
  } else return false;
}

function isSpecialVariableAccess(node, varType) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(varType.type)), varType.obj, varType.obj, varType.member);
}

exports.isSpecialVariableAccess = isSpecialVariableAccess; // #################### Node Identification Primitives
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function expressionTypeDescription(node, typeRegex) {
  return new RegExp(typeRegex).test(node.expression.typeDescriptions.typeString);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function typeDescription(node, typeRegex) {
  return new RegExp(typeRegex).test(node.typeDescriptions.typeString);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function nodeType(node, typeRegex) {
  return new RegExp(typeRegex).test(node.nodeType);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function nodeTypeIn(node, typeRegex) {
  return typeRegex.some(typeRegex => nodeType(node, typeRegex));
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function memName(node, memNameRegex) {
  return node && !memNameRegex || new RegExp(memNameRegex).test(node.name) || new RegExp(memNameRegex).test(node.memberName);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function operator(node, opRegex) {
  return new RegExp(opRegex).test(node.operator);
} // #################### Helpers


function exactMatch(regexStr) {
  return '^' + regexStr + '$';
}

function matches(...fnArgs) {
  const args = [];

  for (let k = 0; k < fnArgs.length; k++) {
    args.push(fnArgs[k]);
  }

  return '(' + args.join('|') + ')';
}
/**
 * Finds first node of a certain type under a specific node.
 * @node {AstNode} node to start form
 * @type {String} Type the ast node should have
 * @return {AstNode} null or node found
 * Note: developed keeping identifier node search in mind to get first identifier node from left in subscope
 */


function findFirstSubNodeLTR(node, type) {
  if (node.nodeType && nodeType(node, type)) return node;else if (node.nodeType && nodeType(node, exactMatch('Assignment'))) return findFirstSubNodeLTR(node.leftHandSide, type);else if (node.nodeType && nodeType(node, exactMatch('MemberAccess'))) return findFirstSubNodeLTR(node.expression, type);else if (node.nodeType && nodeType(node, exactMatch('IndexAccess'))) return findFirstSubNodeLTR(node.baseExpression, type);else if (node.nodeType && nodeType(node, exactMatch('UnaryOperation'))) return findFirstSubNodeLTR(node.subExpression, type);
}
/**
 * Builds a function signature as used in the AST of the solc-json AST
 * @param {Array} paramTypes
 *  list of parameter type names
 * @param {Array} returnTypes
 *  list of return type names
 * @return {Boolean} isPayable
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function buildFunctionSignature(paramTypes, returnTypes, isPayable, additionalMods) {
  return 'function (' + remix_lib_1.util.concatWithSeperator(paramTypes, ',') + ')' + (isPayable ? ' payable' : '') + (additionalMods ? ' ' + additionalMods : '') + (returnTypes.length ? ' returns (' + remix_lib_1.util.concatWithSeperator(returnTypes, ',') + ')' : '');
}

function buildAbiSignature(funName, paramTypes) {
  return funName + '(' + remix_lib_1.util.concatWithSeperator(paramTypes, ',') + ')';
} // To create the method signature similar to contract.evm.gasEstimates.external object
// For address payable, return address 


function getMethodParamsSplittedTypeDesc(node, contracts) {
  return node.parameters.parameters.map((varNode, varIndex) => {
    let finalTypeString;
    const typeString = varNode.typeDescriptions.typeString;

    if (typeString.includes('struct')) {
      const fnName = node.name;

      for (const filename in contracts) {
        for (const contractName in contracts[filename]) {
          const methodABI = contracts[filename][contractName].abi.find(e => {
            var _a;

            return e.name === fnName && ((_a = e.inputs) === null || _a === void 0 ? void 0 : _a.length) && e.inputs[varIndex]['type'].includes('tuple') && e.inputs[varIndex]['internalType'] === typeString;
          });

          if (methodABI && methodABI.inputs) {
            const inputs = methodABI.inputs[varIndex];
            const typeStr = getTypeStringFromComponents(inputs['components']);
            finalTypeString = typeStr + inputs['type'].replace('tuple', '');
          }
        }
      }
    } else finalTypeString = typeString.split(' ')[0];

    return finalTypeString;
  });
}

exports.getMethodParamsSplittedTypeDesc = getMethodParamsSplittedTypeDesc;

function getTypeStringFromComponents(components) {
  let typeString = '(';

  for (let i = 0; i < components.length; i++) {
    const param = components[i];

    if (param.type.includes('tuple') && param.components && param.components.length > 0) {
      typeString = typeString + getTypeStringFromComponents(param.components);
      typeString = typeString + param.type.replace('tuple', '');
    } else typeString = typeString + param.type;

    if (i !== components.length - 1) typeString = typeString + ',';
  }

  typeString = typeString + ')';
  return typeString;
}
/**
 * Get compiler version from compiler contract object
 * This is used to redirect the user to specific version of Solidity documentation
 * @param contractFiles compiled contract object
 */


function getCompilerVersion(contractFiles) {
  let version = 'latest';
  const fileNames = Object.keys(contractFiles);
  const contracts = contractFiles[fileNames[0]];
  const contractNames = Object.keys(contracts);
  const contract = contracts[contractNames[0]]; // For some compiler/contract,  metadata is ""

  if (contract && contract.metadata) {
    const metadata = JSON.parse(contract.metadata);
    const compilerVersion = metadata.compiler.version;
    if (!compilerVersion.includes('nightly')) version = 'v' + compilerVersion.split('+commit')[0];
  }

  return version;
}

exports.getCompilerVersion = getCompilerVersion;
const helpers = {
  expressionTypeDescription,
  nodeType,
  memName,
  operator,
  buildFunctionSignature,
  buildAbiSignature
};
exports.helpers = helpers;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/stringBytesLength.js":
/*!************************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/stringBytesLength.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class stringBytesLength {
  constructor() {
    this.name = `String length: `;
    this.description = `Bytes length != String length`;
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.stringToBytesConversions = [];
    this.bytesLengthChecks = [];
  }

  visit(node) {
    if (node.nodeType === "FunctionCall" && staticAnalysisCommon_1.isStringToBytesConversion(node)) this.stringToBytesConversions.push(node);else if (node.nodeType === "MemberAccess" && staticAnalysisCommon_1.isBytesLengthCheck(node)) this.bytesLengthChecks.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);

    if (this.stringToBytesConversions.length > 0 && this.bytesLengthChecks.length > 0) {
      return [{
        warning: `"bytes" and "string" lengths are not the same since strings are assumed to be UTF-8 encoded (according to the ABI defintion) therefore one character is not nessesarily encoded in one byte of data.`,
        location: this.bytesLengthChecks[0].src,
        more: `https://solidity.readthedocs.io/en/${version}/abi-spec.html#argument-encoding`
      }];
    } else {
      return [];
    }
  }

}

exports.default = stringBytesLength;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/thisLocal.js":
/*!****************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/thisLocal.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

class thisLocal {
  constructor() {
    this.warningNodes = [];
    this.name = `This on local calls: `;
    this.description = `Invocation of local functions via 'this'`;
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (node.nodeType === 'MemberAccess' && staticAnalysisCommon_1.isThisLocalCall(node)) this.warningNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.warningNodes.map(function (item, i) {
      return {
        warning: `Use of "this" for local functions: Never use "this" to call functions in the same contract, it only consumes more gas than normal local calls.`,
        location: item.src,
        more: `https://solidity.readthedocs.io/en/${version}/control-structures.html#external-function-calls`
      };
    });
  }

}

exports.default = thisLocal;

/***/ }),

/***/ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/txOrigin.js":
/*!***************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-analyzer/solidity-analyzer/modules/txOrigin.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const categories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./categories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/categories.js"));

const algorithmCategories_1 = tslib_1.__importDefault(__webpack_require__(/*! ./algorithmCategories */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/algorithmCategories.js"));

const staticAnalysisCommon_1 = __webpack_require__(/*! ./staticAnalysisCommon */ "../../../dist/libs/remix-analyzer/solidity-analyzer/modules/staticAnalysisCommon.js");

class txOrigin {
  constructor() {
    this.txOriginNodes = [];
    this.name = `Transaction origin: `;
    this.description = `'tx.origin' used`;
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (staticAnalysisCommon_1.isTxOriginAccess(node)) this.txOriginNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = staticAnalysisCommon_1.getCompilerVersion(compilationResults.contracts);
    return this.txOriginNodes.map((item, i) => {
      return {
        warning: `Use of tx.origin: "tx.origin" is useful only in very exceptional cases. 
                  If you use it for authentication, you usually want to replace it by "msg.sender", because otherwise any contract you call can act on your behalf.`,
        location: item.src,
        more: `https://solidity.readthedocs.io/en/${version}/security-considerations.html#tx-origin`
      };
    });
  }

}

exports.default = txOrigin;

/***/ }),

/***/ "../../../dist/libs/remix-astwalker/astWalker.js":
/*!***************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-astwalker/astWalker.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const events_1 = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

const isObject = function (obj) {
  return obj != null && obj.constructor.name === "Object";
};

function isAstNode(node) {
  return isObject(node) && 'id' in node && 'nodeType' in node && 'src' in node;
}

exports.isAstNode = isAstNode;
/**
 * Crawl the given AST through the function walk(ast, callback)
 */

/**
 * visit all the AST nodes
 *
 * @param {Object} ast  - AST node
 * @return EventEmitter
 * event('node', <Node Type | false>) will be fired for every node of type <Node Type>.
 * event('node', "*") will be fired for all other nodes.
 * in each case, if the event emits false it does not descend into children.
 * If no event for the current type, children are visited.
 */

class AstWalker extends events_1.EventEmitter {
  manageCallback(node, callback // eslint-disable-line @typescript-eslint/ban-types
  ) {
    // FIXME: we shouldn't be doing this callback determination type on each AST node,
    // since the callback function is set once per walk.
    // Better would be to store the right one as a variable and
    // return that.
    if (node) {
      if (node.name in callback) {
        return callback[node.name](node);
      } else {
        return callback["*"](node);
      }
    }

    if (node) {
      if (node.nodeType in callback) {
        /* istanbul ignore next */
        return callback[node.nodeType](node);
      } else {
        /* istanbul ignore next */
        return callback["*"](node);
      }
    }
  } // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types


  walk(ast, callback) {
    if (callback) {
      if (callback instanceof Function) {
        callback = Object({
          "*": callback
        });
      }

      if (!("*" in callback)) {
        callback["*"] = function () {
          return true;
        };
      }

      if (ast) {
        if (this.manageCallback(ast, callback) && ast.children && ast.children.length > 0) {
          for (const k in ast.children) {
            const child = ast.children[k];
            this.walk(child, callback);
          }
        }
      } else if (ast) {
        if (this.manageCallback(ast, callback) && ast.nodes && ast.nodes.length > 0) {
          for (const k in ast.nodes) {
            const child = ast.nodes[k];
            this.walk(child, callback);
          }
        }
      }
    } else {
      if (ast) {
        if (ast.children && ast.children.length > 0) {
          for (const k in ast.children) {
            const child = ast.children[k];
            this.emit("node", child);
            this.walk(child);
          }
        }
      }

      if (ast) {
        if (ast.nodes && ast.nodes.length > 0) {
          for (const k in ast.nodes) {
            const child = ast.nodes[k];
            this.emit("node", child);
            this.walk(child);
          }
        }
      }
    }
  } // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types


  walkFullInternal(ast, callback) {
    if (isAstNode(ast)) {
      // console.log(`XXX id ${ast.id}, nodeType: ${ast.nodeType}, src: ${ast.src}`);
      callback(ast);

      for (const k of Object.keys(ast)) {
        // Possible optimization:
        // if (k in ['id', 'src', 'nodeType']) continue;
        const astItem = ast[k];

        if (Array.isArray(astItem)) {
          for (const child of astItem) {
            if (child) {
              this.walkFullInternal(child, callback);
            }
          }
        } else {
          this.walkFullInternal(astItem, callback);
        }
      }
    }
  } // Normalizes parameter callback and calls walkFullInternal
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


  walkFull(ast, callback) {
    if (!isAstNode(ast)) throw new TypeError("first argument should be an ast");
    return this.walkFullInternal(ast, callback);
  } // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types


  walkAstList(sourcesList, cb) {
    if (cb) {
      if (sourcesList.ast) {
        this.walk(sourcesList.ast, cb);
      } else {
        this.walk(sourcesList.legacyAST, cb);
      }
    } else {
      if (sourcesList.ast) {
        this.walk(sourcesList.ast);
      } else {
        this.walk(sourcesList.legacyAST);
      }
    }
  }

}

exports.AstWalker = AstWalker;

/***/ }),

/***/ "../../../dist/libs/remix-astwalker/index.js":
/*!***********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-astwalker/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

tslib_1.__exportStar(__webpack_require__(/*! ./astWalker */ "../../../dist/libs/remix-astwalker/astWalker.js"), exports);

tslib_1.__exportStar(__webpack_require__(/*! ./sourceMappings */ "../../../dist/libs/remix-astwalker/sourceMappings.js"), exports);

/***/ }),

/***/ "../../../dist/libs/remix-astwalker/sourceMappings.js":
/*!********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-astwalker/sourceMappings.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const astWalker_1 = __webpack_require__(/*! ./astWalker */ "../../../dist/libs/remix-astwalker/astWalker.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");
/**
 * Turn an character offset into a "LineColPosition".
 *
 * @param offset  The character offset to convert.
 */


function lineColPositionFromOffset(offset, lineBreaks) {
  let line = remix_lib_1.util.findLowerBound(offset, lineBreaks);

  if (lineBreaks[line] !== offset) {
    line += 1;
  }

  const beginColumn = line === 0 ? 0 : lineBreaks[line - 1] + 1;
  return {
    line: line + 1,
    character: offset - beginColumn + 1
  };
}

exports.lineColPositionFromOffset = lineColPositionFromOffset;
/**
 * Turn a solc AST's "src" attribute string (s:l:f)
 * into a Location
 *
 * @param astNode  The object to convert.
 */

function sourceLocationFromAstNode(astNode) {
  if (astWalker_1.isAstNode(astNode) && astNode.src) {
    return sourceLocationFromSrc(astNode.src);
  }

  return null;
}

exports.sourceLocationFromAstNode = sourceLocationFromAstNode;
/**
 * Break out fields of solc AST's "src" attribute string (s:l:f)
 * into its "start", "length", and "file index" components
 * and return that as a Location
 *
 * @param src  A solc "src" field.
 * @returns {Location}
 */

function sourceLocationFromSrc(src) {
  const split = src.split(':');
  return {
    start: parseInt(split[0], 10),
    length: parseInt(split[1], 10),
    file: parseInt(split[2], 10)
  };
}

exports.sourceLocationFromSrc = sourceLocationFromSrc;
/**
 * Routines for retrieving solc AST object(s) using some criteria, usually
 * includng "src' information.
 */

class SourceMappings {
  constructor(source) {
    this.source = source; // Create a list of line offsets which will be used to map between
    // character offset and line/column positions.

    const lineBreaks = [];

    for (let pos = source.indexOf('\n'); pos >= 0; pos = source.indexOf('\n', pos + 1)) {
      lineBreaks.push(pos);
    }

    this.lineBreaks = lineBreaks;
  }

  /**
   * Get a list of nodes that are at the given "position".
   *
   * @param astNodeType  Type of node to return or null.
   * @param position     Character offset where AST node should be located.
   */
  nodesAtPosition(astNodeType, position, ast) {
    const astWalker = new astWalker_1.AstWalker();
    const found = [];

    const callback = function (node) {
      const nodeLocation = sourceLocationFromAstNode(node);

      if (nodeLocation && nodeLocation.start == position.start && nodeLocation.length == position.length) {
        if (!astNodeType || astNodeType === node.nodeType) {
          found.push(node);
        }
      }

      return true;
    };

    astWalker.walkFull(ast, callback);
    return found;
  }
  /**
   * Retrieve the first "astNodeType" that includes the source map at arg instIndex, or "null" if none found.
   *
   * @param astNodeType   nodeType that a found ASTNode must be. Use "null" if any ASTNode can match.
   * @param sourceLocation "src" location that the AST node must match.
   */


  findNodeAtSourceLocation(astNodeType, sourceLocation, ast) {
    const astWalker = new astWalker_1.AstWalker();
    let found = null;
    /* FIXME: Looking at AST walker code,
       I don't understand a need to return a boolean. */

    const callback = function (node) {
      const nodeLocation = sourceLocationFromAstNode(node);

      if (nodeLocation && nodeLocation.start == sourceLocation.start && nodeLocation.length == sourceLocation.length) {
        if (astNodeType == undefined || astNodeType === node.nodeType) {
          found = node;
        }
      }

      return true;
    };

    astWalker.walkFull(ast, callback);
    return found;
  }
  /**
   * Retrieve the line/column range position for the given source-mapping string.
   *
   * @param src  Solc "src" object containing attributes {source} and {length}.
   */


  srcToLineColumnRange(src) {
    const sourceLocation = sourceLocationFromSrc(src);

    if (sourceLocation.start >= 0 && sourceLocation.length >= 0) {
      return {
        start: lineColPositionFromOffset(sourceLocation.start, this.lineBreaks),
        end: lineColPositionFromOffset(sourceLocation.start + sourceLocation.length, this.lineBreaks)
      };
    } else {
      return {
        start: null,
        end: null
      };
    }
  }

}

exports.SourceMappings = SourceMappings;

/***/ }),

/***/ "../../../dist/libs/remix-debug/index.js":
/*!*******************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EthDebugger = __webpack_require__(/*! ./src/Ethdebugger */ "../../../dist/libs/remix-debug/src/Ethdebugger.js");

const TransactionDebugger = __webpack_require__(/*! ./src/debugger/debugger */ "../../../dist/libs/remix-debug/src/debugger/debugger.js");

const CmdLine = __webpack_require__(/*! ./src/cmdline */ "../../../dist/libs/remix-debug/src/cmdline/index.js");

const StorageViewer = __webpack_require__(/*! ./src/storage/storageViewer */ "../../../dist/libs/remix-debug/src/storage/storageViewer.js");

const StorageResolver = __webpack_require__(/*! ./src/storage/storageResolver */ "../../../dist/libs/remix-debug/src/storage/storageResolver.js");

const SolidityDecoder = __webpack_require__(/*! ./src/solidity-decoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/index.js");

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const BreakpointManager = remixLib.code.BreakpointManager;
/*
  Use of breakPointManager :

  var breakPointManager = new BreakpointManager(this.debugger, (sourceLocation) => {
    return line/column from offset (sourceLocation)
  })
  this.debugger.setBreakpointManager(breakPointManager)
*/

module.exports = {
  EthDebugger: EthDebugger,
  TransactionDebugger: TransactionDebugger,

  /**
   * constructor
   *
   * @param {Object} _debugger - type of EthDebugger
   * @return {Function} _locationToRowConverter - function implemented by editor which return a column/line position for a char source location
   */
  BreakpointManager: BreakpointManager,
  SolidityDecoder: SolidityDecoder,
  storage: {
    StorageViewer: StorageViewer,
    StorageResolver: StorageResolver
  },
  CmdLine: CmdLine
};

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/Ethdebugger.js":
/*!*****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/Ethdebugger.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const StorageViewer = __webpack_require__(/*! ./storage/storageViewer */ "../../../dist/libs/remix-debug/src/storage/storageViewer.js");

const StorageResolver = __webpack_require__(/*! ./storage/storageResolver */ "../../../dist/libs/remix-debug/src/storage/storageResolver.js");

const SolidityDecoder = __webpack_require__(/*! ./solidity-decoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/index.js");

const SolidityProxy = SolidityDecoder.SolidityProxy;
const stateDecoder = SolidityDecoder.stateDecoder;
const localDecoder = SolidityDecoder.localDecoder;
const InternalCallTree = SolidityDecoder.InternalCallTree;

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const TraceManager = remixLib.trace.TraceManager;
const CodeManager = remixLib.code.CodeManager;
const traceHelper = remixLib.helpers.trace;
const EventManager = remixLib.EventManager;
/**
  * Ethdebugger is a wrapper around a few classes that helps debugging a transaction
  *
  * - Web3Providers - define which environment (web3) the transaction will be retrieved from
  * - TraceManager - Load / Analyze the trace and retrieve details of specific test
  * - CodeManager - Retrieve loaded byte code and help to resolve AST item from vmtrace index
  * - SolidityProxy - Basically used to extract state variable from AST
  * - Breakpoint Manager - Used to add / remove / jumpto breakpoint
  * - InternalCallTree - Used to retrieved local variables
  * - StorageResolver - Help resolving the storage accross different steps
  *
  * @param {Map} opts  -  { function compilationResult } //
  */

function Ethdebugger(opts) {
  this.compilationResult = opts.compilationResult || function (contractAddress) {
    return null;
  };

  this.web3 = opts.web3;
  this.event = new EventManager();
  this.tx;
  this.traceManager = new TraceManager({
    web3: this.web3
  });
  this.codeManager = new CodeManager(this.traceManager);
  this.solidityProxy = new SolidityProxy(this.traceManager, this.codeManager);
  this.storageResolver = null;
  this.callTree = new InternalCallTree(this.event, this.traceManager, this.solidityProxy, this.codeManager, {
    includeLocalVariables: true
  });
}

Ethdebugger.prototype.setManagers = function () {
  this.traceManager = new TraceManager({
    web3: this.web3
  });
  this.codeManager = new CodeManager(this.traceManager);
  this.solidityProxy = new SolidityProxy(this.traceManager, this.codeManager);
  this.storageResolver = null;
  this.callTree = new InternalCallTree(this.event, this.traceManager, this.solidityProxy, this.codeManager, {
    includeLocalVariables: true
  });
};

Ethdebugger.prototype.resolveStep = function (index) {
  this.codeManager.resolveStep(index, this.tx);
};

Ethdebugger.prototype.setCompilationResult = function (compilationResult) {
  if (compilationResult && compilationResult.data) {
    this.solidityProxy.reset(compilationResult.data);
  } else {
    this.solidityProxy.reset({});
  }
};
/* resolve source location */


Ethdebugger.prototype.sourceLocationFromVMTraceIndex = function (address, stepIndex, callback) {
  this.callTree.sourceLocationTracker.getSourceLocationFromVMTraceIndex(address, stepIndex, this.solidityProxy.contracts, (error, rawLocation) => {
    callback(error, rawLocation);
  });
};

Ethdebugger.prototype.sourceLocationFromInstructionIndex = function (address, instIndex, callback) {
  this.callTree.sourceLocationTracker.getSourceLocationFromInstructionIndex(address, instIndex, this.solidityProxy.contracts, (error, rawLocation) => {
    callback(error, rawLocation);
  });
};
/* breakpoint */


Ethdebugger.prototype.setBreakpointManager = function (breakpointManager) {
  this.breakpointManager = breakpointManager;
};
/* decode locals */


Ethdebugger.prototype.extractLocalsAt = function (step, callback) {
  callback(null, this.callTree.findScope(step));
};

Ethdebugger.prototype.decodeLocalsAt = function (step, sourceLocation, callback) {
  this.traceManager.waterfall([this.traceManager.getStackAt, this.traceManager.getMemoryAt, this.traceManager.getCurrentCalledAddressAt], step, (error, result) => {
    if (!error) {
      const stack = result[0].value;
      const memory = result[1].value;

      try {
        const storageViewer = new StorageViewer({
          stepIndex: step,
          tx: this.tx,
          address: result[2].value
        }, this.storageResolver, this.traceManager);
        localDecoder.solidityLocals(step, this.callTree, stack, memory, storageViewer, sourceLocation).then(locals => {
          if (!locals.error) {
            callback(null, locals);
          } else {
            callback(locals.error);
          }
        });
      } catch (e) {
        callback(e.message);
      }
    } else {
      callback(error);
    }
  });
};
/* decode state */


Ethdebugger.prototype.extractStateAt = function (step, callback) {
  this.solidityProxy.extractStateVariablesAt(step, (error, stateVars) => {
    callback(error, stateVars);
  });
};

Ethdebugger.prototype.decodeStateAt = function (step, stateVars, callback) {
  this.traceManager.getCurrentCalledAddressAt(step, (error, address) => {
    if (error) return callback(error);
    const storageViewer = new StorageViewer({
      stepIndex: step,
      tx: this.tx,
      address: address
    }, this.storageResolver, this.traceManager);
    stateDecoder.decodeState(stateVars, storageViewer).then(result => {
      if (!result.error) {
        callback(null, result);
      } else {
        callback(result.error);
      }
    });
  });
};

Ethdebugger.prototype.storageViewAt = function (step, address) {
  return new StorageViewer({
    stepIndex: step,
    tx: this.tx,
    address: address
  }, this.storageResolver, this.traceManager);
};

Ethdebugger.prototype.updateWeb3 = function (web3) {
  this.web3 = web3;
  this.setManagers();
};

Ethdebugger.prototype.unLoad = function () {
  this.traceManager.init();
  this.codeManager.clear();
  this.event.trigger('traceUnloaded');
};

Ethdebugger.prototype.debug = function (tx) {
  if (this.traceManager.isLoading) {
    return;
  }

  if (!tx.to) {
    tx.to = traceHelper.contractCreationToken('0');
  }

  this.tx = tx;
  this.traceManager.resolveTrace(tx, (error, result) => tslib_1.__awaiter(this, void 0, void 0, function* () {
    if (result) {
      this.setCompilationResult(yield this.compilationResult(tx.to));
      this.event.trigger('newTraceLoaded', [this.traceManager.trace]);

      if (this.breakpointManager && this.breakpointManager.hasBreakpoint()) {
        this.breakpointManager.jumpNextBreakpoint(false);
      }

      this.storageResolver = new StorageResolver({
        web3: this.traceManager.web3
      });
    } else {
      this.statusMessage = error ? error.message : 'Trace not loaded';
    }
  }));
};

module.exports = Ethdebugger;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/cmdline/contextManager.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/cmdline/contextManager.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const EventManager = remixLib.EventManager;
const Web3Providers = remixLib.vm.Web3Providers;
const DummyProvider = remixLib.vm.DummyProvider;
const init = remixLib.init;

class ContextManager {
  constructor(executionContext) {
    this.executionContext = executionContext;
    this.web3 = this.executionContext.web3();
    this.event = new EventManager();
  }

  initProviders() {
    this.web3Providers = new Web3Providers();
    this.addProvider('DUMMYWEB3', new DummyProvider());
    this.switchProvider('DUMMYWEB3');
    this.addProvider('vm', this.executionContext.vm());
    this.addProvider('injected', this.executionContext.internalWeb3());
    this.addProvider('web3', this.executionContext.internalWeb3());
    this.switchProvider(this.executionContext.getProvider());
  }

  getWeb3() {
    return this.web3;
  }

  addProvider(type, obj) {
    this.web3Providers.addProvider(type, obj);
    this.event.trigger('providerAdded', [type]);
  }

  switchProvider(type, cb) {
    this.web3Providers.get(type, (error, obj) => {
      if (error) {// console.log('provider ' + type + ' not defined')
      } else {
        this.web3 = obj;
        this.executionContext.detectNetwork((error, network) => {
          if (error || !network) {
            this.web3 = obj;
          } else {
            var webDebugNode = init.web3DebugNode(network.name);
            this.web3 = !webDebugNode ? obj : webDebugNode;
          }

          this.event.trigger('providerChanged', [type, this.web3]);
          if (cb) return cb();
        });
        this.event.trigger('providerChanged', [type, this.web3]);
      }
    });
  }

}

module.exports = ContextManager;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/cmdline/index.js":
/*!*******************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/cmdline/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

const Debugger = __webpack_require__(/*! ../debugger/debugger.js */ "../../../dist/libs/remix-debug/src/debugger/debugger.js");

const ContextManager = __webpack_require__(/*! ./contextManager.js */ "../../../dist/libs/remix-debug/src/cmdline/contextManager.js");

const events_1 = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const executionContext = remixLib.execution.executionContext;

class CmdLine {
  constructor() {
    this.executionContext = executionContext;
    this.events = new events_1.default();
    this.lineColumnPos = null;
    this.rawLocation = null;
  }

  connect(providerType, url) {
    if (providerType !== 'http') throw new Error('unsupported provider type');
    this.web3 = new Web3(new Web3.providers.HttpProvider(url));
  }

  loadCompilationData(inputJson, outputJson) {
    const data = {};
    data.data = outputJson;
    data.source = {
      sources: inputJson.sources
    };
    this.loadCompilationResult(data);
  }

  loadCompilationResult(compilationResult) {
    this.compilation = {};
    this.compilation.compilationResult = compilationResult;
  }

  initDebugger(cb) {
    this.contextManager = new ContextManager(this.executionContext);
    this.debugger = new Debugger({
      web3: this.contextManager.getWeb3(),
      compilationResult: () => {
        return this.compilation.compilationResult;
      }
    });
    this.contextManager.event.register('providerChanged', () => {
      this.debugger.updateWeb3(this.contextManager.getWeb3());
    });
    this.contextManager.initProviders();
    this.contextManager.addProvider('debugger_web3', this.web3);
    this.contextManager.switchProvider('debugger_web3', cb);
  }

  getSource() {
    const lineColumnPos = this.lineColumnPos;
    if (!lineColumnPos || !lineColumnPos.start) return [];
    const content = this.compilation.compilationResult.source.sources[this.filename].content.split('\n');
    const source = [];
    let line;
    line = content[lineColumnPos.start.line - 2];

    if (line !== undefined) {
      source.push('    ' + (lineColumnPos.start.line - 1) + ':  ' + line);
    }

    line = content[lineColumnPos.start.line - 1];

    if (line !== undefined) {
      source.push('    ' + lineColumnPos.start.line + ':  ' + line);
    }

    const currentLineNumber = lineColumnPos.start.line;
    const currentLine = content[currentLineNumber];
    source.push('=>  ' + (currentLineNumber + 1) + ':  ' + currentLine);
    const startLine = lineColumnPos.start.line;

    for (var i = 1; i < 4; i++) {
      const line = content[startLine + i];
      source.push('    ' + (startLine + i + 1) + ':  ' + line);
    }

    return source;
  }

  getCurrentLine() {
    const lineColumnPos = this.lineColumnPos;
    if (!lineColumnPos) return '';
    const currentLineNumber = lineColumnPos.start.line;
    const content = this.compilation.compilationResult.source.sources[this.filename].content.split('\n');
    return content[currentLineNumber];
  }

  startDebug(txNumber, filename, cb) {
    this.filename = filename;
    this.txHash = txNumber;
    this.debugger.debug(null, txNumber, null, () => {
      this.debugger.event.register('newSourceLocation', (lineColumnPos, rawLocation) => {
        this.lineColumnPos = lineColumnPos;
        this.rawLocation = rawLocation;
        this.events.emit('source', [lineColumnPos, rawLocation]);
      });
      this.debugger.vmDebuggerLogic.event.register('solidityState', data => {
        this.solidityState = data;
        this.events.emit('globals', data);
      }); // TODO: this doesnt work too well, it should request the data instead...

      this.debugger.vmDebuggerLogic.event.register('solidityLocals', data => {
        if (JSON.stringify(data) === '{}') return;
        this.solidityLocals = data;
        this.events.emit('locals', data);
      });

      if (cb) {
        // TODO: this should be an onReady event
        setTimeout(cb, 1000);
      }
    });
  }

  getVars() {
    return {
      locals: this.solidityLocals,
      contract: this.solidityState
    };
  }

  triggerSourceUpdate() {
    this.events.emit('source', [this.lineColumnPos, this.rawLocation]);
  }

  stepJumpNextBreakpoint() {
    this.debugger.step_manager.jumpNextBreakpoint();
  }

  stepJumpPreviousBreakpoint() {
    this.debugger.step_manager.jumpPreviousBreakpoint();
  }

  stepOverForward(solidityMode) {
    this.debugger.step_manager.stepOverForward(solidityMode);
  }

  stepOverBack(solidityMode) {
    this.debugger.step_manager.stepOverBack(solidityMode);
  }

  stepIntoForward(solidityMode) {
    this.debugger.step_manager.stepIntoForward(solidityMode);
  }

  stepIntoBack(solidityMode) {
    this.debugger.step_manager.stepIntoBack(solidityMode);
  }

  jumpTo(step) {
    this.debugger.step_manager.jumpTo(step);
  }

  getTraceLength() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.traceLength;
  }

  getCodeFirstStep() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.calculateFirstStep();
  }

  getCodeTraceLength() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.calculateCodeLength();
  }

  nextStep() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.nextStep();
  }

  previousStep() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.previousStep();
  }

  currentStep() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.currentStepIndex;
  }

  canGoNext() {
    return this.currentStep() < this.getCodeTraceLength();
  }

  canGoPrevious() {
    return this.currentStep() > this.getCodeFirstStep();
  }

  unload() {
    return this.debugger.unload();
  }

  displayLocals() {
    console.dir('= displayLocals');
    console.dir(this.solidityLocals);
  }

  displayGlobals() {
    console.dir('= displayGlobals');
    console.dir(this.solidityState);
  }

}

module.exports = CmdLine;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/debugger/VmDebugger.js":
/*!*************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/debugger/VmDebugger.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const EventManager = remixLib.EventManager;
const ui = remixLib.helpers.ui;

const StorageResolver = __webpack_require__(/*! ../storage/storageResolver */ "../../../dist/libs/remix-debug/src/storage/storageResolver.js");

const StorageViewer = __webpack_require__(/*! ../storage/storageViewer */ "../../../dist/libs/remix-debug/src/storage/storageViewer.js");

const DebuggerSolidityState = __webpack_require__(/*! ./solidityState */ "../../../dist/libs/remix-debug/src/debugger/solidityState.js");

const DebuggerSolidityLocals = __webpack_require__(/*! ./solidityLocals */ "../../../dist/libs/remix-debug/src/debugger/solidityLocals.js");

class VmDebuggerLogic {
  constructor(_debugger, tx, _stepManager, _traceManager, _codeManager, _solidityProxy, _callTree) {
    this.event = new EventManager();
    this.debugger = _debugger;
    this.stepManager = _stepManager;
    this._traceManager = _traceManager;
    this._codeManager = _codeManager;
    this._solidityProxy = _solidityProxy;
    this._callTree = _callTree;
    this.storageResolver = null;
    this.tx = tx;
    this.debuggerSolidityState = new DebuggerSolidityState(tx, _stepManager, _traceManager, _codeManager, _solidityProxy);
    this.debuggerSolidityLocals = new DebuggerSolidityLocals(tx, _stepManager, _traceManager, _callTree);
  }

  start() {
    this.listenToEvents();
    this.listenToCodeManagerEvents();
    this.listenToTraceManagerEvents();
    this.listenToFullStorageChanges();
    this.listenToNewChanges();
    this.listenToSolidityStateEvents();
    this.listenToSolidityLocalsEvents();
  }

  listenToEvents() {
    this.debugger.event.register('traceUnloaded', () => {
      this.event.trigger('traceUnloaded');
    });
    this.debugger.event.register('newTraceLoaded', () => {
      this.event.trigger('newTraceLoaded');
    });
  }

  listenToCodeManagerEvents() {
    this._codeManager.event.register('changed', (code, address, index) => {
      this.event.trigger('codeManagerChanged', [code, address, index]);
    });
  }

  listenToTraceManagerEvents() {
    this.event.register('indexChanged', this, index => {
      if (index < 0) return;
      if (this.stepManager.currentStepIndex !== index) return;
      this.event.trigger('indexUpdate', [index]);
      this.event.trigger('functionsStackUpdate', [this._callTree.retrieveFunctionsStack(index)]);

      this._traceManager.getCallDataAt(index, (error, calldata) => {
        if (error) {
          // console.log(error)
          this.event.trigger('traceManagerCallDataUpdate', [{}]);
        } else if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceManagerCallDataUpdate', [calldata]);
        }
      });

      this._traceManager.getMemoryAt(index, (error, memory) => {
        if (error) {
          // console.log(error)
          this.event.trigger('traceManagerMemoryUpdate', [{}]);
        } else if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceManagerMemoryUpdate', [ui.formatMemory(memory, 16)]);
        }
      });

      this._traceManager.getCallStackAt(index, (error, callstack) => {
        if (error) {
          // console.log(error)
          this.event.trigger('traceManagerCallStackUpdate', [{}]);
        } else if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceManagerCallStackUpdate', [callstack]);
        }
      });

      this._traceManager.getStackAt(index, (error, callstack) => {
        if (error) {
          // console.log(error)
          this.event.trigger('traceManagerStackUpdate', [{}]);
        } else if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceManagerStackUpdate', [callstack]);
        }
      });

      this._traceManager.getCurrentCalledAddressAt(index, (error, address) => {
        if (error) return;
        if (!this.storageResolver) return;
        var storageViewer = new StorageViewer({
          stepIndex: this.stepManager.currentStepIndex,
          tx: this.tx,
          address: address
        }, this.storageResolver, this._traceManager);
        storageViewer.storageRange((error, storage) => {
          if (error) {
            // console.log(error)
            this.event.trigger('traceManagerStorageUpdate', [{}]);
          } else if (this.stepManager.currentStepIndex === index) {
            var header = storageViewer.isComplete(address) ? '[Completely Loaded]' : '[Partially Loaded]';
            this.event.trigger('traceManagerStorageUpdate', [storage, header]);
          }
        });
      });

      this._traceManager.getCurrentStep(index, (error, step) => {
        this.event.trigger('traceCurrentStepUpdate', [error, step]);
      });

      this._traceManager.getMemExpand(index, (error, addmem) => {
        this.event.trigger('traceMemExpandUpdate', [error, addmem]);
      });

      this._traceManager.getStepCost(index, (error, gas) => {
        this.event.trigger('traceStepCostUpdate', [error, gas]);
      });

      this._traceManager.getCurrentCalledAddressAt(index, (error, address) => {
        this.event.trigger('traceCurrentCalledAddressAtUpdate', [error, address]);
      });

      this._traceManager.getRemainingGas(index, (error, remaining) => {
        this.event.trigger('traceRemainingGasUpdate', [error, remaining]);
      });

      this._traceManager.getReturnValue(index, (error, returnValue) => {
        if (error) {
          this.event.trigger('traceReturnValueUpdate', [[error]]);
        } else if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceReturnValueUpdate', [[returnValue]]);
        }
      });
    });
  }

  listenToFullStorageChanges() {
    this.address = [];
    this.traceLength = 0;
    this.debugger.event.register('newTraceLoaded', length => {
      this._traceManager.getAddresses((error, addresses) => {
        if (error) return;
        this.event.trigger('traceAddressesUpdate', [addresses]);
        this.addresses = addresses;
      });

      this._traceManager.getLength((error, length) => {
        if (error) return;
        this.event.trigger('traceLengthUpdate', [length]);
        this.traceLength = length;
      });
    });
    this.debugger.event.register('indexChanged', this, index => {
      if (index < 0) return;
      if (this.stepManager.currentStepIndex !== index) return;
      if (!this.storageResolver) return; // Clean up storage update

      if (index === this.traceLength - 1) {
        return this.event.trigger('traceStorageUpdate', [{}]);
      }

      var storageJSON = {};

      for (var k in this.addresses) {
        var address = this.addresses[k];
        var storageViewer = new StorageViewer({
          stepIndex: this.stepManager.currentStepIndex,
          tx: this.tx,
          address: address
        }, this.storageResolver, this._traceManager);
        storageViewer.storageRange((error, result) => {
          if (!error) {
            storageJSON[address] = result;
            this.event.trigger('traceStorageUpdate', [storageJSON]);
          }
        });
      }
    });
  }

  listenToNewChanges() {
    this.debugger.event.register('newTraceLoaded', this, () => {
      this.storageResolver = new StorageResolver({
        web3: this.debugger.web3
      });
      this.debuggerSolidityState.storageResolver = this.storageResolver;
      this.debuggerSolidityLocals.storageResolver = this.storageResolver;
      this.event.trigger('newTrace', []);
    });
    this.debugger.callTree.event.register('callTreeReady', () => {
      if (this.debugger.callTree.reducedTrace.length) {
        return this.event.trigger('newCallTree', []);
      }
    });
  }

  listenToSolidityStateEvents() {
    this.event.register('indexChanged', this.debuggerSolidityState.init.bind(this.debuggerSolidityState));
    this.debuggerSolidityState.event.register('solidityState', state => {
      this.event.trigger('solidityState', [state]);
    });
    this.debuggerSolidityState.event.register('solidityStateMessage', message => {
      this.event.trigger('solidityStateMessage', [message]);
    });
    this.debuggerSolidityState.event.register('solidityStateUpdating', () => {
      this.event.trigger('solidityStateUpdating', []);
    });
    this.event.register('traceUnloaded', this.debuggerSolidityState.reset.bind(this.debuggerSolidityState));
    this.event.register('newTraceLoaded', this.debuggerSolidityState.reset.bind(this.debuggerSolidityState));
  }

  listenToSolidityLocalsEvents() {
    this.event.register('sourceLocationChanged', this.debuggerSolidityLocals.init.bind(this.debuggerSolidityLocals));
    this.debuggerSolidityLocals.event.register('solidityLocals', state => {
      this.event.trigger('solidityLocals', [state]);
    });
    this.debuggerSolidityLocals.event.register('solidityLocalsMessage', message => {
      this.event.trigger('solidityLocalsMessage', [message]);
    });
    this.debuggerSolidityLocals.event.register('solidityLocalsUpdating', () => {
      this.event.trigger('solidityLocalsUpdating', []);
    });
    this.debuggerSolidityLocals.event.register('traceReturnValueUpdate', (data, header) => {
      this.event.trigger('traceReturnValueUpdate', [data, header]);
    });
  }

}

module.exports = VmDebuggerLogic;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/debugger/debugger.js":
/*!***********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/debugger/debugger.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const Ethdebugger = __webpack_require__(/*! ../Ethdebugger */ "../../../dist/libs/remix-debug/src/Ethdebugger.js");

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const EventManager = remixLib.EventManager;
const traceHelper = remixLib.helpers.trace;
const OffsetToColumnConverter = remixLib.OffsetToColumnConverter;

const StepManager = __webpack_require__(/*! ./stepManager */ "../../../dist/libs/remix-debug/src/debugger/stepManager.js");

const VmDebuggerLogic = __webpack_require__(/*! ./VmDebugger */ "../../../dist/libs/remix-debug/src/debugger/VmDebugger.js");

function Debugger(options) {
  this.event = new EventManager();
  this.offsetToLineColumnConverter = options.offsetToLineColumnConverter || new OffsetToColumnConverter();
  /*
    Returns a compilation result for a given address or the last one available if none are found
  */

  this.compilationResult = options.compilationResult || function (contractAddress) {
    return null;
  };

  this.debugger = new Ethdebugger({
    web3: options.web3,
    compilationResult: this.compilationResult
  });
  this.breakPointManager = new remixLib.code.BreakpointManager(this.debugger, sourceLocation => tslib_1.__awaiter(this, void 0, void 0, function* () {
    const compilationResult = yield this.compilationResult();
    if (!compilationResult) return {
      start: null,
      end: null
    };
    return this.offsetToLineColumnConverter.offsetToLineColumn(sourceLocation, sourceLocation.file, compilationResult.source.sources, compilationResult.data.sources);
  }), step => {
    this.event.trigger('breakpointStep', [step]);
  });
  this.debugger.setBreakpointManager(this.breakPointManager);
  this.debugger.event.register('newTraceLoaded', this, () => {
    this.event.trigger('debuggerStatus', [true]);
  });
  this.debugger.event.register('traceUnloaded', this, () => {
    this.event.trigger('debuggerStatus', [false]);
  });
  this.event.register('breakpointStep', step => {
    this.step_manager.jumpTo(step);
  });
}

Debugger.prototype.registerAndHighlightCodeItem = function (index) {
  // register selected code item, highlight the corresponding source location
  this.debugger.traceManager.getCurrentCalledAddressAt(index, (error, address) => tslib_1.__awaiter(this, void 0, void 0, function* () {
    if (error) return console.log(error);
    const compilationResultForAddress = yield this.compilationResult(address);
    if (!compilationResultForAddress) return;
    this.debugger.callTree.sourceLocationTracker.getSourceLocationFromVMTraceIndex(address, index, compilationResultForAddress.data.contracts, (error, rawLocation) => {
      if (!error && compilationResultForAddress && compilationResultForAddress.data) {
        var lineColumnPos = this.offsetToLineColumnConverter.offsetToLineColumn(rawLocation, rawLocation.file, compilationResultForAddress.source.sources, compilationResultForAddress.data.sources);
        this.event.trigger('newSourceLocation', [lineColumnPos, rawLocation]);
      } else {
        this.event.trigger('newSourceLocation', [null]);
      }
    });
  }));
};

Debugger.prototype.updateWeb3 = function (web3) {
  this.debugger.web3 = web3;
};

Debugger.prototype.debug = function (blockNumber, txNumber, tx, loadingCb) {
  const web3 = this.debugger.web3;
  return new Promise((resolve, reject) => {
    if (this.debugger.traceManager.isLoading) {
      return resolve();
    }

    if (tx) {
      if (!tx.to) {
        tx.to = traceHelper.contractCreationToken('0');
      }

      this.debugTx(tx, loadingCb);
      return resolve();
    }

    try {
      if (txNumber.indexOf('0x') !== -1) {
        return web3.eth.getTransaction(txNumber, (_error, tx) => {
          if (_error) return reject(_error);
          if (!tx) return reject('cannot find transaction ' + txNumber);
          this.debugTx(tx, loadingCb);
          return resolve();
        });
      }

      web3.eth.getTransactionFromBlock(blockNumber, txNumber, (_error, tx) => {
        if (_error) return reject(_error);
        if (!tx) return reject('cannot find transaction ' + blockNumber + ' ' + txNumber);
        this.debugTx(tx, loadingCb);
        return resolve();
      });
    } catch (e) {
      return reject(e.message);
    }
  });
};

Debugger.prototype.debugTx = function (tx, loadingCb) {
  this.step_manager = new StepManager(this.debugger, this.debugger.traceManager);
  this.debugger.codeManager.event.register('changed', this, (code, address, instIndex) => {
    this.debugger.callTree.sourceLocationTracker.getSourceLocationFromVMTraceIndex(address, this.step_manager.currentStepIndex, this.debugger.solidityProxy.contracts, (error, sourceLocation) => {
      if (!error) {
        this.vmDebuggerLogic.event.trigger('sourceLocationChanged', [sourceLocation]);
      }
    });
  });
  this.vmDebuggerLogic = new VmDebuggerLogic(this.debugger, tx, this.step_manager, this.debugger.traceManager, this.debugger.codeManager, this.debugger.solidityProxy, this.debugger.callTree);
  this.vmDebuggerLogic.start();
  this.step_manager.event.register('stepChanged', this, stepIndex => {
    if (typeof stepIndex !== 'number' || stepIndex >= this.step_manager.traceLength) {
      return this.event.trigger('endDebug');
    }

    this.debugger.codeManager.resolveStep(stepIndex, tx);
    this.step_manager.event.trigger('indexChanged', [stepIndex]);
    this.vmDebuggerLogic.event.trigger('indexChanged', [stepIndex]);
    this.vmDebuggerLogic.debugger.event.trigger('indexChanged', [stepIndex]);
    this.registerAndHighlightCodeItem(stepIndex);
  });
  loadingCb();
  this.debugger.debug(tx);
};

Debugger.prototype.unload = function () {
  this.debugger.unLoad();
  this.event.trigger('debuggerUnloaded');
};

module.exports = Debugger;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/debugger/solidityLocals.js":
/*!*****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/debugger/solidityLocals.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const EventManager = remixLib.EventManager;

const localDecoder = __webpack_require__(/*! ../solidity-decoder/localDecoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/localDecoder.js");

const StorageViewer = __webpack_require__(/*! ../storage/storageViewer */ "../../../dist/libs/remix-debug/src/storage/storageViewer.js");

class DebuggerSolidityLocals {
  constructor(tx, _stepManager, _traceManager, _internalTreeCall) {
    this.event = new EventManager();
    this.stepManager = _stepManager;
    this.internalTreeCall = _internalTreeCall;
    this.storageResolver = null;
    this.traceManager = _traceManager;
    this.tx = tx;
  }

  init(sourceLocation) {
    var decodeTimeout = null;

    if (!this.storageResolver) {
      return this.event.trigger('solidityLocalsMessage', ['storage not ready']);
    }

    if (decodeTimeout) {
      window.clearTimeout(decodeTimeout);
    }

    this.event.trigger('solidityLocalsUpdating');
    decodeTimeout = setTimeout(() => {
      this.decode(sourceLocation);
    }, 500);
  }

  decode(sourceLocation) {
    this.event.trigger('solidityLocalsMessage', ['']);
    this.traceManager.waterfall([this.traceManager.getStackAt, this.traceManager.getMemoryAt, this.traceManager.getCurrentCalledAddressAt], this.stepManager.currentStepIndex, (error, result) => {
      if (error) {
        return error;
      }

      var stack = result[0].value;
      var memory = result[1].value;

      try {
        var storageViewer = new StorageViewer({
          stepIndex: this.stepManager.currentStepIndex,
          tx: this.tx,
          address: result[2].value
        }, this.storageResolver, this.traceManager);
        localDecoder.solidityLocals(this.stepManager.currentStepIndex, this.internalTreeCall, stack, memory, storageViewer, sourceLocation).then(locals => {
          if (!locals.error) {
            this.event.trigger('solidityLocals', [locals]);
          }

          if (!Object.keys(locals).length) {
            this.event.trigger('solidityLocalsMessage', ['no locals']);
          }
        });
      } catch (e) {
        this.event.trigger('solidityLocalsMessage', [e.message]);
      }
    });
  }

}

module.exports = DebuggerSolidityLocals;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/debugger/solidityState.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/debugger/solidityState.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const EventManager = remixLib.EventManager;

const stateDecoder = __webpack_require__(/*! ../solidity-decoder/stateDecoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/stateDecoder.js");

const StorageViewer = __webpack_require__(/*! ../storage/storageViewer */ "../../../dist/libs/remix-debug/src/storage/storageViewer.js");

class DebuggerSolidityState {
  constructor(tx, _stepManager, _traceManager, _codeManager, _solidityProxy) {
    this.event = new EventManager();
    this.storageResolver = null;
    this.stepManager = _stepManager;
    this.traceManager = _traceManager;
    this.codeManager = _codeManager;
    this.solidityProxy = _solidityProxy;
    this.stateVariablesByAddresses = {};
    this.tx = tx;
  }

  init(index) {
    let decodeTimeout = null;

    if (index < 0) {
      return this.event.trigger('solidityStateMessage', ['invalid step index']);
    }

    if (this.stepManager.currentStepIndex !== index) return;

    if (!this.solidityProxy.loaded()) {
      return this.event.trigger('solidityStateMessage', ['invalid step index']);
    }

    if (!this.storageResolver) {
      return;
    }

    if (decodeTimeout) {
      window.clearTimeout(decodeTimeout);
    }

    this.event.trigger('solidityStateUpdating');
    decodeTimeout = setTimeout(() => {
      // necessary due to some states that can crash the debugger
      try {
        this.decode(index);
      } catch (err) {
        console.dir('====> error');
        console.dir(err);
      }
    }, 500);
  }

  reset() {
    this.stateVariablesByAddresses = {};
  }

  decode(index) {
    this.traceManager.getCurrentCalledAddressAt(this.stepManager.currentStepIndex, (error, address) => {
      if (error) {
        return this.event.trigger('solidityState', [{}]);
      }

      if (this.stateVariablesByAddresses[address]) {
        return this.extractStateVariables(this.stateVariablesByAddresses[address], address);
      }

      this.solidityProxy.extractStateVariablesAt(index, (error, stateVars) => {
        if (error) {
          return this.event.trigger('solidityState', [{}]);
        }

        this.stateVariablesByAddresses[address] = stateVars;
        this.extractStateVariables(stateVars, address);
      });
    });
  }

  extractStateVariables(stateVars, address) {
    let storageViewer = new StorageViewer({
      stepIndex: this.stepManager.currentStepIndex,
      tx: this.tx,
      address: address
    }, this.storageResolver, this.traceManager);
    stateDecoder.decodeState(stateVars, storageViewer).then(result => {
      this.event.trigger('solidityStateMessage', ['']);

      if (result.error) {
        return this.event.trigger('solidityStateMessage', [result.error]);
      }

      this.event.trigger('solidityState', [result]);
    });
  }

}

module.exports = DebuggerSolidityState;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/debugger/stepManager.js":
/*!**************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/debugger/stepManager.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const EventManager = remixLib.EventManager;
const util = remixLib.util;

class DebuggerStepManager {
  constructor(_debugger, traceManager) {
    this.event = new EventManager();
    this.debugger = _debugger;
    this.traceManager = traceManager;
    this.currentStepIndex = 0;
    this.traceLength = 0;
    this.codeTraceLength = 0;
    this.revertionPoint = null;
    this.listenToEvents();
  }

  listenToEvents() {
    this.debugger.event.register('newTraceLoaded', this, () => {
      this.traceManager.getLength((error, newLength) => {
        if (error) {
          return console.log(error);
        }

        if (this.traceLength !== newLength) {
          this.event.trigger('traceLengthChanged', [newLength]);
          this.traceLength = newLength;
          this.codeTraceLength = this.calculateCodeLength();
        }

        this.jumpTo(0);
      });
    });
    this.debugger.callTree.event.register('callTreeReady', () => {
      if (this.debugger.callTree.functionCallStack.length) {
        this.jumpTo(this.debugger.callTree.functionCallStack[0]);
      }
    });
    this.event.register('indexChanged', this, index => {
      if (index < 0) return;
      if (this.currentStepIndex !== index) return;
      this.traceManager.buildCallPath(index, (error, callsPath) => {
        if (error) {
          console.log(error);
          return this.event.trigger('revertWarning', ['']);
        }

        this.currentCall = callsPath[callsPath.length - 1];

        if (this.currentCall.reverted) {
          let revertedReason = this.currentCall.outofgas ? 'outofgas' : '';
          this.revertionPoint = this.currentCall.return;
          return this.event.trigger('revertWarning', [revertedReason]);
        }

        for (var k = callsPath.length - 2; k >= 0; k--) {
          var parent = callsPath[k];
          if (!parent.reverted) continue;
          this.revertionPoint = parent.return;
          this.event.trigger('revertWarning', ['parenthasthrown']);
        }

        this.event.trigger('revertWarning', ['']);
      });
    });
  }

  triggerStepChanged(step) {
    this.traceManager.getLength((error, length) => {
      let stepState = 'valid';

      if (error) {
        stepState = 'invalid';
      } else if (step <= 0) {
        stepState = 'initial';
      } else if (step >= length - 1) {
        stepState = 'end';
      }

      let jumpOutDisabled = step === this.traceManager.findStepOut(step);
      this.event.trigger('stepChanged', [step, stepState, jumpOutDisabled]);
    });
  }

  stepIntoBack(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    let step = this.currentStepIndex - 1;
    this.currentStepIndex = step;

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, -1);
    }

    if (!this.traceManager.inRange(step)) {
      return;
    }

    this.event.trigger('stepChanged', [step]);
  }

  stepIntoForward(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    let step = this.currentStepIndex + 1;
    this.currentStepIndex = step;

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, 1);
    }

    if (!this.traceManager.inRange(step)) {
      return;
    }

    this.event.trigger('stepChanged', [step]);
  }

  stepOverBack(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    let step = this.traceManager.findStepOverBack(this.currentStepIndex);

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, -1);
    }

    this.currentStepIndex = step;
    this.event.trigger('stepChanged', [step]);
  }

  stepOverForward(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    let step = this.currentStepIndex + 1;
    let scope = this.debugger.callTree.findScope(step);

    if (scope && scope.firstStep === step) {
      step = scope.lastStep + 1;
    }

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, 1);
    }

    this.currentStepIndex = step;
    this.event.trigger('stepChanged', [step]);
  }

  jumpOut(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    var step = this.traceManager.findStepOut(this.currentStepIndex);

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, 0);
    }

    this.currentStepIndex = step;
    this.event.trigger('stepChanged', [step]);
  }

  jumpTo(step) {
    if (!this.traceManager.inRange(step)) return;
    this.currentStepIndex = step;
    this.event.trigger('stepChanged', [step]);
  }

  jumpToException() {
    this.jumpTo(this.revertionPoint);
  }

  jumpNextBreakpoint() {
    this.debugger.breakpointManager.jumpNextBreakpoint(this.currentStepIndex, true);
  }

  jumpPreviousBreakpoint() {
    this.debugger.breakpointManager.jumpPreviousBreakpoint(this.currentStepIndex, true);
  }

  calculateFirstStep() {
    let step = this.resolveToReducedTrace(0, 1);
    return this.resolveToReducedTrace(step, 1);
  }

  calculateCodeStepList() {
    let step = 0;
    let steps = [];

    while (step < this.traceLength) {
      let _step = this.resolveToReducedTrace(step, 1);

      if (!_step) break;
      steps.push(_step);
      step += 1;
    }

    steps = steps.filter((item, pos, self) => {
      return steps.indexOf(item) === pos;
    });
    return steps;
  }

  calculateCodeLength() {
    this.calculateCodeStepList().reverse();
    return this.calculateCodeStepList().reverse()[1] || this.traceLength;
  }

  nextStep() {
    return this.resolveToReducedTrace(this.currentStepIndex, 1);
  }

  previousStep() {
    return this.resolveToReducedTrace(this.currentStepIndex, -1);
  }

  resolveToReducedTrace(value, incr) {
    if (this.debugger.callTree.reducedTrace.length) {
      var nextSource = util.findClosestIndex(value, this.debugger.callTree.reducedTrace);
      nextSource = nextSource + incr;

      if (nextSource <= 0) {
        nextSource = 0;
      } else if (nextSource > this.debugger.callTree.reducedTrace.length) {
        nextSource = this.debugger.callTree.reducedTrace.length - 1;
      }

      return this.debugger.callTree.reducedTrace[nextSource];
    }

    return value;
  }

}

module.exports = DebuggerStepManager;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/astHelper.js":
/*!********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/astHelper.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const AstWalker = remixLib.AstWalker;
/**
  * return all contract definitions of the given @astList
  *
  * @param {Object} sourcesList - sources list (containing root AST node)
  * @return {Object} - returns a mapping from AST node ids to AST nodes for the contracts
  */

function extractContractDefinitions(sourcesList) {
  const ret = {
    contractsById: {},
    contractsByName: {},
    sourcesByContract: {}
  };
  const walker = new AstWalker();

  for (let k in sourcesList) {
    walker.walk(sourcesList[k].legacyAST, {
      'ContractDefinition': node => {
        ret.contractsById[node.id] = node;
        ret.sourcesByContract[node.id] = k;
        ret.contractsByName[k + ':' + node.attributes.name] = node;
        return false;
      }
    });
  }

  return ret;
}
/**
  * returns the linearized base contracts of the contract @arg id
  *
  * @param {Int} id - contract id to resolve
  * @param {Map} contracts  - all contracts defined in the current context
  * @return {Array} - array of base contracts in derived to base order as AST nodes.
  */


function getLinearizedBaseContracts(id, contractsById) {
  return contractsById[id].attributes.linearizedBaseContracts.map(function (id) {
    return contractsById[id];
  });
}
/**
  * return state var and type definition of the given contract
  *
  * @param {String} contractName - contract for which state var should be resolved
  * @param {Object} sourcesList - sources list (containing root AST node)
  * @param {Object} [contracts] - map of contract definitions (contains contractsById, contractsByName)
  * @return {Object} - return an object containing: stateItems - list of all the children node of the @arg contractName
  *                                                 stateVariables - list of all the variable declaration of the @arg contractName
  */


function extractStateDefinitions(contractName, sourcesList, contracts) {
  if (!contracts) {
    contracts = extractContractDefinitions(sourcesList);
  }

  const node = contracts.contractsByName[contractName];

  if (node) {
    const stateItems = [];
    const stateVar = [];
    const baseContracts = getLinearizedBaseContracts(node.id, contracts.contractsById);
    baseContracts.reverse();

    for (let k in baseContracts) {
      const ctr = baseContracts[k];

      for (let i in ctr.children) {
        const item = ctr.children[i];
        stateItems.push(item);

        if (item.name === 'VariableDeclaration') {
          stateVar.push(item);
        }
      }
    }

    return {
      stateDefinitions: stateItems,
      stateVariables: stateVar
    };
  }

  return null;
}
/**
  * return state var and type definition of all the contracts from the given @args sourcesList
  *
  * @param {Object} sourcesList - sources list (containing root AST node)
  * @param {Object} [contracts] - map of contract definitions (contains contractsById, contractsByName)
  * @return {Object} - returns a mapping between contract name and contract state
  */


function extractStatesDefinitions(sourcesList, contracts) {
  if (!contracts) {
    contracts = extractContractDefinitions(sourcesList);
  }

  const ret = {};

  for (let contract in contracts.contractsById) {
    const name = contracts.contractsById[contract].attributes.name;
    const source = contracts.sourcesByContract[contract];
    const fullName = source + ':' + name;
    const state = extractStateDefinitions(fullName, sourcesList, contracts);
    ret[fullName] = state;
    ret[name] = state; // solc < 0.4.9
  }

  return ret;
}

module.exports = {
  extractStatesDefinitions: extractStatesDefinitions,
  extractStateDefinitions: extractStateDefinitions,
  extractContractDefinitions: extractContractDefinitions,
  getLinearizedBaseContracts: getLinearizedBaseContracts
};

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/decodeInfo.js":
/*!*********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/decodeInfo.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const AddressType = __webpack_require__(/*! ./types/Address */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Address.js");

const ArrayType = __webpack_require__(/*! ./types/ArrayType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ArrayType.js");

const BoolType = __webpack_require__(/*! ./types/Bool */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Bool.js");

const BytesType = __webpack_require__(/*! ./types/DynamicByteArray */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/DynamicByteArray.js");

const BytesXType = __webpack_require__(/*! ./types/FixedByteArray */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/FixedByteArray.js");

const EnumType = __webpack_require__(/*! ./types/Enum */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Enum.js");

const StringType = __webpack_require__(/*! ./types/StringType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/StringType.js");

const StructType = __webpack_require__(/*! ./types/Struct */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Struct.js");

const IntType = __webpack_require__(/*! ./types/Int */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Int.js");

const UintType = __webpack_require__(/*! ./types/Uint */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Uint.js");

const MappingType = __webpack_require__(/*! ./types/Mapping */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Mapping.js");

const util = __webpack_require__(/*! ./types/util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");
/**
  * mapping decode the given @arg type
  *
  * @param {String} type - type given by the AST
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function mapping(type, stateDefinitions, contractName) {
  const match = type.match(/mapping\((.*?)=>(.*)\)$/);
  const keyTypeName = match[1].trim();
  const valueTypeName = match[2].trim();
  const keyType = parseType(keyTypeName, stateDefinitions, contractName, 'storage');
  const valueType = parseType(valueTypeName, stateDefinitions, contractName, 'storage');
  var underlyingTypes = {
    'keyType': keyType,
    'valueType': valueType
  };
  return new MappingType(underlyingTypes, 'location', util.removeLocation(type));
}
/**
  * Uint decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g uint256, uint32)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function uint(type) {
  type === 'uint' ? 'uint256' : type;
  const storageBytes = parseInt(type.replace('uint', '')) / 8;
  return new UintType(storageBytes);
}
/**
  * Int decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g int256, int32)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function int(type) {
  type === 'int' ? 'int256' : type;
  const storageBytes = parseInt(type.replace('int', '')) / 8;
  return new IntType(storageBytes);
}
/**
  * Address decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g address)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function address(type) {
  return new AddressType();
}
/**
  * Bool decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g bool)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function bool(type) {
  return new BoolType();
}
/**
  * DynamicByteArray decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g bytes storage ref)
  * @param {null} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {null} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function dynamicByteArray(type, stateDefinitions, contractName, location) {
  if (!location) {
    location = util.extractLocation(type);
  }

  if (location) {
    return new BytesType(location);
  } else {
    return null;
  }
}
/**
  * FixedByteArray decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g bytes16)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function fixedByteArray(type) {
  const storageBytes = parseInt(type.replace('bytes', ''));
  return new BytesXType(storageBytes);
}
/**
  * StringType decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g string storage ref)
  * @param {null} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {null} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function stringType(type, stateDefinitions, contractName, location) {
  if (!location) {
    location = util.extractLocation(type);
  }

  if (location) {
    return new StringType(location);
  } else {
    return null;
  }
}
/**
  * ArrayType decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g int256[] storage ref, int256[] storage ref[] storage ref)
  * @param {Object} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName, arraySize, subArray}
  */


function array(type, stateDefinitions, contractName, location) {
  let arraySize;
  const match = type.match(/(.*)\[(.*?)\]( storage ref| storage pointer| memory| calldata)?$/);

  if (!match) {
    console.log('unable to parse type ' + type);
    return null;
  }

  if (!location) {
    location = match[3].trim();
  }

  arraySize = match[2] === '' ? 'dynamic' : parseInt(match[2]);
  const underlyingType = parseType(match[1], stateDefinitions, contractName, location);

  if (underlyingType === null) {
    console.log('unable to parse type ' + type);
    return null;
  }

  return new ArrayType(underlyingType, arraySize, location);
}
/**
  * Enum decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g enum enumDef)
  * @param {Object} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName, enum}
  */


function enumType(type, stateDefinitions, contractName) {
  const match = type.match(/enum (.*)/);
  const enumDef = getEnum(match[1], stateDefinitions, contractName);

  if (enumDef === null) {
    console.log('unable to retrieve decode info of ' + type);
    return null;
  }

  return new EnumType(enumDef);
}
/**
  * Struct decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g struct structDef storage ref)
  * @param {Object} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName, members}
  */


function struct(type, stateDefinitions, contractName, location) {
  const match = type.match(/struct (\S*?)( storage ref| storage pointer| memory| calldata)?$/);

  if (match) {
    if (!location) {
      location = match[2].trim();
    }

    const memberDetails = getStructMembers(match[1], stateDefinitions, contractName, location); // type is used to extract the ast struct definition

    if (!memberDetails) return null;
    return new StructType(memberDetails, location, match[1]);
  } else {
    return null;
  }
}
/**
  * retrieve enum declaration of the given @arg type
  *
  * @param {String} type - type given by the AST (e.g enum enumDef)
  * @param {Object} stateDefinitions  - all state declarations given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @return {Array} - containing all value declaration of the current enum type
  */


function getEnum(type, stateDefinitions, contractName) {
  const split = type.split('.');

  if (!split.length) {
    type = contractName + '.' + type;
  } else {
    contractName = split[0];
  }

  const state = stateDefinitions[contractName];

  if (state) {
    for (let dec of state.stateDefinitions) {
      if (dec.attributes && dec.attributes.name && type === contractName + '.' + dec.attributes.name) {
        return dec;
      }
    }
  }

  return null;
}
/**
  * retrieve memebers declared in the given @arg tye
  *
  * @param {String} typeName - name of the struct type (e.g struct <name>)
  * @param {Object} stateDefinitions  - all state definition given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Array} containing all members of the current struct type
  */


function getStructMembers(type, stateDefinitions, contractName, location) {
  const split = type.split('.');

  if (!split.length) {
    type = contractName + '.' + type;
  } else {
    contractName = split[0];
  }

  const state = stateDefinitions[contractName];

  if (state) {
    for (let dec of state.stateDefinitions) {
      if (dec.name === 'StructDefinition' && type === contractName + '.' + dec.attributes.name) {
        const offsets = computeOffsets(dec.children, stateDefinitions, contractName, location);

        if (!offsets) {
          return null;
        }

        return {
          members: offsets.typesOffsets,
          storageSlots: offsets.endLocation.slot
        };
      }
    }
  }

  return null;
}
/**
  * parse the full type
  *
  * @param {String} fullType - type given by the AST (ex: uint[2] storage ref[2])
  * @return {String} returns the token type (used to instanciate the right decoder) (uint[2] storage ref[2] will return 'array', uint256 will return uintX)
  */


function typeClass(fullType) {
  fullType = util.removeLocation(fullType);

  if (fullType.lastIndexOf(']') === fullType.length - 1) {
    return 'array';
  }

  if (fullType.indexOf('mapping') === 0) {
    return 'mapping';
  }

  if (fullType.indexOf(' ') !== -1) {
    fullType = fullType.split(' ')[0];
  }

  const char = fullType.indexOf('bytes') === 0 ? 'X' : '';
  return fullType.replace(/[0-9]+/g, char);
}
/**
  * parse the type and return an object representing the type
  *
  * @param {Object} type - type name given by the ast node
  * @param {Object} stateDefinitions - all state stateDefinitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} - return the corresponding decoder or null on error
  */


function parseType(type, stateDefinitions, contractName, location) {
  const decodeInfos = {
    'contract': address,
    'address': address,
    'array': array,
    'bool': bool,
    'bytes': dynamicByteArray,
    'bytesX': fixedByteArray,
    'enum': enumType,
    'string': stringType,
    'struct': struct,
    'int': int,
    'uint': uint,
    'mapping': mapping
  };
  const currentType = typeClass(type);

  if (currentType === null) {
    console.log('unable to retrieve decode info of ' + type);
    return null;
  }

  if (decodeInfos[currentType]) {
    return decodeInfos[currentType](type, stateDefinitions, contractName, location);
  } else {
    return null;
  }
}
/**
  * compute offset (slot offset and byte offset of the @arg list of types)
  *
  * @param {Array} types - list of types
  * @param {Object} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Array} - return an array of types item: {name, type, location}. location defines the byte offset and slot offset
  */


function computeOffsets(types, stateDefinitions, contractName, location) {
  const ret = [];
  const storagelocation = {
    offset: 0,
    slot: 0
  };

  for (var i in types) {
    var variable = types[i];
    var type = parseType(variable.attributes.type, stateDefinitions, contractName, location);

    if (!type) {
      console.log('unable to retrieve decode info of ' + variable.attributes.type);
      return null;
    }

    if (!variable.attributes.constant && storagelocation.offset + type.storageBytes > 32) {
      storagelocation.slot++;
      storagelocation.offset = 0;
    }

    ret.push({
      name: variable.attributes.name,
      type: type,
      constant: variable.attributes.constant,
      storagelocation: {
        offset: variable.attributes.constant ? 0 : storagelocation.offset,
        slot: variable.attributes.constant ? 0 : storagelocation.slot
      }
    });

    if (!variable.attributes.constant) {
      if (type.storageSlots === 1 && storagelocation.offset + type.storageBytes <= 32) {
        storagelocation.offset += type.storageBytes;
      } else {
        storagelocation.slot += type.storageSlots;
        storagelocation.offset = 0;
      }
    }
  }

  if (storagelocation.offset > 0) {
    storagelocation.slot++;
  }

  return {
    typesOffsets: ret,
    endLocation: storagelocation
  };
}

module.exports = {
  parseType: parseType,
  computeOffsets: computeOffsets,
  Uint: uint,
  Address: address,
  Bool: bool,
  DynamicByteArray: dynamicByteArray,
  FixedByteArray: fixedByteArray,
  Int: int,
  String: stringType,
  Array: array,
  Enum: enumType,
  Struct: struct
};

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/index.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const SolidityProxy = __webpack_require__(/*! ./solidityProxy */ "../../../dist/libs/remix-debug/src/solidity-decoder/solidityProxy.js");

const stateDecoder = __webpack_require__(/*! ./stateDecoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/stateDecoder.js");

const localDecoder = __webpack_require__(/*! ./localDecoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/localDecoder.js");

const InternalCallTree = __webpack_require__(/*! ./internalCallTree */ "../../../dist/libs/remix-debug/src/solidity-decoder/internalCallTree.js");

module.exports = {
  SolidityProxy: SolidityProxy,
  stateDecoder: stateDecoder,
  localDecoder: localDecoder,
  InternalCallTree: InternalCallTree
};

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/internalCallTree.js":
/*!***************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/internalCallTree.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const SourceLocationTracker = remixLib.SourceLocationTracker;
const AstWalker = remixLib.AstWalker;
const EventManager = remixLib.EventManager;

const decodeInfo = __webpack_require__(/*! ./decodeInfo */ "../../../dist/libs/remix-debug/src/solidity-decoder/decodeInfo.js");

const util = remixLib.util;
const traceHelper = remixLib.helpers.trace;

const typesUtil = __webpack_require__(/*! ./types/util.js */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");
/**
 * Tree representing internal jump into function.
 * Triggers `callTreeReady` event when tree is ready
 * Triggers `callTreeBuildFailed` event when tree fails to build
 */


class InternalCallTree {
  /**
    * constructor
    *
    * @param {Object} debuggerEvent  - event declared by the debugger (EthDebugger)
    * @param {Object} traceManager  - trace manager
    * @param {Object} solidityProxy  - solidity proxy
    * @param {Object} codeManager  - code manager
    * @param {Object} opts  - { includeLocalVariables }
    */
  constructor(debuggerEvent, traceManager, solidityProxy, codeManager, opts) {
    this.includeLocalVariables = opts.includeLocalVariables;
    this.event = new EventManager();
    this.solidityProxy = solidityProxy;
    this.traceManager = traceManager;
    this.sourceLocationTracker = new SourceLocationTracker(codeManager);
    debuggerEvent.register('newTraceLoaded', trace => {
      this.reset();

      if (!this.solidityProxy.loaded()) {
        this.event.trigger('callTreeBuildFailed', ['compilation result not loaded. Cannot build internal call tree']);
      } else {
        // each recursive call to buildTree represent a new context (either call, delegatecall, internal function)
        buildTree(this, 0, '', true).then(result => {
          if (result.error) {
            this.event.trigger('callTreeBuildFailed', [result.error]);
          } else {
            createReducedTrace(this, traceManager.trace.length - 1);
            this.event.trigger('callTreeReady', [this.scopes, this.scopeStarts]);
          }
        }, reason => {
          console.log('analyzing trace falls ' + reason);
          this.event.trigger('callTreeNotReady', [reason]);
        });
      }
    });
  }
  /**
    * reset tree
    *
    */


  reset() {
    /*
      scopes: map of scopes defined by range in the vmtrace {firstStep, lastStep, locals}.
      Keys represent the level of deepness (scopeId)
      scopeId : <currentscope_id>.<sub_scope_id>.<sub_sub_scope_id>
    */
    this.scopes = {};
    /*
      scopeStart: represent start of a new scope. Keys are index in the vmtrace, values are scopeId
    */

    this.sourceLocationTracker.clearCache();
    this.functionCallStack = [];
    this.functionDefinitionsByScope = {};
    this.scopeStarts = {};
    this.variableDeclarationByFile = {};
    this.functionDefinitionByFile = {};
    this.astWalker = new AstWalker();
    this.reducedTrace = [];
  }
  /**
    * find the scope given @arg vmTraceIndex
    *
    * @param {Int} vmtraceIndex  - index on the vm trace
    */


  findScope(vmtraceIndex) {
    let scopeId = this.findScopeId(vmtraceIndex);
    if (scopeId !== '' && !scopeId) return null;
    let scope = this.scopes[scopeId];

    while (scope.lastStep && scope.lastStep < vmtraceIndex && scope.firstStep > 0) {
      scopeId = this.parentScope(scopeId);
      scope = this.scopes[scopeId];
    }

    return scope;
  }

  parentScope(scopeId) {
    const matched = scopeId.match(/(.\d|\d)$/);
    return scopeId.replace(matched[1], '');
  }

  findScopeId(vmtraceIndex) {
    const scopes = Object.keys(this.scopeStarts);
    if (!scopes.length) return null;
    const scopeStart = util.findLowerBoundValue(vmtraceIndex, scopes);
    return this.scopeStarts[scopeStart];
  }

  retrieveFunctionsStack(vmtraceIndex) {
    let scope = this.findScope(vmtraceIndex);
    if (!scope) return [];
    let scopeId = this.scopeStarts[scope.firstStep];
    let functions = [];
    if (!scopeId) return functions;
    let i = 0; // eslint-disable-next-line no-constant-condition

    while (true) {
      i += 1;
      if (i > 1000) throw new Error('retrieFunctionStack: recursion too deep');
      let functionDefinition = this.functionDefinitionsByScope[scopeId];

      if (functionDefinition !== undefined) {
        functions.push(functionDefinition);
      }

      let parent = this.parentScope(scopeId);
      if (!parent) break;else scopeId = parent;
    }

    return functions;
  }

  extractSourceLocation(step) {
    return new Promise((resolve, reject) => {
      this.traceManager.getCurrentCalledAddressAt(step, (error, address) => {
        if (!error) {
          this.sourceLocationTracker.getSourceLocationFromVMTraceIndex(address, step, this.solidityProxy.contracts, (error, sourceLocation) => {
            if (!error) {
              return resolve(sourceLocation);
            } else {
              return reject('InternalCallTree - Cannot retrieve sourcelocation for step ' + step + ' ' + error);
            }
          });
        } else {
          return reject('InternalCallTree - Cannot retrieve address for step ' + step + ' ' + error);
        }
      });
    });
  }

}

function buildTree(tree, step, scopeId, isExternalCall) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    let subScope = 1;
    tree.scopeStarts[step] = scopeId;
    tree.scopes[scopeId] = {
      firstStep: step,
      locals: {}
    };

    function callDepthChange(step, trace) {
      if (step + 1 < trace.length) {
        return trace[step].depth !== trace[step + 1].depth;
      }

      return false;
    }

    function includedSource(source, included) {
      return included.start !== -1 && included.length !== -1 && included.file !== -1 && included.start >= source.start && included.start + included.length <= source.start + source.length && included.file === source.file;
    }

    let currentSourceLocation = {
      start: -1,
      length: -1,
      file: -1
    };
    let previousSourceLocation = currentSourceLocation;

    while (step < tree.traceManager.trace.length) {
      let sourceLocation;
      let newLocation = false;

      try {
        sourceLocation = yield tree.extractSourceLocation(step);

        if (!includedSource(sourceLocation, currentSourceLocation)) {
          tree.reducedTrace.push(step);
          currentSourceLocation = sourceLocation;
          newLocation = true;
        }
      } catch (e) {
        return {
          outStep: step,
          error: 'InternalCallTree - Error resolving source location. ' + step + ' ' + e
        };
      }

      if (!sourceLocation) {
        return {
          outStep: step,
          error: 'InternalCallTree - No source Location. ' + step
        };
      }

      const isCallInstruction = traceHelper.isCallInstruction(tree.traceManager.trace[step]); // we are checking if we are jumping in a new CALL or in an internal function

      if (isCallInstruction || sourceLocation.jump === 'i') {
        try {
          const externalCallResult = yield buildTree(tree, step + 1, scopeId === '' ? subScope.toString() : scopeId + '.' + subScope, isCallInstruction);

          if (externalCallResult.error) {
            return {
              outStep: step,
              error: 'InternalCallTree - ' + externalCallResult.error
            };
          } else {
            step = externalCallResult.outStep;
            subScope++;
          }
        } catch (e) {
          return {
            outStep: step,
            error: 'InternalCallTree - ' + e.message
          };
        }
      } else if (isExternalCall && callDepthChange(step, tree.traceManager.trace) || !isExternalCall && sourceLocation.jump === 'o') {
        // if not, we might be returning from a CALL or internal function. This is what is checked here.
        tree.scopes[scopeId].lastStep = step;
        return {
          outStep: step + 1
        };
      } else {
        // if not, we are in the current scope.
        // We check in `includeVariableDeclaration` if there is a new local variable in scope for this specific `step`
        if (tree.includeLocalVariables) {
          includeVariableDeclaration(tree, step, sourceLocation, scopeId, newLocation, previousSourceLocation);
        }

        previousSourceLocation = sourceLocation;
        step++;
      }
    }

    return {
      outStep: step
    };
  });
} // the reduced trace contain an entry only if that correspond to a new source location


function createReducedTrace(tree, index) {
  tree.reducedTrace.push(index);
}

function includeVariableDeclaration(tree, step, sourceLocation, scopeId, newLocation, previousSourceLocation) {
  const variableDeclaration = resolveVariableDeclaration(tree, step, sourceLocation); // using the vm trace step, the current source location and the ast,
  // we check if the current vm trace step target a new ast node of type VariableDeclaration
  // that way we know that there is a new local variable from here.

  if (variableDeclaration && !tree.scopes[scopeId].locals[variableDeclaration.attributes.name]) {
    tree.traceManager.getStackAt(step, (error, stack) => {
      // the stack length at this point is where the value of the new local variable will be stored.
      // so, either this is the direct value, or the offset in memory. That depends on the type.
      if (!error) {
        tree.solidityProxy.contractNameAt(step, (error, contractName) => {
          if (!error && variableDeclaration.attributes.name !== '') {
            var states = tree.solidityProxy.extractStatesDefinitions();
            var location = typesUtil.extractLocationFromAstVariable(variableDeclaration);
            location = location === 'default' ? 'storage' : location; // we push the new local variable in our tree

            tree.scopes[scopeId].locals[variableDeclaration.attributes.name] = {
              name: variableDeclaration.attributes.name,
              type: decodeInfo.parseType(variableDeclaration.attributes.type, states, contractName, location),
              stackDepth: stack.length,
              sourceLocation: sourceLocation
            };
          }
        });
      }
    });
  } // we check here if we are at the beginning inside a new function.
  // if that is the case, we have to add to locals tree the inputs and output params


  const functionDefinition = resolveFunctionDefinition(tree, step, previousSourceLocation);

  if (functionDefinition && (newLocation && traceHelper.isJumpDestInstruction(tree.traceManager.trace[step - 1]) || functionDefinition.attributes.isConstructor)) {
    tree.functionCallStack.push(step);
    const functionDefinitionAndInputs = {
      functionDefinition,
      inputs: []
    }; // means: the previous location was a function definition && JUMPDEST
    // => we are at the beginning of the function and input/output are setup

    tree.solidityProxy.contractNameAt(step, (error, contractName) => {
      if (!error) {
        tree.traceManager.getStackAt(step, (error, stack) => {
          if (!error) {
            var states = tree.solidityProxy.extractStatesDefinitions();

            if (functionDefinition.children && functionDefinition.children.length) {
              let inputs;
              let outputs;

              for (const element of functionDefinition.children) {
                if (element.name === 'ParameterList') {
                  if (!inputs) inputs = element;else {
                    outputs = element;
                    break;
                  }
                }
              } // input params


              if (inputs) {
                functionDefinitionAndInputs.inputs = addParams(inputs, tree, scopeId, states, contractName, previousSourceLocation, stack.length, inputs.children.length, -1);
              } // output params


              if (outputs) addParams(outputs, tree, scopeId, states, contractName, previousSourceLocation, stack.length, 0, 1);
            }
          }
        });
      }
    });
    tree.functionDefinitionsByScope[scopeId] = functionDefinitionAndInputs;
  }
} // this extract all the variable declaration for a given ast and file
// and keep this in a cache


function resolveVariableDeclaration(tree, step, sourceLocation) {
  if (!tree.variableDeclarationByFile[sourceLocation.file]) {
    const ast = tree.solidityProxy.ast(sourceLocation);

    if (ast) {
      tree.variableDeclarationByFile[sourceLocation.file] = extractVariableDeclarations(ast, tree.astWalker);
    } else {
      // console.log('Ast not found for step ' + step + '. file ' + sourceLocation.file)
      return null;
    }
  }

  return tree.variableDeclarationByFile[sourceLocation.file][sourceLocation.start + ':' + sourceLocation.length + ':' + sourceLocation.file];
} // this extract all the function definition for a given ast and file
// and keep this in a cache


function resolveFunctionDefinition(tree, step, sourceLocation) {
  if (!tree.functionDefinitionByFile[sourceLocation.file]) {
    const ast = tree.solidityProxy.ast(sourceLocation);

    if (ast) {
      tree.functionDefinitionByFile[sourceLocation.file] = extractFunctionDefinitions(ast, tree.astWalker);
    } else {
      // console.log('Ast not found for step ' + step + '. file ' + sourceLocation.file)
      return null;
    }
  }

  return tree.functionDefinitionByFile[sourceLocation.file][sourceLocation.start + ':' + sourceLocation.length + ':' + sourceLocation.file];
}

function extractVariableDeclarations(ast, astWalker) {
  const ret = {};
  astWalker.walk(ast, node => {
    if (node.name === 'VariableDeclaration') {
      ret[node.src] = node;
    }

    return true;
  });
  return ret;
}

function extractFunctionDefinitions(ast, astWalker) {
  const ret = {};
  astWalker.walk(ast, node => {
    if (node.name === 'FunctionDefinition') {
      ret[node.src] = node;
    }

    return true;
  });
  return ret;
}

function addParams(parameterList, tree, scopeId, states, contractName, sourceLocation, stackLength, stackPosition, dir) {
  let params = [];

  for (let inputParam in parameterList.children) {
    const param = parameterList.children[inputParam];
    const stackDepth = stackLength + dir * stackPosition;

    if (stackDepth >= 0) {
      let location = typesUtil.extractLocationFromAstVariable(param);
      location = location === 'default' ? 'memory' : location;
      const attributesName = param.attributes.name === '' ? `$${inputParam}` : param.attributes.name;
      tree.scopes[scopeId].locals[attributesName] = {
        name: attributesName,
        type: decodeInfo.parseType(param.attributes.type, states, contractName, location),
        stackDepth: stackDepth,
        sourceLocation: sourceLocation
      };
      params.push(attributesName);
    }

    stackPosition += dir;
  }

  return params;
}

module.exports = InternalCallTree;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/localDecoder.js":
/*!***********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/localDecoder.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

function solidityLocals(vmtraceIndex, internalTreeCall, stack, memory, storageResolver, currentSourceLocation) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const scope = internalTreeCall.findScope(vmtraceIndex);

    if (!scope) {
      const error = {
        'message': 'Can\'t display locals. reason: compilation result might not have been provided'
      };
      throw error;
    }

    const locals = {};
    memory = formatMemory(memory);
    let anonymousIncr = 1;

    for (let local in scope.locals) {
      var variable = scope.locals[local];

      if (variable.stackDepth < stack.length && variable.sourceLocation.start <= currentSourceLocation.start) {
        let name = variable.name;

        if (name.indexOf('$') !== -1) {
          name = '<' + anonymousIncr + '>';
          anonymousIncr++;
        }

        try {
          locals[name] = yield variable.type.decodeFromStack(variable.stackDepth, stack, memory, storageResolver);
        } catch (e) {
          console.log(e);
          locals[name] = '<decoding failed - ' + e.message + '>';
        }
      }
    }

    return locals;
  });
}

function formatMemory(memory) {
  if (memory instanceof Array) {
    memory = memory.join('').replace(/0x/g, '');
  }

  return memory;
}

module.exports = {
  solidityLocals: solidityLocals
};

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/solidityProxy.js":
/*!************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/solidityProxy.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const traceHelper = remixLib.helpers.trace;

const stateDecoder = __webpack_require__(/*! ./stateDecoder */ "../../../dist/libs/remix-debug/src/solidity-decoder/stateDecoder.js");

const astHelper = __webpack_require__(/*! ./astHelper */ "../../../dist/libs/remix-debug/src/solidity-decoder/astHelper.js");

const util = remixLib.util;

class SolidityProxy {
  constructor(traceManager, codeManager) {
    this.cache = new Cache();
    this.reset({});
    this.traceManager = traceManager;
    this.codeManager = codeManager;
  }
  /**
    * reset the cache and apply a new @arg compilationResult
    *
    * @param {Object} compilationResult  - result os a compilatiion (diectly returned by the compiler)
    */


  reset(compilationResult) {
    this.sources = compilationResult.sources;
    this.contracts = compilationResult.contracts;
    this.cache.reset();
  }
  /**
    * check if the object has been properly loaded
    *
    * @return {Bool} - returns true if a compilation result has been applied
    */


  loaded() {
    return this.contracts !== undefined;
  }
  /**
    * retrieve the compiled contract name at the @arg vmTraceIndex (cached)
    *
    * @param {Int} vmTraceIndex  - index in the vm trave where to resolve the executed contract name
    * @param {Function} cb  - callback returns (error, contractName)
    */


  contractNameAt(vmTraceIndex, cb) {
    this.traceManager.getCurrentCalledAddressAt(vmTraceIndex, (error, address) => {
      if (error) {
        cb(error);
      } else {
        if (this.cache.contractNameByAddress[address]) {
          cb(null, this.cache.contractNameByAddress[address]);
        } else {
          this.codeManager.getCode(address, (error, code) => {
            if (error) {
              cb(error);
            } else {
              const contractName = contractNameFromCode(this.contracts, code.bytecode, address);
              this.cache.contractNameByAddress[address] = contractName;
              cb(null, contractName);
            }
          });
        }
      }
    });
  }
  /**
    * extract the state variables of the given compiled @arg contractName (cached)
    *
    * @param {String} contractName  - name of the contract to retrieve state variables from
    * @return {Object} - returns state variables of @args contractName
    */


  extractStatesDefinitions() {
    if (!this.cache.contractDeclarations) {
      this.cache.contractDeclarations = astHelper.extractContractDefinitions(this.sources);
    }

    if (!this.cache.statesDefinitions) {
      this.cache.statesDefinitions = astHelper.extractStatesDefinitions(this.sources, this.cache.contractDeclarations);
    }

    return this.cache.statesDefinitions;
  }
  /**
    * extract the state variables of the given compiled @arg contractName (cached)
    *
    * @param {String} contractName  - name of the contract to retrieve state variables from
    * @return {Object} - returns state variables of @args contractName
    */


  extractStateVariables(contractName) {
    if (!this.cache.stateVariablesByContractName[contractName]) {
      this.cache.stateVariablesByContractName[contractName] = stateDecoder.extractStateVariables(contractName, this.sources);
    }

    return this.cache.stateVariablesByContractName[contractName];
  }
  /**
    * extract the state variables of the given compiled @arg vmtraceIndex (cached)
    *
    * @param {Int} vmTraceIndex  - index in the vm trave where to resolve the state variables
    * @return {Object} - returns state variables of @args vmTraceIndex
    */


  extractStateVariablesAt(vmtraceIndex, cb) {
    this.contractNameAt(vmtraceIndex, (error, contractName) => {
      if (error) {
        cb(error);
      } else {
        cb(null, this.extractStateVariables(contractName));
      }
    });
  }
  /**
    * get the AST of the file declare in the @arg sourceLocation
    *
    * @param {Object} sourceLocation  - source location containing the 'file' to retrieve the AST from
    * @return {Object} - AST of the current file
    */


  ast(sourceLocation) {
    const file = this.fileNameFromIndex(sourceLocation.file);

    if (this.sources[file]) {
      return this.sources[file].legacyAST;
    } else {
      // console.log('AST not found for file id ' + sourceLocation.file)
      return null;
    }
  }
  /**
   * get the filename refering to the index from the compilation result
   *
   * @param {Int} index  - index of the filename
   * @return {String} - filename
   */


  fileNameFromIndex(index) {
    return Object.keys(this.contracts)[index];
  }

}

function contractNameFromCode(contracts, code, address) {
  const isCreation = traceHelper.isContractCreation(address);

  for (let file in contracts) {
    for (let contract in contracts[file]) {
      const bytecode = isCreation ? contracts[file][contract].evm.bytecode.object : contracts[file][contract].evm.deployedBytecode.object;

      if (util.compareByteCode(code, '0x' + bytecode)) {
        return contract;
      }
    }
  }

  return null;
}

class Cache {
  constructor() {
    this.reset();
  }

  reset() {
    this.contractNameByAddress = {};
    this.stateVariablesByContractName = {};
    this.contractDeclarations = null;
    this.statesDefinitions = null;
  }

}

module.exports = SolidityProxy;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/stateDecoder.js":
/*!***********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/stateDecoder.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const astHelper = __webpack_require__(/*! ./astHelper */ "../../../dist/libs/remix-debug/src/solidity-decoder/astHelper.js");

const decodeInfo = __webpack_require__(/*! ./decodeInfo */ "../../../dist/libs/remix-debug/src/solidity-decoder/decodeInfo.js");
/**
  * decode the contract state storage
  *
  * @param {Array} storage location  - location of all state variables
  * @param {Object} storageResolver  - resolve storage queries
  * @return {Map} - decoded state variable
  */


function decodeState(stateVars, storageResolver) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const ret = {};

    for (var k in stateVars) {
      var stateVar = stateVars[k];

      try {
        const decoded = yield stateVar.type.decodeFromStorage(stateVar.storagelocation, storageResolver);
        decoded.constant = stateVar.constant;

        if (decoded.constant) {
          decoded.value = '<constant>';
        }

        ret[stateVar.name] = decoded;
      } catch (e) {
        console.log(e);
        ret[stateVar.name] = '<decoding failed - ' + e.message + '>';
      }
    }

    return ret;
  });
}
/**
  * return all storage location variables of the given @arg contractName
  *
  * @param {String} contractName  - name of the contract
  * @param {Object} sourcesList  - sources list
  * @return {Object} - return the location of all contract variables in the storage
  */


function extractStateVariables(contractName, sourcesList) {
  const states = astHelper.extractStatesDefinitions(sourcesList);

  if (!states[contractName]) {
    return [];
  }

  const types = states[contractName].stateVariables;
  const offsets = decodeInfo.computeOffsets(types, states, contractName, 'storage');

  if (!offsets) {
    return []; // TODO should maybe return an error
  }

  return offsets.typesOffsets;
}
/**
  * return the state of the given @a contractName as a json object
  *
  * @param {Object} storageResolver  - resolve storage queries
  * @param {astList} astList  - AST nodes of all the sources
  * @param {String} contractName  - contract for which state var should be resolved
  * @return {Map} - return the state of the contract
  */


function solidityState(storageResolver, astList, contractName) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const stateVars = extractStateVariables(contractName, astList);

    try {
      return yield decodeState(stateVars, storageResolver);
    } catch (e) {
      return '<decoding failed - ' + e.message + '>';
    }
  });
}

module.exports = {
  solidityState: solidityState,
  extractStateVariables: extractStateVariables,
  decodeState: decodeState
};

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Address.js":
/*!************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Address.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const util = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const ValueType = __webpack_require__(/*! ./ValueType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js");

class Address extends ValueType {
  constructor() {
    super(1, 20, 'address');
  }

  decodeValue(value) {
    if (!value) {
      return '0x0000000000000000000000000000000000000000';
    } else {
      return '0x' + util.extractHexByteSlice(value, this.storageBytes, 0).toUpperCase();
    }
  }

}

module.exports = Address;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ArrayType.js":
/*!**************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/ArrayType.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const util = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const sha3256 = remixLib.util.sha3_256;

const BN = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js").BN;

const RefType = __webpack_require__(/*! ./RefType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/RefType.js");

class ArrayType extends RefType {
  constructor(underlyingType, arraySize, location) {
    let storageSlots = null;

    if (arraySize === 'dynamic') {
      storageSlots = 1;
    } else {
      if (underlyingType.storageBytes < 32) {
        const itemPerSlot = Math.floor(32 / underlyingType.storageBytes);
        storageSlots = Math.ceil(arraySize / itemPerSlot);
      } else {
        storageSlots = arraySize * underlyingType.storageSlots;
      }
    }

    const size = arraySize !== 'dynamic' ? arraySize : '';
    super(storageSlots, 32, underlyingType.typeName + '[' + size + ']', location);
    this.underlyingType = underlyingType;
    this.arraySize = arraySize;
  }

  decodeFromStorage(location, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const ret = [];
      let size = null;
      let slotValue;

      try {
        slotValue = yield util.extractHexValue(location, storageResolver, this.storageBytes);
      } catch (e) {
        console.log(e);
        return {
          value: '<decoding failed - ' + e.message + '>',
          type: this.typeName
        };
      }

      const currentLocation = {
        offset: 0,
        slot: location.slot
      };

      if (this.arraySize === 'dynamic') {
        size = util.toBN('0x' + slotValue);
        currentLocation.slot = sha3256(location.slot);
      } else {
        size = new BN(this.arraySize);
      }

      var k = util.toBN(0);

      for (; k.lt(size) && k.ltn(300); k.iaddn(1)) {
        try {
          ret.push(yield this.underlyingType.decodeFromStorage(currentLocation, storageResolver));
        } catch (e) {
          return {
            value: '<decoding failed - ' + e.message + '>',
            type: this.typeName
          };
        }

        if (this.underlyingType.storageSlots === 1 && location.offset + this.underlyingType.storageBytes <= 32) {
          currentLocation.offset += this.underlyingType.storageBytes;

          if (currentLocation.offset + this.underlyingType.storageBytes > 32) {
            currentLocation.offset = 0;
            currentLocation.slot = '0x' + util.add(currentLocation.slot, 1).toString(16);
          }
        } else {
          currentLocation.slot = '0x' + util.add(currentLocation.slot, this.underlyingType.storageSlots).toString(16);
          currentLocation.offset = 0;
        }
      }

      return {
        value: ret,
        length: '0x' + size.toString(16),
        type: this.typeName
      };
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    const ret = [];
    let length = this.arraySize;

    if (this.arraySize === 'dynamic') {
      length = memory.substr(2 * offset, 64);
      length = parseInt(length, 16);
      offset = offset + 32;
    }

    for (var k = 0; k < length; k++) {
      var contentOffset = offset;
      ret.push(this.underlyingType.decodeFromMemory(contentOffset, memory));
      offset += 32;
    }

    return {
      value: ret,
      length: '0x' + length.toString(16),
      type: this.typeName
    };
  }

}

module.exports = ArrayType;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Bool.js":
/*!*********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Bool.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ValueType = __webpack_require__(/*! ./ValueType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js");

const util = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

class Bool extends ValueType {
  constructor() {
    super(1, 1, 'bool');
  }

  decodeValue(value) {
    if (!value) {
      return false;
    } else {
      value = util.extractHexByteSlice(value, this.storageBytes, 0);
      return value !== '00';
    }
  }

}

module.exports = Bool;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/DynamicByteArray.js":
/*!*********************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/DynamicByteArray.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const util = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const sha3256 = remixLib.util.sha3_256;

const BN = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js").BN;

const RefType = __webpack_require__(/*! ./RefType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/RefType.js");

class DynamicByteArray extends RefType {
  constructor(location) {
    super(1, 32, 'bytes', location);
  }

  decodeFromStorage(location, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      let value = '0x0';

      try {
        value = yield util.extractHexValue(location, storageResolver, this.storageBytes);
      } catch (e) {
        console.log(e);
        return {
          value: '<decoding failed - ' + e.message + '>',
          type: this.typeName
        };
      }

      const bn = new BN(value, 16);

      if (bn.testn(0)) {
        const length = bn.div(new BN(2));
        let dataPos = new BN(sha3256(location.slot).replace('0x', ''), 16);
        let ret = '';
        let currentSlot = '0x';

        try {
          currentSlot = yield util.readFromStorage(dataPos, storageResolver);
        } catch (e) {
          console.log(e);
          return {
            value: '<decoding failed - ' + e.message + '>',
            type: this.typeName
          };
        }

        while (length.gt(ret.length) && ret.length < 32000) {
          currentSlot = currentSlot.replace('0x', '');
          ret += currentSlot;
          dataPos = dataPos.add(new BN(1));

          try {
            currentSlot = yield util.readFromStorage(dataPos, storageResolver);
          } catch (e) {
            console.log(e);
            return {
              value: '<decoding failed - ' + e.message + '>',
              type: this.typeName
            };
          }
        }

        return {
          value: '0x' + ret.replace(/(00)+$/, ''),
          length: '0x' + length.toString(16),
          type: this.typeName
        };
      } else {
        var size = parseInt(value.substr(value.length - 2, 2), 16) / 2;
        return {
          value: '0x' + value.substr(0, size * 2),
          length: '0x' + size.toString(16),
          type: this.typeName
        };
      }
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    offset = 2 * offset;
    let length = memory.substr(offset, 64);
    length = 2 * parseInt(length, 16);
    return {
      length: '0x' + length.toString(16),
      value: '0x' + memory.substr(offset + 64, length),
      type: this.typeName
    };
  }

}

module.exports = DynamicByteArray;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Enum.js":
/*!*********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Enum.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ValueType = __webpack_require__(/*! ./ValueType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js");

class Enum extends ValueType {
  constructor(enumDef) {
    let storageBytes = 0;
    let length = enumDef.children.length;

    while (length > 1) {
      length = length / 256;
      storageBytes++;
    }

    super(1, storageBytes, 'enum');
    this.enumDef = enumDef;
  }

  decodeValue(value) {
    if (!value) {
      return this.enumDef.children[0].attributes.name;
    } else {
      value = parseInt(value, 16);

      if (this.enumDef.children.length > value) {
        return this.enumDef.children[value].attributes.name;
      } else {
        return 'INVALID_ENUM<' + value + '>';
      }
    }
  }

}

module.exports = Enum;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/FixedByteArray.js":
/*!*******************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/FixedByteArray.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ValueType = __webpack_require__(/*! ./ValueType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js");

class FixedByteArray extends ValueType {
  constructor(storageBytes) {
    super(1, storageBytes, 'bytes' + storageBytes);
  }

  decodeValue(value) {
    return '0x' + value.substr(0, 2 * this.storageBytes).toUpperCase();
  }

}

module.exports = FixedByteArray;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Int.js":
/*!********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Int.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const util = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const ValueType = __webpack_require__(/*! ./ValueType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js");

class Int extends ValueType {
  constructor(storageBytes) {
    super(1, storageBytes, 'int' + storageBytes * 8);
  }

  decodeValue(value) {
    value = util.extractHexByteSlice(value, this.storageBytes, 0);
    return util.decodeIntFromHex(value, this.storageBytes, true);
  }

}

module.exports = Int;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Mapping.js":
/*!************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Mapping.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const RefType = __webpack_require__(/*! ./RefType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/RefType.js");

const util = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const ethutil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

class Mapping extends RefType {
  constructor(underlyingTypes, location, fullType) {
    super(1, 32, fullType, 'storage');
    this.keyType = underlyingTypes.keyType;
    this.valueType = underlyingTypes.valueType;
    this.initialDecodedState = null;
  }

  decodeFromStorage(location, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const corrections = this.valueType.members ? this.valueType.members.map(value => {
        return value.storagelocation;
      }) : [];

      if (!this.initialDecodedState) {
        // cache the decoded initial storage
        let mappingsInitialPreimages;

        try {
          mappingsInitialPreimages = yield storageResolver.initialMappingsLocation(corrections);
          this.initialDecodedState = yield this.decodeMappingsLocation(mappingsInitialPreimages, location, storageResolver);
        } catch (e) {
          return {
            value: e.message,
            type: this.typeName
          };
        }
      }

      const mappingPreimages = yield storageResolver.mappingsLocation(corrections);
      let ret = yield this.decodeMappingsLocation(mappingPreimages, location, storageResolver); // fetch mapping storage changes

      ret = Object.assign({}, this.initialDecodedState, ret); // merge changes

      return {
        value: ret,
        type: this.typeName
      };
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    // mappings can only exist in storage and not in memory
    // so this should never be called
    return {
      value: '<not implemented>',
      length: '0x',
      type: this.typeName
    };
  }

  decodeMappingsLocation(preimages, location, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const mapSlot = util.normalizeHex(ethutil.bufferToHex(location.slot));

      if (!preimages[mapSlot]) {
        return {};
      }

      const ret = {};

      for (let i in preimages[mapSlot]) {
        const mapLocation = getMappingLocation(i, location.slot);
        const globalLocation = {
          offset: location.offset,
          slot: mapLocation
        };
        ret[i] = yield this.valueType.decodeFromStorage(globalLocation, storageResolver);
      }

      return ret;
    });
  }

}

function getMappingLocation(key, position) {
  // mapping storage location decribed at http://solidity.readthedocs.io/en/develop/miscellaneous.html#layout-of-state-variables-in-storage
  // > the value corresponding to a mapping key k is located at keccak256(k . p) where . is concatenation.
  // key should be a hex string, and position an int
  const mappingK = ethutil.toBuffer('0x' + key);
  let mappingP = ethutil.intToBuffer(position);
  mappingP = ethutil.setLengthLeft(mappingP, 32);
  const mappingKeyBuf = concatTypedArrays(mappingK, mappingP);
  const mappingKeyPreimage = '0x' + mappingKeyBuf.toString('hex');
  let mappingStorageLocation = ethutil.keccak(mappingKeyPreimage);
  mappingStorageLocation = new ethutil.BN(mappingStorageLocation, 16);
  return mappingStorageLocation;
}

function concatTypedArrays(a, b) {
  let c = new a.constructor(a.length + b.length);
  c.set(a, 0);
  c.set(b, a.length);
  return c;
}

module.exports = Mapping;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/RefType.js":
/*!************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/RefType.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const util = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

class RefType {
  constructor(storageSlots, storageBytes, typeName, location) {
    this.location = location;
    this.storageSlots = storageSlots;
    this.storageBytes = storageBytes;
    this.typeName = typeName;
    this.basicType = 'RefType';
  }
  /**
    * decode the type from the stack
    *
    * @param {Int} stackDepth - position of the type in the stack
    * @param {Array} stack - stack
    * @param {String} - memory
    * @param {Object} - storageResolver
    * @return {Object} decoded value
    */


  decodeFromStack(stackDepth, stack, memory, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (stack.length - 1 < stackDepth) {
        return {
          error: '<decoding failed - stack underflow ' + stackDepth + '>',
          type: this.typeName
        };
      }

      let offset = stack[stack.length - 1 - stackDepth];

      if (this.isInStorage()) {
        offset = util.toBN(offset);

        try {
          return yield this.decodeFromStorage({
            offset: 0,
            slot: offset
          }, storageResolver);
        } catch (e) {
          console.log(e);
          return {
            error: '<decoding failed - ' + e.message + '>',
            type: this.typeName
          };
        }
      } else if (this.isInMemory()) {
        offset = parseInt(offset, 16);
        return this.decodeFromMemoryInternal(offset, memory);
      } else {
        return {
          error: '<decoding failed - no decoder for ' + this.location + '>',
          type: this.typeName
        };
      }
    });
  }
  /**
    * decode the type from the memory
    *
    * @param {Int} offset - position of the ref of the type in memory
    * @param {String} memory - memory
    * @return {Object} decoded value
    */


  decodeFromMemory(offset, memory) {
    offset = memory.substr(2 * offset, 64);
    offset = parseInt(offset, 16);
    return this.decodeFromMemoryInternal(offset, memory);
  }
  /**
    * current type defined in storage
    *
    * @return {Bool} - return true if the type is defined in the storage
    */


  isInStorage() {
    return this.location.indexOf('storage') === 0;
  }
  /**
    * current type defined in memory
    *
    * @return {Bool} - return true if the type is defined in the memory
    */


  isInMemory() {
    return this.location.indexOf('memory') === 0;
  }

}

module.exports = RefType;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/StringType.js":
/*!***************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/StringType.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const DynamicBytes = __webpack_require__(/*! ./DynamicByteArray */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/DynamicByteArray.js");

class StringType extends DynamicBytes {
  constructor(location) {
    super(location);
    this.typeName = 'string';
  }

  decodeFromStorage(location, storageResolver) {
    const _super = Object.create(null, {
      decodeFromStorage: {
        get: () => super.decodeFromStorage
      }
    });

    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      let decoded = '0x';

      try {
        decoded = yield _super.decodeFromStorage.call(this, location, storageResolver);
      } catch (e) {
        console.log(e);
        return '<decoding failed - ' + e.message + '>';
      }

      return format(decoded);
    });
  }

  decodeFromStack(stackDepth, stack, memory) {
    const _super = Object.create(null, {
      decodeFromStack: {
        get: () => super.decodeFromStack
      }
    });

    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      try {
        return yield _super.decodeFromStack.call(this, stackDepth, stack, memory);
      } catch (e) {
        console.log(e);
        return '<decoding failed - ' + e.message + '>';
      }
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    const decoded = super.decodeFromMemoryInternal(offset, memory);
    return format(decoded);
  }

}

function format(decoded) {
  if (decoded.error) {
    return decoded;
  }

  let value = decoded.value;
  value = value.replace('0x', '').replace(/(..)/g, '%$1');
  const ret = {
    length: decoded.length,
    raw: decoded.value,
    type: 'string'
  };

  try {
    ret.value = decodeURIComponent(value);
  } catch (e) {
    ret.error = 'Invalid UTF8 encoding';
    ret.raw = decoded.value;
  }

  return ret;
}

module.exports = StringType;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Struct.js":
/*!***********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Struct.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const util = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const RefType = __webpack_require__(/*! ./RefType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/RefType.js");

class Struct extends RefType {
  constructor(memberDetails, location, fullType) {
    super(memberDetails.storageSlots, 32, 'struct ' + fullType, location);
    this.members = memberDetails.members;
  }

  decodeFromStorage(location, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const ret = {};

      for (var item of this.members) {
        const globalLocation = {
          offset: location.offset + item.storagelocation.offset,
          slot: util.add(location.slot, item.storagelocation.slot)
        };

        try {
          ret[item.name] = yield item.type.decodeFromStorage(globalLocation, storageResolver);
        } catch (e) {
          console.log(e);
          ret[item.name] = '<decoding failed - ' + e.message + '>';
        }
      }

      return {
        value: ret,
        type: this.typeName
      };
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    const ret = {};
    this.members.map((item, i) => {
      var contentOffset = offset;
      var member = item.type.decodeFromMemory(contentOffset, memory);
      ret[item.name] = member;
      offset += 32;
    });
    return {
      value: ret,
      type: this.typeName
    };
  }

}

module.exports = Struct;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/Uint.js":
/*!*********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/Uint.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const util = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

const ValueType = __webpack_require__(/*! ./ValueType */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js");

class Uint extends ValueType {
  constructor(storageBytes) {
    super(1, storageBytes, 'uint' + storageBytes * 8);
  }

  decodeValue(value) {
    value = util.extractHexByteSlice(value, this.storageBytes, 0);
    return util.decodeIntFromHex(value, this.storageBytes, false);
  }

}

module.exports = Uint;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js":
/*!**************************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/ValueType.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

var util = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

class ValueType {
  constructor(storageSlots, storageBytes, typeName) {
    this.storageSlots = storageSlots;
    this.storageBytes = storageBytes;
    this.typeName = typeName;
    this.basicType = 'ValueType';
  }
  /**
    * decode the type with the @arg location from the storage
    *
    * @param {Object} location - containing offset and slot
    * @param {Object} storageResolver  - resolve storage queries
    * @return {Object} - decoded value
    */


  decodeFromStorage(location, storageResolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      try {
        var value = yield util.extractHexValue(location, storageResolver, this.storageBytes);
        return {
          value: this.decodeValue(value),
          type: this.typeName
        };
      } catch (e) {
        console.log(e);
        return {
          value: '<decoding failed - ' + e.message + '>',
          type: this.typeName
        };
      }
    });
  }
  /**
    * decode the type from the stack
    *
    * @param {Int} stackDepth - position of the type in the stack
    * @param {Array} stack - stack
    * @param {String} - memory
    * @return {Object} - decoded value
    */


  decodeFromStack(stackDepth, stack, memory) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      let value;

      if (stackDepth >= stack.length) {
        value = this.decodeValue('');
      } else {
        value = this.decodeValue(stack[stack.length - 1 - stackDepth].replace('0x', ''));
      }

      return {
        value: value,
        type: this.typeName
      };
    });
  }
  /**
    * decode the type with the @arg offset location from the memory
    *
    * @param {Int} stackDepth - position of the type in the stack
    * @return {String} - memory
    * @return {Object} - decoded value
    */


  decodeFromMemory(offset, memory) {
    let value = memory.substr(2 * offset, 64);
    return {
      value: this.decodeValue(value),
      type: this.typeName
    };
  }

}

module.exports = ValueType;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js":
/*!*********************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/solidity-decoder/types/util.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const ethutil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const BN = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js").BN;

module.exports = {
  readFromStorage: readFromStorage,
  decodeIntFromHex: decodeIntFromHex,
  extractHexValue: extractHexValue,
  extractHexByteSlice: extractHexByteSlice,
  toBN: toBN,
  add: add,
  sub: sub,
  extractLocation: extractLocation,
  removeLocation: removeLocation,
  normalizeHex: normalizeHex,
  extractLocationFromAstVariable: extractLocationFromAstVariable
};

function decodeIntFromHex(value, byteLength, signed) {
  let bigNumber = new BN(value, 16);

  if (signed) {
    bigNumber = bigNumber.fromTwos(8 * byteLength);
  }

  return bigNumber.toString(10);
}

function readFromStorage(slot, storageResolver) {
  const hexSlot = '0x' + normalizeHex(ethutil.bufferToHex(slot));
  return new Promise((resolve, reject) => {
    storageResolver.storageSlot(hexSlot, (error, slot) => {
      if (error) {
        return reject(error);
      } else {
        if (!slot) {
          slot = {
            key: slot,
            value: ''
          };
        }

        return resolve(normalizeHex(slot.value));
      }
    });
  });
}
/**
 * @returns a hex encoded byte slice of length @arg byteLength from inside @arg slotValue.
 *
 * @param {String} slotValue  - hex encoded value to extract the byte slice from
 * @param {Int} byteLength  - Length of the byte slice to extract
 * @param {Int} offsetFromLSB  - byte distance from the right end slot value to the right end of the byte slice
 */


function extractHexByteSlice(slotValue, byteLength, offsetFromLSB) {
  const offset = slotValue.length - 2 * offsetFromLSB - 2 * byteLength;
  return slotValue.substr(offset, 2 * byteLength);
}
/**
 * @returns a hex encoded storage content at the given @arg location. it does not have Ox prefix but always has the full length.
 *
 * @param {Object} location  - object containing the slot and offset of the data to extract.
 * @param {Object} storageResolver  - storage resolver
 * @param {Int} byteLength  - Length of the byte slice to extract
 */


function extractHexValue(location, storageResolver, byteLength) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    let slotvalue;

    try {
      slotvalue = yield readFromStorage(location.slot, storageResolver);
    } catch (e) {
      return '0x';
    }

    return extractHexByteSlice(slotvalue, byteLength, location.offset);
  });
}

function toBN(value) {
  if (value instanceof BN) {
    return value;
  } else if (value.match && value.match(/^(0x)?([a-f0-9]*)$/)) {
    value = ethutil.unpad(value.replace(/^(0x)/, ''));
    value = new BN(value === '' ? '0' : value, 16);
  } else if (!isNaN(value)) {
    value = new BN(value);
  }

  return value;
}

function add(value1, value2) {
  return toBN(value1).add(toBN(value2));
}

function sub(value1, value2) {
  return toBN(value1).sub(toBN(value2));
}

function removeLocation(type) {
  return type.replace(/( storage ref| storage pointer| memory| calldata)/g, '');
}

function extractLocation(type) {
  let match = type.match(/( storage ref| storage pointer| memory| calldata)?$/);

  if (match[1] !== '') {
    return match[1].trim();
  } else {
    return null;
  }
}

function extractLocationFromAstVariable(node) {
  if (node.attributes.storageLocation !== 'default') {
    return node.attributes.storageLocation;
  } else if (node.attributes.stateVariable) {
    return 'storage';
  } else {
    return 'default'; // local variables => storage, function parameters & return values => memory, state => storage
  }
}

function normalizeHex(hex) {
  hex = hex.replace('0x', '');

  if (hex.length < 64) {
    return new Array(64 - hex.length + 1).join('0') + hex;
  }

  return hex;
}

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/storage/mappingPreimages.js":
/*!******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/storage/mappingPreimages.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const util = __webpack_require__(/*! ../solidity-decoder/types/util */ "../../../dist/libs/remix-debug/src/solidity-decoder/types/util.js");

module.exports = {
  decodeMappingsKeys: decodeMappingsKeys
};
/**
  * extract the mappings location from the storage
  * like { "<mapping_slot>" : { "<mapping-key1>": preimageOf1 }, { "<mapping-key2>": preimageOf2 }, ... }
  *
  * @param {Object} storage  - storage given by storage Viewer (basically a mapping hashedkey : {key, value})
  * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
  * @param {Function} callback  - calback
  * @return {Map} - solidity mapping location (e.g { "<mapping_slot>" : { "<mapping-key1>": preimageOf1 }, { "<mapping-key2>": preimageOf2 }, ... })
  */

function decodeMappingsKeys(web3, storage, corrections, callback) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const ret = {};
    if (!corrections.length) corrections.push({
      offset: 0,
      slot: 0
    });

    for (let hashedLoc in storage) {
      var preimage;

      try {
        const key = storage[hashedLoc].key;

        for (let k in corrections) {
          const corrected = util.sub(key, corrections[k].slot).toString(16);
          preimage = yield getPreimage(web3, '0x' + corrected);
          if (preimage) break;
        }
      } catch (e) {} // eslint-disable-line no-empty


      if (preimage) {
        // got preimage!
        // get mapping position (i.e. storage slot), its the last 32 bytes
        const slotByteOffset = preimage.length - 64;
        const mappingSlot = preimage.substr(slotByteOffset);
        const mappingKey = preimage.substr(0, slotByteOffset);

        if (!ret[mappingSlot]) {
          ret[mappingSlot] = {};
        }

        ret[mappingSlot][mappingKey] = preimage;
      }
    }

    callback(null, ret);
  });
}
/**
  * Uses web3 to return preimage of a key
  *
  * @param {String} key  - key to retrieve the preimage of
  * @return {String} - preimage of the given key
  */


function getPreimage(web3, key) {
  return new Promise((resolve, reject) => {
    web3.debug.preimage(key.indexOf('0x') === 0 ? key : '0x' + key, (error, preimage) => {
      if (error) {
        resolve(null);
      } else {
        resolve(preimage);
      }
    });
  });
}

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/storage/storageResolver.js":
/*!*****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/storage/storageResolver.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const traceHelper = remixLib.helpers.trace;

const mappingPreimages = __webpack_require__(/*! ./mappingPreimages */ "../../../dist/libs/remix-debug/src/storage/mappingPreimages.js");
/**
  * Basically one instance is created for one debugging session.
  * (TODO: one instance need to be shared over all the components)
  */


class StorageResolver {
  constructor(options) {
    this.storageByAddress = {};
    this.preimagesMappingByAddress = {};
    this.maxSize = 100;
    this.web3 = options.web3;
    this.zeroSlot = '0x0000000000000000000000000000000000000000000000000000000000000000';
  }
  /**
   * returns the storage for the given context (address and vm trace index)
   * returns the range 0x0 => this.maxSize
   *
   * @param {Object} - tx - transaction
   * @param {Int} - stepIndex - Index of the stop in the vm trace
   * @param {String} - address - lookup address
   * @param {Function} - callback - contains a map: [hashedKey] = {key, hashedKey, value}
   */


  storageRange(tx, stepIndex, address, callback) {
    this.storageRangeInternal(this, this.zeroSlot, tx, stepIndex, address, callback);
  }
  /**
   * compute the mappgings type locations for the current address (cached for a debugging session)
   * note: that only retrieve the first 100 items.
   *
   * @param {Object} tx
   * @param {Int} stepIndex
   * @param {Object} address  - storage
   * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
   * @return {Function} - callback
   */


  initialPreimagesMappings(tx, stepIndex, address, corrections, callback) {
    if (this.preimagesMappingByAddress[address]) {
      return callback(null, this.preimagesMappingByAddress[address]);
    }

    this.storageRange(tx, stepIndex, address, (error, storage) => {
      if (error) {
        return callback(error);
      }

      mappingPreimages.decodeMappingsKeys(this.web3, storage, corrections, (error, mappings) => {
        if (error) {
          callback(error);
        } else {
          this.preimagesMappingByAddress[address] = mappings;
          callback(null, mappings);
        }
      });
    });
  }
  /**
   * return a slot value for the given context (address and vm trace index)
   *
   * @param {String} - slot - slot key
   * @param {Object} - tx - transaction
   * @param {Int} - stepIndex - Index of the stop in the vm trace
   * @param {String} - address - lookup address
   * @param {Function} - callback - {key, hashedKey, value} -
   */


  storageSlot(slot, tx, stepIndex, address, callback) {
    this.storageRangeInternal(this, slot, tx, stepIndex, address, (error, storage) => {
      if (error) {
        callback(error);
      } else {
        callback(null, storage[slot] !== undefined ? storage[slot] : null);
      }
    });
  }
  /**
   * return True if the storage at @arg address is complete
   *
   * @param {String} address  - contract address
   * @return {Bool} - return True if the storage at @arg address is complete
   */


  isComplete(address) {
    return this.storageByAddress[address] && this.storageByAddress[address].complete;
  }
  /**
   * retrieve the storage and ensure at least @arg slot is cached.
   * - If @arg slot is already cached, the storage will be returned from the cache
   *   even if the next 1000 items are not in the cache.
   * - If @arg slot is not cached, the corresponding value will be resolved and the next 1000 slots.
   */


  storageRangeInternal(self, slotKey, tx, stepIndex, address, callback) {
    var cached = this.fromCache(self, address);

    if (cached && cached.storage[slotKey]) {
      // we have the current slot in the cache and maybe the next 1000...
      return callback(null, cached.storage);
    }

    this.storageRangeWeb3Call(tx, address, slotKey, self.maxSize, (error, storage, nextKey) => {
      if (error) {
        return callback(error);
      }

      if (!storage[slotKey] && slotKey !== self.zeroSlot) {
        // we don't cache the zero slot (could lead to inconsistency)
        storage[slotKey] = {
          key: slotKey,
          value: self.zeroSlot
        };
      }

      self.toCache(self, address, storage);

      if (slotKey === self.zeroSlot && !nextKey) {
        // only working if keys are sorted !!
        self.storageByAddress[address].complete = true;
      }

      callback(null, storage);
    });
  }
  /**
   * retrieve the storage from the cache. if @arg slot is defined, return only the desired slot, if not return the entire known storage
   *
   * @param {String} address  - contract address
   * @return {String} - either the entire known storage or a single value
   */


  fromCache(self, address) {
    if (!self.storageByAddress[address]) {
      return null;
    }

    return self.storageByAddress[address];
  }
  /**
   * store the result of `storageRangeAtInternal`
   *
   * @param {String} address  - contract address
   * @param {Object} storage  - result of `storageRangeAtInternal`, contains {key, hashedKey, value}
   */


  toCache(self, address, storage) {
    if (!self.storageByAddress[address]) {
      self.storageByAddress[address] = {};
    }

    self.storageByAddress[address].storage = Object.assign(self.storageByAddress[address].storage || {}, storage);
  }

  storageRangeWeb3Call(tx, address, start, maxSize, callback) {
    if (traceHelper.isContractCreation(address)) {
      callback(null, {}, null);
    } else {
      this.web3.debug.storageRangeAt(tx.blockHash, tx.transactionIndex === undefined ? tx.hash : tx.transactionIndex, address, start, maxSize, (error, result) => {
        if (error) {
          callback(error);
        } else if (result.storage) {
          callback(null, result.storage, result.nextKey);
        } else {
          callback('the storage has not been provided');
        }
      });
    }
  }

}

module.exports = StorageResolver;

/***/ }),

/***/ "../../../dist/libs/remix-debug/src/storage/storageViewer.js":
/*!***************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-debug/src/storage/storageViewer.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const util = remixLib.util;

const mappingPreimages = __webpack_require__(/*! ./mappingPreimages */ "../../../dist/libs/remix-debug/src/storage/mappingPreimages.js");
/**
  * easier access to the storage resolver
  * Basically one instance is created foreach execution step and foreach component that need it.
  * (TODO: one instance need to be shared over all the components)
  */


class StorageViewer {
  constructor(_context, _storageResolver, _traceManager) {
    this.context = _context;
    this.storageResolver = _storageResolver;
    this.web3 = this.storageResolver.web3;
    this.initialMappingsLocationPromise = null;
    this.currentMappingsLocationPromise = null;

    _traceManager.accumulateStorageChanges(this.context.stepIndex, this.context.address, {}, (error, storageChanges) => {
      if (!error) {
        this.storageChanges = storageChanges;
      } else {
        console.log(error);
      }
    });
  }
  /**
    * return the storage for the current context (address and vm trace index)
    * by default now returns the range 0 => 1000
    *
    * @param {Function} - callback - contains a map: [hashedKey] = {key, hashedKey, value}
    */


  storageRange(callback) {
    this.storageResolver.storageRange(this.context.tx, this.context.stepIndex, this.context.address, (error, storage) => {
      if (error) {
        callback(error);
      } else {
        callback(null, Object.assign({}, storage, this.storageChanges));
      }
    });
  }
  /**
    * return a slot value for the current context (address and vm trace index)
    * @param {String} - slot - slot key (not hashed key!)
    * @param {Function} - callback - {key, hashedKey, value} -
    */


  storageSlot(slot, callback) {
    const hashed = util.sha3_256(slot);

    if (this.storageChanges[hashed]) {
      return callback(null, this.storageChanges[hashed]);
    }

    this.storageResolver.storageSlot(hashed, this.context.tx, this.context.stepIndex, this.context.address, (error, storage) => {
      if (error) {
        callback(error);
      } else {
        callback(null, storage);
      }
    });
  }
  /**
    * return True if the storage at @arg address is complete
    *
    * @param {String} address  - contract address
    * @return {Bool} - return True if the storage at @arg address is complete
    */


  isComplete(address) {
    return this.storageResolver.isComplete(address);
  }
  /**
    * return all the possible mappings locations for the current context (cached) do not return state changes during the current transaction
    *
    * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
    */


  initialMappingsLocation(corrections) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.initialMappingsLocationPromise) {
        this.initialMappingsLocationPromise = new Promise((resolve, reject) => {
          this.storageResolver.initialPreimagesMappings(this.context.tx, this.context.stepIndex, this.context.address, corrections, (error, initialMappingsLocation) => {
            if (error) {
              reject(error);
            } else {
              resolve(initialMappingsLocation);
            }
          });
        });
      }

      return this.initialMappingsLocationPromise;
    });
  }
  /**
    * return all the possible mappings locations for the current context (cached) and current mapping slot. returns state changes during the current transaction
    *
    * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
    */


  mappingsLocation(corrections) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.currentMappingsLocationPromise) {
        this.currentMappingsLocationPromise = new Promise((resolve, reject) => {
          this.extractMappingsLocationChanges(this.storageChanges, corrections, (error, mappingsLocationChanges) => {
            if (error) {
              reject(error);
            } else {
              resolve(mappingsLocationChanges);
            }
          });
        });
      }

      return this.currentMappingsLocationPromise;
    });
  }
  /**
    * retrieve mapping location changes from the storage changes.
    * @param {Map} storageChanges
    * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
    */


  extractMappingsLocationChanges(storageChanges, corrections, callback) {
    if (this.mappingsLocationChanges) {
      return callback(null, this.mappingsLocationChanges);
    }

    mappingPreimages.decodeMappingsKeys(this.web3, storageChanges, corrections, (error, mappings) => {
      if (!error) {
        this.mappingsLocationChanges = mappings;
        return callback(null, this.mappingsLocationChanges);
      } else {
        callback(error);
      }
    });
  }

}

module.exports = StorageViewer;

/***/ }),

/***/ "../../../dist/libs/remix-lib/index.js":
/*!*****************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventManager = __webpack_require__(/*! ./src/eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

const traceHelper = __webpack_require__(/*! ./src/helpers/traceHelper */ "../../../dist/libs/remix-lib/src/helpers/traceHelper.js");

const uiHelper = __webpack_require__(/*! ./src/helpers/uiHelper */ "../../../dist/libs/remix-lib/src/helpers/uiHelper.js");

const compilerHelper = __webpack_require__(/*! ./src/helpers/compilerHelper */ "../../../dist/libs/remix-lib/src/helpers/compilerHelper.js");

const SourceMappingDecoder = __webpack_require__(/*! ./src/sourceMappingDecoder */ "../../../dist/libs/remix-lib/src/sourceMappingDecoder.js");

const SourceLocationTracker = __webpack_require__(/*! ./src/sourceLocationTracker */ "../../../dist/libs/remix-lib/src/sourceLocationTracker.js");

const OffsetToColumnConverter = __webpack_require__(/*! ./src/offsetToLineColumnConverter */ "../../../dist/libs/remix-lib/src/offsetToLineColumnConverter.js");

const init = __webpack_require__(/*! ./src/init */ "../../../dist/libs/remix-lib/src/init.js");

const util = __webpack_require__(/*! ./src/util */ "../../../dist/libs/remix-lib/src/util.js");

const Web3Providers = __webpack_require__(/*! ./src/web3Provider/web3Providers */ "../../../dist/libs/remix-lib/src/web3Provider/web3Providers.js");

const DummyProvider = __webpack_require__(/*! ./src/web3Provider/dummyProvider */ "../../../dist/libs/remix-lib/src/web3Provider/dummyProvider.js");

const Web3VMProvider = __webpack_require__(/*! ./src/web3Provider/web3VmProvider */ "../../../dist/libs/remix-lib/src/web3Provider/web3VmProvider.js");

const AstWalker = __webpack_require__(/*! ./src/astWalker */ "../../../dist/libs/remix-lib/src/astWalker.js");

const Storage = __webpack_require__(/*! ./src/storage */ "../../../dist/libs/remix-lib/src/storage.js");

const EventsDecoder = __webpack_require__(/*! ./src/execution/eventsDecoder */ "../../../dist/libs/remix-lib/src/execution/eventsDecoder.js");

const txExecution = __webpack_require__(/*! ./src/execution/txExecution */ "../../../dist/libs/remix-lib/src/execution/txExecution.js");

const txHelper = __webpack_require__(/*! ./src/execution/txHelper */ "../../../dist/libs/remix-lib/src/execution/txHelper.js");

const txFormat = __webpack_require__(/*! ./src/execution/txFormat */ "../../../dist/libs/remix-lib/src/execution/txFormat.js");

const txListener = __webpack_require__(/*! ./src/execution/txListener */ "../../../dist/libs/remix-lib/src/execution/txListener.js");

const txRunner = __webpack_require__(/*! ./src/execution/txRunner */ "../../../dist/libs/remix-lib/src/execution/txRunner.js");

const executionContext = __webpack_require__(/*! ./src/execution/execution-context */ "../../../dist/libs/remix-lib/src/execution/execution-context.js");

const typeConversion = __webpack_require__(/*! ./src/execution/typeConversion */ "../../../dist/libs/remix-lib/src/execution/typeConversion.js");

const CodeManager = __webpack_require__(/*! ./src/code/codeManager */ "../../../dist/libs/remix-lib/src/code/codeManager.js");

const BreakpointManager = __webpack_require__(/*! ./src/code/breakpointManager */ "../../../dist/libs/remix-lib/src/code/breakpointManager.js");

const TraceManager = __webpack_require__(/*! ./src/trace/traceManager */ "../../../dist/libs/remix-lib/src/trace/traceManager.js");

const UniversalDApp = __webpack_require__(/*! ./src/universalDapp */ "../../../dist/libs/remix-lib/src/universalDapp.js");

if ( true && typeof module.exports !== 'undefined') {
  module.exports = modules();
}

function modules() {
  return {
    code: {
      CodeManager: CodeManager,
      BreakpointManager: BreakpointManager
    },
    trace: {
      TraceManager: TraceManager
    },
    EventManager: EventManager,
    helpers: {
      trace: traceHelper,
      ui: uiHelper,
      compiler: compilerHelper
    },
    vm: {
      Web3Providers: Web3Providers,
      DummyProvider: DummyProvider,
      Web3VMProvider: Web3VMProvider
    },
    SourceMappingDecoder: SourceMappingDecoder,
    SourceLocationTracker: SourceLocationTracker,
    OffsetToColumnConverter: OffsetToColumnConverter,
    Storage: Storage,
    init: init,
    util: util,
    AstWalker: AstWalker,
    execution: {
      EventsDecoder: EventsDecoder,
      txExecution: txExecution,
      txHelper: txHelper,
      executionContext: new executionContext(),
      txFormat: txFormat,
      txListener: txListener,
      txRunner: txRunner,
      typeConversion: typeConversion
    },
    UniversalDApp: UniversalDApp
  };
}

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/astWalker.js":
/*!*************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/astWalker.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Crawl the given AST through the function walk(ast, callback)
 */

function AstWalker() {}
/**
 * visit all the AST nodes
 *
 * @param {Object} ast  - AST node
 * @param {Object or Function} callback  - if (Function) the function will be called for every node.
 *                                       - if (Object) callback[<Node Type>] will be called for
 *                                         every node of type <Node Type>. callback["*"] will be called for all other nodes.
 *                                         in each case, if the callback returns false it does not descend into children.
 *                                         If no callback for the current type, children are visited.
 */


AstWalker.prototype.walk = function (ast, callback) {
  if (callback instanceof Function) {
    callback = {
      '*': callback
    };
  }

  if (!('*' in callback)) {
    callback['*'] = function () {
      return true;
    };
  }

  if (manageCallBack(ast, callback) && ast.children && ast.children.length > 0) {
    for (let k in ast.children) {
      const child = ast.children[k];
      this.walk(child, callback);
    }
  }
};
/**
 * walk the given @astList
 *
 * @param {Object} sourcesList - sources list (containing root AST node)
 * @param {Function} - callback used by AstWalker to compute response
 */


AstWalker.prototype.walkAstList = function (sourcesList, callback) {
  const walker = new AstWalker();

  for (let k in sourcesList) {
    walker.walk(sourcesList[k].legacyAST, callback);
  }
};

function manageCallBack(node, callback) {
  if (node.name in callback) {
    return callback[node.name](node);
  } else {
    return callback['*'](node);
  }
}

module.exports = AstWalker;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/code/breakpointManager.js":
/*!**************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/code/breakpointManager.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const EventManager = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

const helper = __webpack_require__(/*! ../helpers/traceHelper */ "../../../dist/libs/remix-lib/src/helpers/traceHelper.js");
/**
  * allow to manage breakpoint
  *
  * Trigger events: breakpointHit, breakpointAdded, breakpointRemoved
  */


class BreakpointManager {
  /**
    * constructor
    *
    * @param {Object} _debugger - type of EthDebugger
    * @return {Function} _locationToRowConverter - function implemented by editor which return a column/line position for a char source location
    */
  constructor(_debugger, _locationToRowConverter, _jumpToCallback) {
    this.event = new EventManager();
    this.debugger = _debugger;
    this.breakpoints = {};
    this.locationToRowConverter = _locationToRowConverter;
    this.previousLine;

    this.jumpToCallback = _jumpToCallback || (() => {});
  }
  /**
    * start looking for the next breakpoint
    * @param {Bool} defaultToLimit - if true jump to the end of the trace if no more breakpoint found
    *
    */


  jumpNextBreakpoint(fromStep, defaultToLimit) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      this.jump(fromStep || 0, 1, defaultToLimit);
    });
  }
  /**
    * start looking for the previous breakpoint
    * @param {Bool} defaultToLimit - if true jump to the start of the trace if no more breakpoint found
    *
    */


  jumpPreviousBreakpoint(fromStep, defaultToLimit) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      this.jump(fromStep || 0, -1, defaultToLimit);
    });
  }
  /**
   * start looking for the previous or next breakpoint
   * @param {Int} direction - 1 or -1 direction of the search
   * @param {Bool} defaultToLimit - if true jump to the limit (end if direction is 1, beginning if direction is -1) of the trace if no more breakpoint found
   *
   */


  jump(fromStep, direction, defaultToLimit) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.locationToRowConverter) {
        console.log('row converter not provided');
        return;
      }

      function depthChange(step, trace) {
        return trace[step].depth !== trace[step - 1].depth;
      }

      function hitLine(currentStep, sourceLocation, previousSourceLocation, self) {
        // isJumpDestInstruction -> returning from a internal function call
        // depthChange -> returning from an external call
        // sourceLocation.start <= previousSourceLocation.start && ... -> previous src is contained in the current one
        if (helper.isJumpDestInstruction(self.debugger.traceManager.trace[currentStep]) && previousSourceLocation.jump === 'o' || depthChange(currentStep, self.debugger.traceManager.trace) || sourceLocation.start <= previousSourceLocation.start && sourceLocation.start + sourceLocation.length >= previousSourceLocation.start + previousSourceLocation.length) {
          return false;
        } else {
          self.jumpToCallback(currentStep);
          self.event.trigger('breakpointHit', [sourceLocation, currentStep]);
          return true;
        }
      }

      let sourceLocation;
      let previousSourceLocation;
      let currentStep = fromStep + direction;
      let lineHadBreakpoint = false;

      while (currentStep > 0 && currentStep < this.debugger.traceManager.trace.length) {
        try {
          previousSourceLocation = sourceLocation;
          sourceLocation = yield this.debugger.callTree.extractSourceLocation(currentStep);
        } catch (e) {
          console.log('cannot jump to breakpoint ' + e);
          return;
        }

        let lineColumn = yield this.locationToRowConverter(sourceLocation);

        if (this.previousLine !== lineColumn.start.line) {
          if (direction === -1 && lineHadBreakpoint) {
            // TODO : improve this when we will build the correct structure before hand
            lineHadBreakpoint = false;

            if (hitLine(currentStep + 1, previousSourceLocation, sourceLocation, this)) {
              return;
            }
          }

          this.previousLine = lineColumn.start.line;

          if (this.hasBreakpointAtLine(sourceLocation.file, lineColumn.start.line)) {
            lineHadBreakpoint = true;

            if (direction === 1) {
              if (hitLine(currentStep, sourceLocation, previousSourceLocation, this)) {
                return;
              }
            }
          }
        }

        currentStep += direction;
      }

      this.event.trigger('NoBreakpointHit', []);

      if (defaultToLimit) {
        if (direction === -1) {
          this.jumpToCallback(0);
        } else if (direction === 1) {
          this.jumpToCallback(this.debugger.traceManager.trace.length - 1);
        }
      }
    });
  }
  /**
    * check the given pair fileIndex/line against registered breakpoints
    *
    * @param {Int} fileIndex - index of the file content (from the compilation result)
    * @param {Int} line - line number where looking for breakpoint
    * @return {Bool} return true if the given @arg fileIndex @arg line refers to a breakpoint
    */


  hasBreakpointAtLine(fileIndex, line) {
    const filename = this.debugger.solidityProxy.fileNameFromIndex(fileIndex);

    if (filename && this.breakpoints[filename]) {
      const sources = this.breakpoints[filename];

      for (let k in sources) {
        const source = sources[k];

        if (line === source.row) {
          return true;
        }
      }
    }

    return false;
  }
  /**
    * return true if current manager has breakpoint
    *
    * @return {Bool} true if breapoint registered
    */


  hasBreakpoint() {
    for (let k in this.breakpoints) {
      if (this.breakpoints[k].length) {
        return true;
      }
    }

    return false;
  }
  /**
    * add a new breakpoint to the manager
    *
    * @param {Object} sourceLocation - position of the breakpoint { file: '<file index>', row: '<line number' }
    */


  add(sourceLocation) {
    if (!this.breakpoints[sourceLocation.fileName]) {
      this.breakpoints[sourceLocation.fileName] = [];
    }

    this.breakpoints[sourceLocation.fileName].push(sourceLocation);
    this.event.trigger('breakpointAdded', [sourceLocation]);
  }
  /**
    * remove a breakpoint from the manager
    *
    * @param {Object} sourceLocation - position of the breakpoint { file: '<file index>', row: '<line number' }
    */


  remove(sourceLocation) {
    if (this.breakpoints[sourceLocation.fileName]) {
      var sources = this.breakpoints[sourceLocation.fileName];

      for (let k in sources) {
        const source = sources[k];

        if (sourceLocation.row === source.row) {
          sources.splice(k, 1);
          this.event.trigger('breakpointRemoved', [sourceLocation]);
          break;
        }
      }
    }
  }

}

module.exports = BreakpointManager;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/code/codeManager.js":
/*!********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/code/codeManager.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventManager = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

const traceHelper = __webpack_require__(/*! ../helpers/traceHelper */ "../../../dist/libs/remix-lib/src/helpers/traceHelper.js");

const SourceMappingDecoder = __webpack_require__(/*! ../sourceMappingDecoder */ "../../../dist/libs/remix-lib/src/sourceMappingDecoder.js");

const CodeResolver = __webpack_require__(/*! ./codeResolver */ "../../../dist/libs/remix-lib/src/code/codeResolver.js");
/*
  resolve contract code referenced by vmtrace in order to be used by asm listview.
  events:
   - changed: triggered when an item is selected
   - resolvingStep: when CodeManager resolves code/selected instruction of a new step
*/


function CodeManager(_traceManager) {
  this.event = new EventManager();
  this.isLoading = false;
  this.traceManager = _traceManager;
  this.codeResolver = new CodeResolver({
    web3: this.traceManager.web3
  });
}
/**
 * clear the cache
 *
 */


CodeManager.prototype.clear = function () {
  this.codeResolver.clear();
};
/**
 * resolve the code of the given @arg stepIndex and trigger appropriate event
 *
 * @param {String} stepIndex - vm trace step
 * @param {Object} tx - transaction (given by web3)
 */


CodeManager.prototype.resolveStep = function (stepIndex, tx) {
  if (stepIndex < 0) return;
  this.event.trigger('resolvingStep');

  if (stepIndex === 0) {
    retrieveCodeAndTrigger(this, tx.to, stepIndex, tx);
  } else {
    this.traceManager.getCurrentCalledAddressAt(stepIndex, (error, address) => {
      if (error) {
        console.log(error);
      } else {
        retrieveCodeAndTrigger(this, address, stepIndex, tx);
      }
    });
  }
};
/**
 * Retrieve the code located at the given @arg address
 *
 * @param {String} address - address of the contract to get the code from
 * @param {Function} cb - callback function, return the bytecode
 */


CodeManager.prototype.getCode = function (address, cb) {
  if (traceHelper.isContractCreation(address)) {
    var codes = this.codeResolver.getExecutingCodeFromCache(address);

    if (!codes) {
      this.traceManager.getContractCreationCode(address, (error, hexCode) => {
        if (!error) {
          codes = this.codeResolver.cacheExecutingCode(address, hexCode);
          cb(null, codes);
        }
      });
    } else {
      cb(null, codes);
    }
  } else {
    this.codeResolver.resolveCode(address, (address, code) => {
      cb(null, code);
    });
  }
};
/**
 * Retrieve the called function for the current vm step for the given @arg address
 *
 * @param {String} stepIndex - vm trace step
 * @param {String} sourceMap - source map given byt the compilation result
 * @param {Object} ast - ast given by the compilation result
 * @return {Object} return the ast node of the function
 */


CodeManager.prototype.getFunctionFromStep = function (stepIndex, sourceMap, ast) {
  this.traceManager.getCurrentCalledAddressAt(stepIndex, (error, address) => {
    if (error) {
      console.log(error);
      return {
        error: 'Cannot retrieve current address for ' + stepIndex
      };
    } else {
      this.traceManager.getCurrentPC(stepIndex, (error, pc) => {
        if (error) {
          console.log(error);
          return {
            error: 'Cannot retrieve current PC for ' + stepIndex
          };
        } else {
          return this.getFunctionFromPC(address, pc, sourceMap, ast);
        }
      });
    }
  });
};
/**
 * Retrieve the instruction index of the given @arg step
 *
 * @param {String} address - address of the current context
 * @param {String} step - vm trace step
 * @param {Function} callback - instruction index
 */


CodeManager.prototype.getInstructionIndex = function (address, step, callback) {
  this.traceManager.getCurrentPC(step, (error, pc) => {
    if (error) {
      console.log(error);
      callback('Cannot retrieve current PC for ' + step, null);
    } else {
      const itemIndex = this.codeResolver.getInstructionIndex(address, pc);
      callback(null, itemIndex);
    }
  });
};
/**
 * Retrieve the called function for the given @arg pc and @arg address
 *
 * @param {String} address - address of the current context (used to resolve instruction index)
 * @param {String} pc - pc that point to the instruction index
 * @param {String} sourceMap - source map given byt the compilation result
 * @param {Object} ast - ast given by the compilation result
 * @return {Object} return the ast node of the function
 */


CodeManager.prototype.getFunctionFromPC = function (address, pc, sourceMap, ast) {
  const instIndex = this.codeResolver.getInstructionIndex(address, pc);
  return SourceMappingDecoder.findNodeAtInstructionIndex('FunctionDefinition', instIndex, sourceMap, ast);
};

function retrieveCodeAndTrigger(codeMananger, address, stepIndex, tx) {
  codeMananger.getCode(address, (error, result) => {
    if (!error) {
      retrieveIndexAndTrigger(codeMananger, address, stepIndex, result.instructions);
    } else {
      console.log(error);
    }
  });
}

function retrieveIndexAndTrigger(codeMananger, address, step, code) {
  codeMananger.getInstructionIndex(address, step, (error, result) => {
    if (!error) {
      codeMananger.event.trigger('changed', [code, address, result]);
    } else {
      console.log(error);
    }
  });
}

module.exports = CodeManager;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/code/codeResolver.js":
/*!*********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/code/codeResolver.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const codeUtils = __webpack_require__(/*! ./codeUtils */ "../../../dist/libs/remix-lib/src/code/codeUtils.js");

function CodeResolver(options) {
  this.web3 = options.web3;
  this.bytecodeByAddress = {}; // bytes code by contract addesses

  this.instructionsByAddress = {}; // assembly items instructions list by contract addesses

  this.instructionsIndexByBytesOffset = {}; // mapping between bytes offset and instructions index.
}

CodeResolver.prototype.clear = function () {
  this.bytecodeByAddress = {};
  this.instructionsByAddress = {};
  this.instructionsIndexByBytesOffset = {};
};

CodeResolver.prototype.resolveCode = function (address, callBack) {
  const cache = this.getExecutingCodeFromCache(address);

  if (cache) {
    return callBack(address, cache);
  }

  this.loadCode(address, code => {
    callBack(address, this.cacheExecutingCode(address, code));
  });
};

CodeResolver.prototype.loadCode = function (address, callback) {
  this.web3.eth.getCode(address, (error, result) => {
    if (error) {
      console.log(error);
    } else {
      callback(result);
    }
  });
};

CodeResolver.prototype.cacheExecutingCode = function (address, hexCode) {
  const codes = this.formatCode(hexCode);
  this.bytecodeByAddress[address] = hexCode;
  this.instructionsByAddress[address] = codes.code;
  this.instructionsIndexByBytesOffset[address] = codes.instructionsIndexByBytesOffset;
  return this.getExecutingCodeFromCache(address);
};

CodeResolver.prototype.formatCode = function (hexCode) {
  const code = codeUtils.nameOpCodes(Buffer.from(hexCode.substring(2), 'hex'));
  return {
    code: code[0],
    instructionsIndexByBytesOffset: code[1]
  };
};

CodeResolver.prototype.getExecutingCodeFromCache = function (address) {
  if (this.instructionsByAddress[address]) {
    return {
      instructions: this.instructionsByAddress[address],
      instructionsIndexByBytesOffset: this.instructionsIndexByBytesOffset[address],
      bytecode: this.bytecodeByAddress[address]
    };
  }

  return null;
};

CodeResolver.prototype.getInstructionIndex = function (address, pc) {
  return this.getExecutingCodeFromCache(address).instructionsIndexByBytesOffset[pc];
};

module.exports = CodeResolver;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/code/codeUtils.js":
/*!******************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/code/codeUtils.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const opcodes = __webpack_require__(/*! ./opcodes */ "../../../dist/libs/remix-lib/src/code/opcodes.js");

module.exports = {
  nameOpCodes: function (raw) {
    let pushData = '';
    const codeMap = {};
    const code = [];

    for (let i = 0; i < raw.length; i++) {
      const pc = i;
      const curOpCode = opcodes(raw[pc], false).name;
      codeMap[i] = code.length; // no destinations into the middle of PUSH

      if (curOpCode.slice(0, 4) === 'PUSH') {
        const jumpNum = raw[pc] - 0x5f;
        pushData = raw.slice(pc + 1, pc + jumpNum + 1);
        i += jumpNum;
      }

      const data = pushData.toString('hex') !== '' ? ' ' + pushData.toString('hex') : '';
      code.push(this.pad(pc, this.roundLog(raw.length, 10)) + ' ' + curOpCode + data);
      pushData = '';
    }

    return [code, codeMap];
  },

  /**
   * Parses code as a list of integers into a list of objects containing
   * information about the opcode.
   */
  parseCode: function (raw) {
    const code = [];

    for (let i = 0; i < raw.length; i++) {
      const opcode = opcodes(raw[i], true);

      if (opcode.name.slice(0, 4) === 'PUSH') {
        const length = raw[i] - 0x5f;
        opcode.pushData = raw.slice(i + 1, i + length + 1); // in case pushdata extends beyond code

        if (i + 1 + length > raw.length) {
          for (let j = opcode.pushData.length; j < length; j++) {
            opcode.pushData.push(0);
          }
        }

        i += length;
      }

      code.push(opcode);
    }

    return code;
  },
  pad: function (num, size) {
    let s = num + '';

    while (s.length < size) s = '0' + s;

    return s;
  },
  log: function (num, base) {
    return Math.log(num) / Math.log(base);
  },
  roundLog: function (num, base) {
    return Math.ceil(this.log(num, base));
  }
};

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/code/opcodes.js":
/*!****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/code/opcodes.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const codes = {
  // 0x0 range - arithmetic ops
  // name, baseCost, off stack, on stack, dynamic, async
  // @todo can be improved on basis of this: https://github.com/ethereumjs/ethereumjs-vm/blob/master/lib/evm/opcodes.ts
  0x00: ['STOP', 0, 0, 0, false],
  0x01: ['ADD', 3, 2, 1, false],
  0x02: ['MUL', 5, 2, 1, false],
  0x03: ['SUB', 3, 2, 1, false],
  0x04: ['DIV', 5, 2, 1, false],
  0x05: ['SDIV', 5, 2, 1, false],
  0x06: ['MOD', 5, 2, 1, false],
  0x07: ['SMOD', 5, 2, 1, false],
  0x08: ['ADDMOD', 8, 3, 1, false],
  0x09: ['MULMOD', 8, 3, 1, false],
  0x0a: ['EXP', 10, 2, 1, false],
  0x0b: ['SIGNEXTEND', 5, 2, 1, false],
  // 0x10 range - bit ops
  0x10: ['LT', 3, 2, 1, false],
  0x11: ['GT', 3, 2, 1, false],
  0x12: ['SLT', 3, 2, 1, false],
  0x13: ['SGT', 3, 2, 1, false],
  0x14: ['EQ', 3, 2, 1, false],
  0x15: ['ISZERO', 3, 1, 1, false],
  0x16: ['AND', 3, 2, 1, false],
  0x17: ['OR', 3, 2, 1, false],
  0x18: ['XOR', 3, 2, 1, false],
  0x19: ['NOT', 3, 1, 1, false],
  0x1a: ['BYTE', 3, 2, 1, false],
  0x1b: ['SHL', 3, 2, 1, false],
  0x1c: ['SHR', 3, 2, 1, false],
  0x1d: ['SAR', 3, 2, 1, false],
  // 0x20 range - crypto
  0x20: ['SHA3', 30, 2, 1, false],
  // 0x30 range - closure state
  0x30: ['ADDRESS', 2, 0, 1, true],
  0x31: ['BALANCE', 700, 1, 1, true, true],
  0x32: ['ORIGIN', 2, 0, 1, true],
  0x33: ['CALLER', 2, 0, 1, true],
  0x34: ['CALLVALUE', 2, 0, 1, true],
  0x35: ['CALLDATALOAD', 3, 1, 1, true],
  0x36: ['CALLDATASIZE', 2, 0, 1, true],
  0x37: ['CALLDATACOPY', 3, 3, 0, true],
  0x38: ['CODESIZE', 2, 0, 1, false],
  0x39: ['CODECOPY', 3, 3, 0, false],
  0x3a: ['GASPRICE', 2, 0, 1, false],
  0x3b: ['EXTCODESIZE', 700, 1, 1, true, true],
  0x3c: ['EXTCODECOPY', 700, 4, 0, true, true],
  0x3d: ['RETURNDATASIZE', 2, 0, 1, true],
  0x3e: ['RETURNDATACOPY', 3, 3, 0, true],
  0x3f: ['EXTCODEHASH', 400, 3, 0, true],
  // '0x40' range - block operations
  0x40: ['BLOCKHASH', 20, 1, 1, true, true],
  0x41: ['COINBASE', 2, 0, 1, true],
  0x42: ['TIMESTAMP', 2, 0, 1, true],
  0x43: ['NUMBER', 2, 0, 1, true],
  0x44: ['DIFFICULTY', 2, 0, 1, true],
  0x45: ['GASLIMIT', 2, 0, 1, true],
  0x46: ['CHAINID', 2, 0, 1, false],
  0x47: ['SELFBALANCE', 5, 0, 1, false],
  // 0x50 range - 'storage' and execution
  0x50: ['POP', 2, 1, 0, false],
  0x51: ['MLOAD', 3, 1, 1, false],
  0x52: ['MSTORE', 3, 2, 0, false],
  0x53: ['MSTORE8', 3, 2, 0, false],
  0x54: ['SLOAD', 800, 1, 1, true, true],
  0x55: ['SSTORE', 0, 2, 0, true, true],
  0x56: ['JUMP', 8, 1, 0, false],
  0x57: ['JUMPI', 10, 2, 0, false],
  0x58: ['PC', 2, 0, 1, false],
  0x59: ['MSIZE', 2, 0, 1, false],
  0x5a: ['GAS', 2, 0, 1, false],
  0x5b: ['JUMPDEST', 1, 0, 0, false],
  // 0x60, range
  0x60: ['PUSH1', 3, 0, 1, false],
  0x61: ['PUSH2', 3, 0, 1, false],
  0x62: ['PUSH3', 3, 0, 1, false],
  0x63: ['PUSH4', 3, 0, 1, false],
  0x64: ['PUSH5', 3, 0, 1, false],
  0x65: ['PUSH6', 3, 0, 1, false],
  0x66: ['PUSH7', 3, 0, 1, false],
  0x67: ['PUSH8', 3, 0, 1, false],
  0x68: ['PUSH9', 3, 0, 1, false],
  0x69: ['PUSH10', 3, 0, 1, false],
  0x6a: ['PUSH11', 3, 0, 1, false],
  0x6b: ['PUSH12', 3, 0, 1, false],
  0x6c: ['PUSH13', 3, 0, 1, false],
  0x6d: ['PUSH14', 3, 0, 1, false],
  0x6e: ['PUSH15', 3, 0, 1, false],
  0x6f: ['PUSH16', 3, 0, 1, false],
  0x70: ['PUSH17', 3, 0, 1, false],
  0x71: ['PUSH18', 3, 0, 1, false],
  0x72: ['PUSH19', 3, 0, 1, false],
  0x73: ['PUSH20', 3, 0, 1, false],
  0x74: ['PUSH21', 3, 0, 1, false],
  0x75: ['PUSH22', 3, 0, 1, false],
  0x76: ['PUSH23', 3, 0, 1, false],
  0x77: ['PUSH24', 3, 0, 1, false],
  0x78: ['PUSH25', 3, 0, 1, false],
  0x79: ['PUSH26', 3, 0, 1, false],
  0x7a: ['PUSH27', 3, 0, 1, false],
  0x7b: ['PUSH28', 3, 0, 1, false],
  0x7c: ['PUSH29', 3, 0, 1, false],
  0x7d: ['PUSH30', 3, 0, 1, false],
  0x7e: ['PUSH31', 3, 0, 1, false],
  0x7f: ['PUSH32', 3, 0, 1, false],
  0x80: ['DUP1', 3, 0, 1, false],
  0x81: ['DUP2', 3, 0, 1, false],
  0x82: ['DUP3', 3, 0, 1, false],
  0x83: ['DUP4', 3, 0, 1, false],
  0x84: ['DUP5', 3, 0, 1, false],
  0x85: ['DUP6', 3, 0, 1, false],
  0x86: ['DUP7', 3, 0, 1, false],
  0x87: ['DUP8', 3, 0, 1, false],
  0x88: ['DUP9', 3, 0, 1, false],
  0x89: ['DUP10', 3, 0, 1, false],
  0x8a: ['DUP11', 3, 0, 1, false],
  0x8b: ['DUP12', 3, 0, 1, false],
  0x8c: ['DUP13', 3, 0, 1, false],
  0x8d: ['DUP14', 3, 0, 1, false],
  0x8e: ['DUP15', 3, 0, 1, false],
  0x8f: ['DUP16', 3, 0, 1, false],
  0x90: ['SWAP1', 3, 0, 0, false],
  0x91: ['SWAP2', 3, 0, 0, false],
  0x92: ['SWAP3', 3, 0, 0, false],
  0x93: ['SWAP4', 3, 0, 0, false],
  0x94: ['SWAP5', 3, 0, 0, false],
  0x95: ['SWAP6', 3, 0, 0, false],
  0x96: ['SWAP7', 3, 0, 0, false],
  0x97: ['SWAP8', 3, 0, 0, false],
  0x98: ['SWAP9', 3, 0, 0, false],
  0x99: ['SWAP10', 3, 0, 0, false],
  0x9a: ['SWAP11', 3, 0, 0, false],
  0x9b: ['SWAP12', 3, 0, 0, false],
  0x9c: ['SWAP13', 3, 0, 0, false],
  0x9d: ['SWAP14', 3, 0, 0, false],
  0x9e: ['SWAP15', 3, 0, 0, false],
  0x9f: ['SWAP16', 3, 0, 0, false],
  0xa0: ['LOG0', 375, 2, 0, false],
  0xa1: ['LOG1', 375, 3, 0, false],
  0xa2: ['LOG2', 375, 4, 0, false],
  0xa3: ['LOG3', 375, 5, 0, false],
  0xa4: ['LOG4', 375, 6, 0, false],
  // '0xf0' range - closures
  0xf0: ['CREATE', 32000, 3, 1, true, true],
  0xf1: ['CALL', 700, 7, 1, true, true],
  0xf2: ['CALLCODE', 700, 7, 1, true, true],
  0xf3: ['RETURN', 0, 2, 0, false],
  0xf4: ['DELEGATECALL', 700, 6, 1, true, true],
  0xf5: ['CREATE2', 32000, 4, 1, true, true],
  0xfa: ['STATICCALL', 700, 6, 1, true, true],
  0xfd: ['REVERT', 0, 2, 0, false],
  // '0x70', range - other
  0xfe: ['INVALID', 0, 0, 0, false],
  0xff: ['SELFDESTRUCT', 5000, 1, 0, false, true]
};

module.exports = function (op, full) {
  const code = codes[op] ? codes[op] : ['INVALID', 0, 0, 0, false, false];
  let opcode = code[0];

  if (full) {
    if (opcode === 'LOG') {
      opcode += op - 0xa0;
    }

    if (opcode === 'PUSH') {
      opcode += op - 0x5f;
    }

    if (opcode === 'DUP') {
      opcode += op - 0x7f;
    }

    if (opcode === 'SWAP') {
      opcode += op - 0x8f;
    }
  }

  return {
    name: opcode,
    fee: code[1],
    in: code[2],
    out: code[3],
    dynamic: code[4],
    async: code[5]
  };
};

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/eventManager.js":
/*!****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/eventManager.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function eventManager() {
  this.registered = {};
  this.anonymous = {};
}
/*
   * Unregister a listener.
   * Note that if obj is a function. the unregistration will be applied to the dummy obj {}.
   *
   * @param {String} eventName  - the event name
   * @param {Object or Func} obj - object that will listen on this event
   * @param {Func} func         - function of the listeners that will be executed
*/


eventManager.prototype.unregister = function (eventName, obj, func) {
  if (!this.registered[eventName]) {
    return;
  }

  if (obj instanceof Function) {
    func = obj;
    obj = this.anonymous;
  }

  for (let reg in this.registered[eventName]) {
    if (this.registered[eventName][reg].obj === obj && this.registered[eventName][reg].func === func) {
      this.registered[eventName].splice(reg, 1);
    }
  }
};
/*
   * Register a new listener.
   * Note that if obj is a function, the function registration will be associated with the dummy object {}
   *
   * @param {String} eventName  - the event name
   * @param {Object or Func} obj - object that will listen on this event
   * @param {Func} func         - function of the listeners that will be executed
*/


eventManager.prototype.register = function (eventName, obj, func) {
  if (!this.registered[eventName]) {
    this.registered[eventName] = [];
  }

  if (obj instanceof Function) {
    func = obj;
    obj = this.anonymous;
  }

  this.registered[eventName].push({
    obj: obj,
    func: func
  });
};
/*
   * trigger event.
   * Every listener have their associated function executed
   *
   * @param {String} eventName  - the event name
   * @param {Array}j - argument that will be passed to the executed function.
*/


eventManager.prototype.trigger = function (eventName, args) {
  if (!this.registered[eventName]) {
    return;
  }

  for (let listener in this.registered[eventName]) {
    const l = this.registered[eventName][listener];
    l.func.apply(l.obj === this.anonymous ? {} : l.obj, args);
  }
};

module.exports = eventManager;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/eventsDecoder.js":
/*!***************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/eventsDecoder.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ethers = __webpack_require__(/*! ethers */ "../../../node_modules/ethers/dist/ethers.min.js");

const txHelper = __webpack_require__(/*! ./txHelper */ "../../../dist/libs/remix-lib/src/execution/txHelper.js");
/**
  * Register to txListener and extract events
  *
  */


class EventsDecoder {
  constructor(opt = {}) {
    this._api = opt.api;
  }
  /**
    * use Transaction Receipt to decode logs. assume that the transaction as already been resolved by txListener.
    * logs are decoded only if the contract if known by remix.
    *
    * @param {Object} tx - transaction object
    * @param {Function} cb - callback
    */


  parseLogs(tx, contractName, compiledContracts, cb) {
    if (tx.isCall) return cb(null, {
      decoded: [],
      raw: []
    });

    this._api.resolveReceipt(tx, (error, receipt) => {
      if (error) return cb(error);

      this._decodeLogs(tx, receipt, contractName, compiledContracts, cb);
    });
  }

  _decodeLogs(tx, receipt, contract, contracts, cb) {
    if (!contract || !receipt) {
      return cb('cannot decode logs - contract or receipt not resolved ');
    }

    if (!receipt.logs) {
      return cb(null, {
        decoded: [],
        raw: []
      });
    }

    this._decodeEvents(tx, receipt.logs, contract, contracts, cb);
  }

  _eventABI(contract) {
    const eventABI = {};
    const abi = new ethers.utils.Interface(contract.abi);

    for (let e in abi.events) {
      const event = abi.events[e];
      eventABI[event.topic.replace('0x', '')] = {
        event: event.name,
        inputs: event.inputs,
        object: event,
        abi: abi
      };
    }

    return eventABI;
  }

  _eventsABI(compiledContracts) {
    const eventsABI = {};
    txHelper.visitContracts(compiledContracts, contract => {
      eventsABI[contract.name] = this._eventABI(contract.object);
    });
    return eventsABI;
  }

  _event(hash, eventsABI) {
    for (let k in eventsABI) {
      if (eventsABI[k][hash]) {
        return eventsABI[k][hash];
      }
    }

    return null;
  }

  _stringifyBigNumber(value) {
    return value._ethersType === 'BigNumber' ? value.toString() : value;
  }

  _stringifyEvent(value) {
    if (value === null || value === undefined) return ' - ';
    if (value._ethersType) value.type = value._ethersType;

    if (Array.isArray(value)) {
      // for struct && array
      return value.map(item => {
        return this._stringifyEvent(item);
      });
    } else {
      return this._stringifyBigNumber(value);
    }
  }

  _decodeEvents(tx, logs, contractName, compiledContracts, cb) {
    const eventsABI = this._eventsABI(compiledContracts);

    const events = [];

    for (let i in logs) {
      // [address, topics, mem]
      const log = logs[i];
      const topicId = log.topics[0];

      const eventAbi = this._event(topicId.replace('0x', ''), eventsABI);

      if (eventAbi) {
        const decodedlog = eventAbi.abi.parseLog(log);
        const decoded = {};

        for (const v in decodedlog.values) {
          decoded[v] = this._stringifyEvent(decodedlog.values[v]);
        }

        events.push({
          from: log.address,
          topic: topicId,
          event: eventAbi.event,
          args: decoded
        });
      } else {
        events.push({
          from: log.address,
          data: log.data,
          topics: log.topics
        });
      }
    }

    cb(null, {
      decoded: events,
      raw: logs
    });
  }

}

module.exports = EventsDecoder;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/execution-context.js":
/*!*******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/execution-context.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global ethereum */


const Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

const EventManager = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

const EthJSVM = __webpack_require__(/*! ethereumjs-vm */ "../../../node_modules/ethereumjs-vm/dist/index.js").default;

const ethUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const StateManager = __webpack_require__(/*! ethereumjs-vm/dist/state/stateManager */ "../../../node_modules/ethereumjs-vm/dist/state/stateManager.js").default;

const Web3VMProvider = __webpack_require__(/*! ../web3Provider/web3VmProvider */ "../../../dist/libs/remix-lib/src/web3Provider/web3VmProvider.js");

const LogsManager = __webpack_require__(/*! ./logsManager.js */ "../../../dist/libs/remix-lib/src/execution/logsManager.js");

const rlp = ethUtil.rlp;
let web3;

if (typeof window !== 'undefined' && typeof window.web3 !== 'undefined') {
  var injectedProvider = window.web3.currentProvider;
  web3 = new Web3(injectedProvider);
} else {
  web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'));
}

const blankWeb3 = new Web3();
const currentFork = 'muirGlacier';
/*
  extend vm state manager and instanciate VM
*/

class StateManagerCommonStorageDump extends StateManager {
  constructor(arg) {
    super(arg);
    this.keyHashes = {};
  }

  putContractStorage(address, key, value, cb) {
    this.keyHashes[ethUtil.keccak(key).toString('hex')] = ethUtil.bufferToHex(key);
    super.putContractStorage(address, key, value, cb);
  }

  dumpStorage(address, cb) {
    this._getStorageTrie(address, (err, trie) => {
      if (err) {
        return cb(err);
      }

      const storage = {};
      const stream = trie.createReadStream();
      stream.on('data', val => {
        const value = rlp.decode(val.value);
        storage['0x' + val.key.toString('hex')] = {
          key: this.keyHashes[val.key.toString('hex')],
          value: '0x' + value.toString('hex')
        };
      });
      stream.on('end', function () {
        cb(storage);
      });
    });
  }

  getStateRoot(cb) {
    const checkpoint = this._checkpointCount;
    this._checkpointCount = 0;
    super.getStateRoot((err, stateRoot) => {
      this._checkpointCount = checkpoint;
      cb(err, stateRoot);
    });
  }

  setStateRoot(stateRoot, cb) {
    let checkpoint = this._checkpointCount;
    this._checkpointCount = 0;
    super.setStateRoot(stateRoot, err => {
      this._checkpointCount = checkpoint;
      cb(err);
    });
  }

}

function createVm(hardfork) {
  const stateManager = new StateManagerCommonStorageDump({});
  stateManager.checkpoint(() => {});
  const vm = new EthJSVM({
    activatePrecompiles: true,
    blockchain: stateManager.blockchain,
    stateManager: stateManager,
    hardfork: hardfork
  });
  vm.blockchain.validate = false;
  const web3vm = new Web3VMProvider();
  web3vm.setVM(vm);
  return {
    vm,
    web3vm,
    stateManager
  };
}

const vms = {
  byzantium: createVm('byzantium'),
  constantinople: createVm('constantinople'),
  petersburg: createVm('petersburg'),
  istanbul: createVm('istanbul'),
  muirGlacier: createVm('muirGlacier')
};
const mainNetGenesisHash = '0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3';
/*
  trigger contextChanged, web3EndpointChanged
*/

function ExecutionContext() {
  this.event = new EventManager();
  this.logsManager = new LogsManager();
  let executionContext = null;
  this.blockGasLimitDefault = 4300000;
  this.blockGasLimit = this.blockGasLimitDefault;
  this.customNetWorks = {};
  this.blocks = {};
  this.latestBlockNumber = 0;
  this.txs = {};

  this.init = function (config) {
    if (config.get('settings/always-use-vm')) {
      executionContext = 'vm';
    } else {
      executionContext = injectedProvider ? 'injected' : 'vm';
      if (executionContext === 'injected') this.askPermission();
    }
  };

  this.askPermission = function () {
    // metamask
    if (ethereum && typeof ethereum.enable === 'function') ethereum.enable();
  };

  this.getProvider = function () {
    return executionContext;
  };

  this.isVM = function () {
    return executionContext === 'vm';
  };

  this.web3 = function () {
    return this.isVM() ? vms[currentFork].web3vm : web3;
  };

  this.detectNetwork = function (callback) {
    if (this.isVM()) {
      callback(null, {
        id: '-',
        name: 'VM'
      });
    } else {
      web3.eth.net.getId((err, id) => {
        let name = null;
        if (err) name = 'Unknown'; // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md
        else if (id === 1) name = 'Main';else if (id === 2) name = 'Morden (deprecated)';else if (id === 3) name = 'Ropsten';else if (id === 4) name = 'Rinkeby';else if (id === 5) name = 'Goerli';else if (id === 42) name = 'Kovan';else name = 'Custom';

        if (id === '1') {
          web3.eth.getBlock(0, (error, block) => {
            if (error) console.log('cant query first block');
            if (block && block.hash !== mainNetGenesisHash) name = 'Custom';
            callback(err, {
              id,
              name
            });
          });
        } else {
          callback(err, {
            id,
            name
          });
        }
      });
    }
  };

  this.removeProvider = name => {
    if (name && this.customNetWorks[name]) {
      delete this.customNetWorks[name];
      this.event.trigger('removeProvider', [name]);
    }
  };

  this.addProvider = network => {
    if (network && network.name && network.url) {
      this.customNetWorks[network.name] = network;
      this.event.trigger('addProvider', [network]);
    }
  };

  this.internalWeb3 = () => {
    return web3;
  };

  this.blankWeb3 = () => {
    return blankWeb3;
  };

  this.vm = () => {
    return vms[currentFork].vm;
  };

  this.setContext = (context, endPointUrl, confirmCb, infoCb) => {
    executionContext = context;
    this.executionContextChange(context, endPointUrl, confirmCb, infoCb);
  };

  this.executionContextChange = (context, endPointUrl, confirmCb, infoCb, cb) => {
    if (!cb) cb = () => {};

    if (context === 'vm') {
      executionContext = context;
      vms[currentFork].stateManager.revert(() => {
        vms[currentFork].stateManager.checkpoint(() => {});
      });
      this.event.trigger('contextChanged', ['vm']);
      return cb();
    }

    if (context === 'injected') {
      if (injectedProvider === undefined) {
        infoCb('No injected Web3 provider found. Make sure your provider (e.g. MetaMask) is active and running (when recently activated you may have to reload the page).');
        return cb();
      } else {
        this.askPermission();
        executionContext = context;
        web3.setProvider(injectedProvider);

        this._updateBlockGasLimit();

        this.event.trigger('contextChanged', ['injected']);
        return cb();
      }
    }

    if (context === 'web3') {
      confirmCb(cb);
    }

    if (this.customNetWorks[context]) {
      var provider = this.customNetWorks[context];
      setProviderFromEndpoint(provider.url, 'web3', () => {
        cb();
      });
    }
  };

  this.currentblockGasLimit = () => {
    return this.blockGasLimit;
  };

  this.stopListenOnLastBlock = () => {
    if (this.listenOnLastBlockId) clearInterval(this.listenOnLastBlockId);
    this.listenOnLastBlockId = null;
  };

  this._updateBlockGasLimit = () => {
    if (this.getProvider() !== 'vm') {
      web3.eth.getBlock('latest', (err, block) => {
        if (!err) {
          // we can't use the blockGasLimit cause the next blocks could have a lower limit : https://github.com/ethereum/remix/issues/506
          this.blockGasLimit = block && block.gasLimit ? Math.floor(block.gasLimit - 5 * block.gasLimit / 1024) : this.blockGasLimitDefault;
        } else {
          this.blockGasLimit = this.blockGasLimitDefault;
        }
      });
    }
  };

  this.listenOnLastBlock = () => {
    this.listenOnLastBlockId = setInterval(() => {
      this._updateBlockGasLimit();
    }, 15000);
  }; // TODO: remove this when this function is moved


  const self = this; // TODO: not used here anymore and needs to be moved

  function setProviderFromEndpoint(endpoint, context, cb) {
    const oldProvider = web3.currentProvider;

    if (endpoint === 'ipc') {
      web3.setProvider(new web3.providers.IpcProvider());
    } else {
      web3.setProvider(new web3.providers.HttpProvider(endpoint));
    }

    web3.eth.net.isListening((err, isConnected) => {
      if (!err && isConnected) {
        executionContext = context;

        self._updateBlockGasLimit();

        self.event.trigger('contextChanged', ['web3']);
        self.event.trigger('web3EndpointChanged');
        cb();
      } else {
        web3.setProvider(oldProvider);
        cb('Not possible to connect to the Web3 provider. Make sure the provider is running and a connection is open (via IPC or RPC).');
      }
    });
  }

  this.setProviderFromEndpoint = setProviderFromEndpoint;

  this.txDetailsLink = (network, hash) => {
    if (transactionDetailsLinks[network]) {
      return transactionDetailsLinks[network] + hash;
    }
  };

  this.addBlock = block => {
    let blockNumber = '0x' + block.header.number.toString('hex');

    if (blockNumber === '0x') {
      blockNumber = '0x0';
    }

    blockNumber = web3.utils.toHex(web3.utils.toBN(blockNumber));
    this.blocks['0x' + block.hash().toString('hex')] = block;
    this.blocks[blockNumber] = block;
    this.latestBlockNumber = blockNumber;
    this.logsManager.checkBlock(blockNumber, block, this.web3());
  };

  this.trackTx = (tx, block) => {
    this.txs[tx] = block;
  };
}

const transactionDetailsLinks = {
  'Main': 'https://www.etherscan.io/tx/',
  'Rinkeby': 'https://rinkeby.etherscan.io/tx/',
  'Ropsten': 'https://ropsten.etherscan.io/tx/',
  'Kovan': 'https://kovan.etherscan.io/tx/',
  'Goerli': 'https://goerli.etherscan.io/tx/'
};
module.exports = ExecutionContext;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/logsManager.js":
/*!*************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/logsManager.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

const crypto = __webpack_require__(/*! crypto */ "../../../node_modules/crypto-browserify/index.js");

class LogsManager {
  constructor() {
    this.notificationCallbacks = [];
    this.subscriptions = {};
    this.filters = {};
    this.filterTracking = {};
    this.oldLogs = [];
  }

  checkBlock(blockNumber, block, web3) {
    async.eachOf(block.transactions, (tx, i, next) => {
      let txHash = '0x' + tx.hash().toString('hex');
      web3.eth.getTransactionReceipt(txHash, (_error, receipt) => {
        for (let log of receipt.logs) {
          this.oldLogs.push({
            type: 'block',
            blockNumber,
            block,
            tx,
            log,
            txNumber: i
          });
          let subscriptions = this.getSubscriptionsFor({
            type: 'block',
            blockNumber,
            block,
            tx,
            log
          });

          for (let subscriptionId of subscriptions) {
            let result = {
              'logIndex': '0x1',
              'blockNumber': blockNumber,
              'blockHash': '0x' + block.hash().toString('hex'),
              'transactionHash': '0x' + tx.hash().toString('hex'),
              'transactionIndex': '0x' + i.toString(16),
              // TODO: if it's a contract deploy, it should be that address instead
              'address': log.address,
              'data': log.data,
              'topics': log.topics
            };

            if (result.address === '0x') {
              delete result.address;
            }

            let response = {
              'jsonrpc': '2.0',
              'method': 'eth_subscription',
              params: {
                'result': result,
                'subscription': subscriptionId
              }
            };
            this.transmit(response);
          }
        }
      });
    }, _err => {});
  }

  eventMatchesFilter(changeEvent, queryType, queryFilter) {
    if (queryFilter.topics.filter(logTopic => changeEvent.log.topics.indexOf(logTopic) >= 0).length === 0) return false;

    if (queryType === 'logs') {
      if (queryFilter.address === '0x' + changeEvent.tx.to.toString('hex') && queryFilter.address === '0x' + changeEvent.tx.from.toString('hex')) {
        if (!queryFilter.toBlock) {
          return true;
        } else if (parseInt(queryFilter.toBlock) > parseInt(changeEvent.blockNumber)) {
          return true;
        }
      }
    }

    return false;
  }

  getSubscriptionsFor(changeEvent) {
    let matchedSubscriptions = [];

    for (let subscriptionId of Object.keys(this.subscriptions)) {
      const subscriptionParams = this.subscriptions[subscriptionId];
      const [queryType, queryFilter] = subscriptionParams;

      if (this.eventMatchesFilter(changeEvent, queryType, queryFilter || {
        topics: []
      })) {
        matchedSubscriptions.push(subscriptionId);
      }
    }

    return matchedSubscriptions;
  }

  getLogsForSubscription(subscriptionId) {
    const subscriptionParams = this.subscriptions[subscriptionId];
    const [_queryType, queryFilter] = subscriptionParams; // eslint-disable-line

    return this.getLogsFor(queryFilter);
  }

  transmit(result) {
    this.notificationCallbacks.forEach(callback => {
      if (result.params.result.raw) {
        result.params.result.data = result.params.result.raw.data;
        result.params.result.topics = result.params.result.raw.topics;
      }

      callback(result);
    });
  }

  addListener(_type, cb) {
    this.notificationCallbacks.push(cb);
  }

  subscribe(params) {
    let subscriptionId = '0x' + crypto.randomBytes(16).toString('hex');
    this.subscriptions[subscriptionId] = params;
    return subscriptionId;
  }

  unsubscribe(subscriptionId) {
    delete this.subscriptions[subscriptionId];
  }

  newFilter(filterType, params) {
    const filterId = '0x' + crypto.randomBytes(16).toString('hex');

    if (filterType === 'block' || filterType === 'pendingTransactions') {
      this.filters[filterId] = {
        filterType
      };
    }

    if (filterType === 'filter') {
      this.filters[filterId] = {
        filterType,
        params
      };
    }

    this.filterTracking[filterId] = {};
    return filterId;
  }

  uninstallFilter(filterId) {
    delete this.filters[filterId];
  }

  getLogsForFilter(filterId, logsOnly) {
    const {
      filterType,
      params
    } = this.filter[filterId];
    const tracking = this.filterTracking[filterId];

    if (logsOnly || filterType === 'filter') {
      return this.getLogsFor(params || {
        topics: []
      });
    }

    if (filterType === 'block') {
      let blocks = this.oldLogs.filter(x => x.type === 'block').filter(x => tracking.block === undefined || x.blockNumber >= tracking.block);
      tracking.block = blocks[blocks.length - 1];
      return blocks.map(block => '0x' + block.hash().toString('hex'));
    }

    if (filterType === 'pendingTransactions') {
      return [];
    }
  }

  getLogsFor(params) {
    let results = [];

    for (let log of this.oldLogs) {
      if (this.eventMatchesFilter(log, 'logs', params)) {
        results.push({
          'logIndex': '0x1',
          'blockNumber': log.blockNumber,
          'blockHash': '0x' + log.block.hash().toString('hex'),
          'transactionHash': '0x' + log.tx.hash().toString('hex'),
          'transactionIndex': '0x' + log.txNumber.toString(16),
          // TODO: if it's a contract deploy, it should be that address instead
          'address': log.log.address,
          'data': log.log.data,
          'topics': log.log.topics
        });
      }
    }

    return results;
  }

}

module.exports = LogsManager;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/txExecution.js":
/*!*************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/txExecution.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ethers = __webpack_require__(/*! ethers */ "../../../node_modules/ethers/dist/ethers.min.js");

module.exports = {
  /**
    * deploy the given contract
    *
    * @param {String} from    - sender address
    * @param {String} data    - data to send with the transaction ( return of txFormat.buildData(...) ).
    * @param {String} value    - decimal representation of value.
    * @param {String} gasLimit    - decimal representation of gas limit.
    * @param {Object} txRunner    - TxRunner.js instance
    * @param {Object} callbacks    - { confirmationCb, gasEstimationForceSend, promptCb }
    *     [validate transaction] confirmationCb (network, tx, gasEstimation, continueTxExecution, cancelCb)
    *     [transaction failed, force send] gasEstimationForceSend (error, continueTxExecution, cancelCb)
    *     [personal mode enabled, need password to continue] promptCb (okCb, cancelCb)
    * @param {Function} finalCallback    - last callback.
    */
  createContract: function (from, data, value, gasLimit, txRunner, callbacks, finalCallback) {
    if (!callbacks.confirmationCb || !callbacks.gasEstimationForceSend || !callbacks.promptCb) {
      return finalCallback('all the callbacks must have been defined');
    }

    const tx = {
      from: from,
      to: null,
      data: data,
      useCall: false,
      value: value,
      gasLimit: gasLimit
    };
    txRunner.rawRun(tx, callbacks.confirmationCb, callbacks.gasEstimationForceSend, callbacks.promptCb, (error, txResult) => {
      // see universaldapp.js line 660 => 700 to check possible values of txResult (error case)
      finalCallback(error, txResult);
    });
  },

  /**
    * call the current given contract ! that will create a transaction !
    *
    * @param {String} from    - sender address
    * @param {String} to    - recipient address
    * @param {String} data    - data to send with the transaction ( return of txFormat.buildData(...) ).
    * @param {String} value    - decimal representation of value.
    * @param {String} gasLimit    - decimal representation of gas limit.
    * @param {Object} txRunner    - TxRunner.js instance
    * @param {Object} callbacks    - { confirmationCb, gasEstimationForceSend, promptCb }
    *     [validate transaction] confirmationCb (network, tx, gasEstimation, continueTxExecution, cancelCb)
    *     [transaction failed, force send] gasEstimationForceSend (error, continueTxExecution, cancelCb)
    *     [personal mode enabled, need password to continue] promptCb (okCb, cancelCb)
    * @param {Function} finalCallback    - last callback.
    */
  callFunction: function (from, to, data, value, gasLimit, funAbi, txRunner, callbacks, finalCallback) {
    const useCall = funAbi.stateMutability === 'view' || funAbi.stateMutability === 'pure';
    const tx = {
      from,
      to,
      data,
      useCall,
      value,
      gasLimit
    };
    txRunner.rawRun(tx, callbacks.confirmationCb, callbacks.gasEstimationForceSend, callbacks.promptCb, (error, txResult) => {
      // see universaldapp.js line 660 => 700 to check possible values of txResult (error case)
      finalCallback(error, txResult);
    });
  },

  /**
    * check if the vm has errored
    *
    * @param {Object} txResult    - the value returned by the vm
    * @return {Object} -  { error: true/false, message: DOMNode }
    */
  checkVMError: function (txResult) {
    const errorCode = {
      OUT_OF_GAS: 'out of gas',
      STACK_UNDERFLOW: 'stack underflow',
      STACK_OVERFLOW: 'stack overflow',
      INVALID_JUMP: 'invalid JUMP',
      INVALID_OPCODE: 'invalid opcode',
      REVERT: 'revert',
      STATIC_STATE_CHANGE: 'static state change',
      INTERNAL_ERROR: 'internal error',
      CREATE_COLLISION: 'create collision',
      STOP: 'stop',
      REFUND_EXHAUSTED: 'refund exhausted'
    };
    const ret = {
      error: false,
      message: ''
    };

    if (!txResult.result.execResult.exceptionError) {
      return ret;
    }

    const exceptionError = txResult.result.execResult.exceptionError.error || '';
    const error = `VM error: ${exceptionError}.\n`;
    let msg;

    if (exceptionError === errorCode.INVALID_OPCODE) {
      msg = `\t\n\tThe execution might have thrown.\n`;
      ret.error = true;
    } else if (exceptionError === errorCode.OUT_OF_GAS) {
      msg = `\tThe transaction ran out of gas. Please increase the Gas Limit.\n`;
      ret.error = true;
    } else if (exceptionError === errorCode.REVERT) {
      const returnData = txResult.result.execResult.returnValue; // It is the hash of Error(string)

      if (returnData && returnData.slice(0, 4).toString('hex') === '08c379a0') {
        const abiCoder = new ethers.utils.AbiCoder();
        const reason = abiCoder.decode(['string'], returnData.slice(4))[0];
        msg = `\tThe transaction has been reverted to the initial state.\nReason provided by the contract: "${reason}".`;
      } else {
        msg = `\tThe transaction has been reverted to the initial state.\nNote: The called function should be payable if you send value and the value you send should be less than your current balance.`;
      }

      ret.error = true;
    } else if (exceptionError === errorCode.STATIC_STATE_CHANGE) {
      msg = `\tState changes is not allowed in Static Call context\n`;
      ret.error = true;
    }

    ret.message = `${error}${exceptionError}${msg}\tDebug the transaction to get more information.`;
    return ret;
  }
};

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/txFormat.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/txFormat.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const ethers = __webpack_require__(/*! ethers */ "../../../node_modules/ethers/dist/ethers.min.js");

const helper = __webpack_require__(/*! ./txHelper */ "../../../dist/libs/remix-lib/src/execution/txHelper.js");

const asyncJS = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

const solcLinker = __webpack_require__(/*! solc/linker */ "../../../node_modules/solc/linker.js");

const ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

module.exports = {
  /**
    * build the transaction data
    *
    * @param {Object} function abi
    * @param {Object} values to encode
    * @param {String} contractbyteCode
    */
  encodeData: function (funABI, values, contractbyteCode) {
    let encoded;
    let encodedHex;

    try {
      encoded = helper.encodeParams(funABI, values);
      encodedHex = encoded.toString('hex');
    } catch (e) {
      return {
        error: 'cannot encode arguments'
      };
    }

    if (contractbyteCode) {
      return {
        data: '0x' + contractbyteCode + encodedHex.replace('0x', '')
      };
    } else {
      return {
        data: helper.encodeFunctionId(funABI) + encodedHex.replace('0x', '')
      };
    }
  },

  /**
  * encode function / constructor parameters
  *
  * @param {Object} params    - input paramater of the function to call
  * @param {Object} funAbi    - abi definition of the function to call. null if building data for the ctor.
  * @param {Function} callback    - callback
  */
  encodeParams: function (params, funAbi, callback) {
    let data = '';
    let dataHex = '';
    let funArgs;

    if (params.indexOf('raw:0x') === 0) {
      // in that case we consider that the input is already encoded and *does not* contain the method signature
      dataHex = params.replace('raw:0x', '');
      data = Buffer.from(dataHex, 'hex');
    } else {
      try {
        params = params.replace(/(^|,\s+|,)(\d+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted number by quoted number

        params = params.replace(/(^|,\s+|,)(0[xX][0-9a-fA-F]+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted hex string by quoted hex string

        funArgs = JSON.parse('[' + params + ']');
      } catch (e) {
        return callback('Error encoding arguments: ' + e);
      }

      if (funArgs.length > 0) {
        try {
          data = helper.encodeParams(funAbi, funArgs);
          dataHex = data.toString('hex');
        } catch (e) {
          return callback('Error encoding arguments: ' + e);
        }
      }

      if (data.slice(0, 9) === 'undefined') {
        dataHex = data.slice(9);
      }

      if (data.slice(0, 2) === '0x') {
        dataHex = data.slice(2);
      }
    }

    callback(null, {
      data: data,
      dataHex: dataHex,
      funArgs: funArgs
    });
  },

  /**
  * encode function call (function id + encoded parameters)
  *
  * @param {Object} params    - input paramater of the function to call
  * @param {Object} funAbi    - abi definition of the function to call. null if building data for the ctor.
  * @param {Function} callback    - callback
  */
  encodeFunctionCall: function (params, funAbi, callback) {
    this.encodeParams(params, funAbi, (error, encodedParam) => {
      if (error) return callback(error);
      callback(null, {
        dataHex: helper.encodeFunctionId(funAbi) + encodedParam.dataHex,
        funAbi,
        funArgs: encodedParam.funArgs
      });
    });
  },

  /**
  * encode constructor creation and link with provided libraries if needed
  *
  * @param {Object} contract    - input paramater of the function to call
  * @param {Object} params    - input paramater of the function to call
  * @param {Object} funAbi    - abi definition of the function to call. null if building data for the ctor.
  * @param {Object} linkLibraries    - contains {linkReferences} object which list all the addresses to be linked
  * @param {Object} linkReferences    - given by the compiler, contains the proper linkReferences
  * @param {Function} callback    - callback
  */
  encodeConstructorCallAndLinkLibraries: function (contract, params, funAbi, linkLibraries, linkReferences, callback) {
    this.encodeParams(params, funAbi, (error, encodedParam) => {
      if (error) return callback(error);
      let bytecodeToDeploy = contract.evm.bytecode.object;

      if (bytecodeToDeploy.indexOf('_') >= 0) {
        if (linkLibraries && linkReferences) {
          for (let libFile in linkLibraries) {
            for (let lib in linkLibraries[libFile]) {
              const address = linkLibraries[libFile][lib];
              if (!ethJSUtil.isValidAddress(address)) return callback(address + ' is not a valid address. Please check the provided address is valid.');
              bytecodeToDeploy = this.linkLibraryStandardFromlinkReferences(lib, address.replace('0x', ''), bytecodeToDeploy, linkReferences);
            }
          }
        }
      }

      if (bytecodeToDeploy.indexOf('_') >= 0) {
        return callback('Failed to link some libraries');
      }

      return callback(null, {
        dataHex: bytecodeToDeploy + encodedParam.dataHex,
        funAbi,
        funArgs: encodedParam.funArgs,
        contractBytecode: contract.evm.bytecode.object
      });
    });
  },

  /**
  * encode constructor creation and deploy librairies if needed
  *
  * @param {String} contractName    - current contract name
  * @param {Object} contract    - input paramater of the function to call
  * @param {Object} contracts    - map of all compiled contracts.
  * @param {Object} params    - input paramater of the function to call
  * @param {Object} funAbi    - abi definition of the function to call. null if building data for the ctor.
  * @param {Function} callback    - callback
  * @param {Function} callbackStep  - callbackStep
  * @param {Function} callbackDeployLibrary  - callbackDeployLibrary
  * @param {Function} callback    - callback
  */
  encodeConstructorCallAndDeployLibraries: function (contractName, contract, contracts, params, funAbi, callback, callbackStep, callbackDeployLibrary) {
    this.encodeParams(params, funAbi, (error, encodedParam) => {
      if (error) return callback(error);
      let dataHex = '';
      const contractBytecode = contract.evm.bytecode.object;
      let bytecodeToDeploy = contract.evm.bytecode.object;

      if (bytecodeToDeploy.indexOf('_') >= 0) {
        this.linkBytecode(contract, contracts, (err, bytecode) => {
          if (err) {
            callback('Error deploying required libraries: ' + err);
          } else {
            bytecodeToDeploy = bytecode + dataHex;
            return callback(null, {
              dataHex: bytecodeToDeploy,
              funAbi,
              funArgs: encodedParam.funArgs,
              contractBytecode,
              contractName: contractName
            });
          }
        }, callbackStep, callbackDeployLibrary);
        return;
      } else {
        dataHex = bytecodeToDeploy + encodedParam.dataHex;
      }

      callback(null, {
        dataHex: bytecodeToDeploy,
        funAbi,
        funArgs: encodedParam.funArgs,
        contractBytecode,
        contractName: contractName
      });
    });
  },

  /**
  * (DEPRECATED) build the transaction data
  *
  * @param {String} contractName
  * @param {Object} contract    - abi definition of the current contract.
  * @param {Object} contracts    - map of all compiled contracts.
  * @param {Bool} isConstructor    - isConstructor.
  * @param {Object} funAbi    - abi definition of the function to call. null if building data for the ctor.
  * @param {Object} params    - input paramater of the function to call
  * @param {Function} callback    - callback
  * @param {Function} callbackStep  - callbackStep
  * @param {Function} callbackDeployLibrary  - callbackDeployLibrary
  */
  buildData: function (contractName, contract, contracts, isConstructor, funAbi, params, callback, callbackStep, callbackDeployLibrary) {
    let funArgs = [];
    let data = '';
    let dataHex = '';

    if (params.indexOf('raw:0x') === 0) {
      // in that case we consider that the input is already encoded and *does not* contain the method signature
      dataHex = params.replace('raw:0x', '');
      data = Buffer.from(dataHex, 'hex');
    } else {
      try {
        if (params.length > 0) {
          funArgs = this.parseFunctionParams(params);
        }
      } catch (e) {
        return callback('Error encoding arguments: ' + e);
      }

      try {
        data = helper.encodeParams(funAbi, funArgs);
        dataHex = data.toString('hex');
      } catch (e) {
        return callback('Error encoding arguments: ' + e);
      }

      if (data.slice(0, 9) === 'undefined') {
        dataHex = data.slice(9);
      }

      if (data.slice(0, 2) === '0x') {
        dataHex = data.slice(2);
      }
    }

    let contractBytecode;

    if (isConstructor) {
      contractBytecode = contract.evm.bytecode.object;
      let bytecodeToDeploy = contract.evm.bytecode.object;

      if (bytecodeToDeploy.indexOf('_') >= 0) {
        this.linkBytecode(contract, contracts, (err, bytecode) => {
          if (err) {
            callback('Error deploying required libraries: ' + err);
          } else {
            bytecodeToDeploy = bytecode + dataHex;
            return callback(null, {
              dataHex: bytecodeToDeploy,
              funAbi,
              funArgs,
              contractBytecode,
              contractName: contractName
            });
          }
        }, callbackStep, callbackDeployLibrary);
        return;
      } else {
        dataHex = bytecodeToDeploy + dataHex;
      }
    } else {
      dataHex = helper.encodeFunctionId(funAbi) + dataHex;
    }

    callback(null, {
      dataHex,
      funAbi,
      funArgs,
      contractBytecode,
      contractName: contractName
    });
  },
  atAddress: function () {},
  linkBytecodeStandard: function (contract, contracts, callback, callbackStep, callbackDeployLibrary) {
    let contractBytecode = contract.evm.bytecode.object;
    asyncJS.eachOfSeries(contract.evm.bytecode.linkReferences, (libs, file, cbFile) => {
      asyncJS.eachOfSeries(contract.evm.bytecode.linkReferences[file], (libRef, libName, cbLibDeployed) => {
        const library = contracts[file][libName];

        if (library) {
          this.deployLibrary(file + ':' + libName, libName, library, contracts, (error, address) => {
            if (error) {
              return cbLibDeployed(error);
            }

            let hexAddress = address.toString('hex');

            if (hexAddress.slice(0, 2) === '0x') {
              hexAddress = hexAddress.slice(2);
            }

            contractBytecode = this.linkLibraryStandard(libName, hexAddress, contractBytecode, contract);
            cbLibDeployed();
          }, callbackStep, callbackDeployLibrary);
        } else {
          cbLibDeployed('Cannot find compilation data of library ' + libName);
        }
      }, error => {
        cbFile(error);
      });
    }, error => {
      if (error) {
        callbackStep(error);
      }

      callback(error, contractBytecode);
    });
  },
  linkBytecodeLegacy: function (contract, contracts, callback, callbackStep, callbackDeployLibrary) {
    const libraryRefMatch = contract.evm.bytecode.object.match(/__([^_]{1,36})__/);

    if (!libraryRefMatch) {
      return callback('Invalid bytecode format.');
    }

    const libraryName = libraryRefMatch[1]; // file_name:library_name

    const libRef = libraryName.match(/(.*):(.*)/);

    if (!libRef) {
      return callback('Cannot extract library reference ' + libraryName);
    }

    if (!contracts[libRef[1]] || !contracts[libRef[1]][libRef[2]]) {
      return callback('Cannot find library reference ' + libraryName);
    }

    const libraryShortName = libRef[2];
    const library = contracts[libRef[1]][libraryShortName];

    if (!library) {
      return callback('Library ' + libraryName + ' not found.');
    }

    this.deployLibrary(libraryName, libraryShortName, library, contracts, (err, address) => {
      if (err) {
        return callback(err);
      }

      let hexAddress = address.toString('hex');

      if (hexAddress.slice(0, 2) === '0x') {
        hexAddress = hexAddress.slice(2);
      }

      contract.evm.bytecode.object = this.linkLibrary(libraryName, hexAddress, contract.evm.bytecode.object);
      this.linkBytecode(contract, contracts, callback, callbackStep, callbackDeployLibrary);
    }, callbackStep, callbackDeployLibrary);
  },
  linkBytecode: function (contract, contracts, callback, callbackStep, callbackDeployLibrary) {
    if (contract.evm.bytecode.object.indexOf('_') < 0) {
      return callback(null, contract.evm.bytecode.object);
    }

    if (contract.evm.bytecode.linkReferences && Object.keys(contract.evm.bytecode.linkReferences).length) {
      this.linkBytecodeStandard(contract, contracts, callback, callbackStep, callbackDeployLibrary);
    } else {
      this.linkBytecodeLegacy(contract, contracts, callback, callbackStep, callbackDeployLibrary);
    }
  },
  deployLibrary: function (libraryName, libraryShortName, library, contracts, callback, callbackStep, callbackDeployLibrary) {
    const address = library.address;

    if (address) {
      return callback(null, address);
    }

    const bytecode = library.evm.bytecode.object;

    if (bytecode.indexOf('_') >= 0) {
      this.linkBytecode(library, contracts, (err, bytecode) => {
        if (err) callback(err);else {
          library.evm.bytecode.object = bytecode;
          this.deployLibrary(libraryName, libraryShortName, library, contracts, callback, callbackStep, callbackDeployLibrary);
        }
      }, callbackStep, callbackDeployLibrary);
    } else {
      callbackStep(`creation of library ${libraryName} pending...`);
      const data = {
        dataHex: bytecode,
        funAbi: {
          type: 'constructor'
        },
        funArgs: [],
        contractBytecode: bytecode,
        contractName: libraryShortName
      };
      callbackDeployLibrary({
        data: data,
        useCall: false
      }, (err, txResult) => {
        if (err) {
          return callback(err);
        }

        const address = txResult.result.createdAddress || txResult.result.contractAddress;
        library.address = address;
        callback(err, address);
      });
    }
  },
  linkLibraryStandardFromlinkReferences: function (libraryName, address, bytecode, linkReferences) {
    for (let file in linkReferences) {
      for (let libName in linkReferences[file]) {
        if (libraryName === libName) {
          bytecode = this.setLibraryAddress(address, bytecode, linkReferences[file][libName]);
        }
      }
    }

    return bytecode;
  },
  linkLibraryStandard: function (libraryName, address, bytecode, contract) {
    return this.linkLibraryStandardFromlinkReferences(libraryName, address, bytecode, contract.evm.bytecode.linkReferences);
  },
  setLibraryAddress: function (address, bytecodeToLink, positions) {
    if (positions) {
      for (let pos of positions) {
        const regpos = bytecodeToLink.match(new RegExp(`(.{${2 * pos.start}})(.{${2 * pos.length}})(.*)`));

        if (regpos) {
          bytecodeToLink = regpos[1] + address + regpos[3];
        }
      }
    }

    return bytecodeToLink;
  },
  linkLibrary: function (libraryName, address, bytecodeToLink) {
    return solcLinker.linkBytecode(bytecodeToLink, {
      [libraryName]: ethJSUtil.addHexPrefix(address)
    });
  },
  decodeResponse: function (response, fnabi) {
    // Only decode if there supposed to be fields
    if (fnabi.outputs && fnabi.outputs.length > 0) {
      try {
        let i;
        const outputTypes = [];

        for (i = 0; i < fnabi.outputs.length; i++) {
          const type = fnabi.outputs[i].type;
          outputTypes.push(type.indexOf('tuple') === 0 ? helper.makeFullTypeDefinition(fnabi.outputs[i]) : type);
        }

        if (!response.length) response = new Uint8Array(32 * fnabi.outputs.length); // ensuring the data is at least filled by 0 cause `AbiCoder` throws if there's not engouh data
        // decode data

        const abiCoder = new ethers.utils.AbiCoder();
        const decodedObj = abiCoder.decode(outputTypes, response);
        const json = {};

        for (i = 0; i < outputTypes.length; i++) {
          const name = fnabi.outputs[i].name;
          json[i] = outputTypes[i] + ': ' + (name ? name + ' ' + decodedObj[i] : decodedObj[i]);
        }

        return json;
      } catch (e) {
        return {
          error: 'Failed to decode output: ' + e
        };
      }
    }

    return {};
  },
  parseFunctionParams: function (params) {
    let args = []; // Check if parameter string starts with array or string

    let startIndex = this.isArrayOrStringStart(params, 0) ? -1 : 0;

    for (let i = 0; i < params.length; i++) {
      // If a quote is received
      if (params.charAt(i) === '"') {
        startIndex = -1;
        let endQuoteIndex = false; // look for closing quote. On success, push the complete string in arguments list

        for (let j = i + 1; !endQuoteIndex; j++) {
          if (params.charAt(j) === '"') {
            args.push(params.substring(i + 1, j));
            endQuoteIndex = true;
            i = j;
          } // Throw error if end of params string is arrived but couldn't get end quote


          if (!endQuoteIndex && j === params.length - 1) {
            throw new Error('invalid params');
          }
        }
      } else if (params.charAt(i) === '[') {
        // If an array/struct opening bracket is received
        startIndex = -1;
        let bracketCount = 1;
        let j;

        for (j = i + 1; bracketCount !== 0; j++) {
          // Increase count if another array opening bracket is received (To handle nested array)
          if (params.charAt(j) === '[') {
            bracketCount++;
          } else if (params.charAt(j) === ']') {
            // // Decrease count if an array closing bracket is received (To handle nested array)
            bracketCount--;
          } // Throw error if end of params string is arrived but couldn't get end of tuple


          if (bracketCount !== 0 && j === params.length - 1) {
            throw new Error('invalid tuple params');
          }
        } // If bracketCount = 0, it means complete array/nested array parsed, push it to the arguments list


        args.push(JSON.parse(params.substring(i, j)));
        i = j - 1;
      } else if (params.charAt(i) === ',') {
        // if startIndex >= 0, it means a parameter was being parsed, it can be first or other parameter
        if (startIndex >= 0) {
          args.push(params.substring(startIndex, i));
        } // Register start index of a parameter to parse


        startIndex = this.isArrayOrStringStart(params, i + 1) ? -1 : i + 1;
      } else if (startIndex >= 0 && i === params.length - 1) {
        // If start index is registered and string is completed (To handle last parameter)
        args.push(params.substring(startIndex, params.length));
      }
    }

    args = args.map(e => {
      if (!Array.isArray(e)) {
        return e.trim();
      } else {
        return e;
      }
    });
    return args;
  },
  isArrayOrStringStart: function (str, index) {
    return str.charAt(index) === '"' || str.charAt(index) === '[';
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/txHelper.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/txHelper.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ethers = __webpack_require__(/*! ethers */ "../../../node_modules/ethers/dist/ethers.min.js");

module.exports = {
  makeFullTypeDefinition: function (typeDef) {
    if (typeDef && typeDef.type.indexOf('tuple') === 0 && typeDef.components) {
      const innerTypes = typeDef.components.map(innerType => {
        return this.makeFullTypeDefinition(innerType);
      });
      return `tuple(${innerTypes.join(',')})${this.extractSize(typeDef.type)}`;
    }

    return typeDef.type;
  },
  encodeParams: function (funABI, args) {
    const types = [];

    if (funABI.inputs && funABI.inputs.length) {
      for (let i = 0; i < funABI.inputs.length; i++) {
        const type = funABI.inputs[i].type; // "false" will be converting to `false` and "true" will be working
        // fine as abiCoder assume anything in quotes as `true`

        if (type === 'bool' && args[i] === 'false') {
          args[i] = false;
        }

        types.push(type.indexOf('tuple') === 0 ? this.makeFullTypeDefinition(funABI.inputs[i]) : type);

        if (args.length < types.length) {
          args.push('');
        }
      }
    } // NOTE: the caller will concatenate the bytecode and this
    //       it could be done here too for consistency


    const abiCoder = new ethers.utils.AbiCoder();
    return abiCoder.encode(types, args);
  },
  encodeFunctionId: function (funABI) {
    if (funABI.type === 'fallback' || funABI.type === 'receive') return '0x';
    let abi = new ethers.utils.Interface([funABI]);
    abi = abi.functions[funABI.name];
    return abi.sighash;
  },
  sortAbiFunction: function (contractabi) {
    // Check if function is constant (introduced with Solidity 0.6.0)
    const isConstant = ({
      stateMutability
    }) => stateMutability === 'view' || stateMutability === 'pure'; // Sorts the list of ABI entries. Constant functions will appear first,
    // followed by non-constant functions. Within those t wo groupings, functions
    // will be sorted by their names.


    return contractabi.sort(function (a, b) {
      if (isConstant(a) && !isConstant(b)) {
        return 1;
      } else if (isConstant(b) && !isConstant(a)) {
        return -1;
      } // If we reach here, either a and b are both constant or both not; sort by name then
      // special case for fallback, receive and constructor function


      if (a.type === 'function' && typeof a.name !== 'undefined') {
        return a.name.localeCompare(b.name);
      } else if (a.type === 'constructor' || a.type === 'fallback' || a.type === 'receive') {
        return 1;
      }
    });
  },
  getConstructorInterface: function (abi) {
    const funABI = {
      'name': '',
      'inputs': [],
      'type': 'constructor',
      'payable': false,
      'outputs': []
    };

    if (typeof abi === 'string') {
      try {
        abi = JSON.parse(abi);
      } catch (e) {
        console.log('exception retrieving ctor abi ' + abi);
        return funABI;
      }
    }

    for (let i = 0; i < abi.length; i++) {
      if (abi[i].type === 'constructor') {
        funABI.inputs = abi[i].inputs || [];
        funABI.payable = abi[i].payable;
        funABI.stateMutability = abi[i].stateMutability;
        break;
      }
    }

    return funABI;
  },
  serializeInputs: function (fnAbi) {
    let serialized = '(';

    if (fnAbi.inputs && fnAbi.inputs.length) {
      serialized += fnAbi.inputs.map(input => {
        return input.type;
      }).join(',');
    }

    serialized += ')';
    return serialized;
  },
  extractSize: function (type) {
    const size = type.match(/([a-zA-Z0-9])(\[.*\])/);
    return size ? size[2] : '';
  },
  getFunction: function (abi, fnName) {
    for (let i = 0; i < abi.length; i++) {
      const fn = abi[i];

      if (fn.type === 'function' && fnName === fn.name + '(' + fn.inputs.map(value => {
        if (value.components) {
          let fullType = this.makeFullTypeDefinition(value);
          return fullType.replace(/tuple/g, ''); // return of makeFullTypeDefinition might contain `tuple`, need to remove it cause `methodIdentifier` (fnName) does not include `tuple` keyword
        } else {
          return value.type;
        }
      }).join(',') + ')') {
        return fn;
      }
    }

    return null;
  },
  getFallbackInterface: function (abi) {
    for (let i = 0; i < abi.length; i++) {
      if (abi[i].type === 'fallback') {
        return abi[i];
      }
    }
  },
  getReceiveInterface: function (abi) {
    for (let i = 0; i < abi.length; i++) {
      if (abi[i].type === 'receive') {
        return abi[i];
      }
    }
  },

  /**
    * return the contract obj of the given @arg name. Uses last compilation result.
    * return null if not found
    * @param {String} name    - contract name
    * @returns contract obj and associated file: { contract, file } or null
    */
  getContract: (contractName, contracts) => {
    for (let file in contracts) {
      if (contracts[file][contractName]) {
        return {
          object: contracts[file][contractName],
          file: file
        };
      }
    }

    return null;
  },

  /**
    * call the given @arg cb (function) for all the contracts. Uses last compilation result
    * stop visiting when cb return true
    * @param {Function} cb    - callback
    */
  visitContracts: (contracts, cb) => {
    for (let file in contracts) {
      for (let name in contracts[file]) {
        if (cb({
          name: name,
          object: contracts[file][name],
          file: file
        })) return;
      }
    }
  },
  inputParametersDeclarationToString: function (abiinputs) {
    const inputs = (abiinputs || []).map(inp => inp.type + ' ' + inp.name);
    return inputs.join(', ');
  }
};

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/txListener.js":
/*!************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/txListener.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

const ethers = __webpack_require__(/*! ethers */ "../../../node_modules/ethers/dist/ethers.min.js");

const ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const EventManager = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

const codeUtil = __webpack_require__(/*! ../util */ "../../../dist/libs/remix-lib/src/util.js");

const defaultExecutionContext = __webpack_require__(/*! ./execution-context */ "../../../dist/libs/remix-lib/src/execution/execution-context.js");

const txFormat = __webpack_require__(/*! ./txFormat */ "../../../dist/libs/remix-lib/src/execution/txFormat.js");

const txHelper = __webpack_require__(/*! ./txHelper */ "../../../dist/libs/remix-lib/src/execution/txHelper.js");
/**
  * poll web3 each 2s if web3
  * listen on transaction executed event if VM
  * attention: blocks returned by the event `newBlock` have slightly different json properties whether web3 or the VM is used
  * trigger 'newBlock'
  *
  */


class TxListener {
  constructor(opt, executionContext) {
    this.event = new EventManager(); // has a default for now for backwards compatability

    this.executionContext = executionContext || defaultExecutionContext;
    this._api = opt.api;
    this._resolvedTransactions = {};
    this._resolvedContracts = {};
    this._isListening = false;
    this._listenOnNetwork = false;
    this._loopId = null;
    this.init();
    this.executionContext.event.register('contextChanged', context => {
      if (this._isListening) {
        this.stopListening();
        this.startListening();
      }
    });
    opt.event.udapp.register('callExecuted', (error, from, to, data, lookupOnly, txResult) => {
      if (error) return; // we go for that case if
      // in VM mode
      // in web3 mode && listen remix txs only

      if (!this._isListening) return; // we don't listen

      if (this._loopId && this.executionContext.getProvider() !== 'vm') return; // we seems to already listen on a "web3" network

      const call = {
        from: from,
        to: to,
        input: data,
        hash: txResult.transactionHash ? txResult.transactionHash : 'call' + (from || '') + to + data,
        isCall: true,
        returnValue: this.executionContext.isVM() ? txResult.result.execResult.returnValue : ethJSUtil.toBuffer(txResult.result),
        envMode: this.executionContext.getProvider()
      };
      addExecutionCosts(txResult, call);

      this._resolveTx(call, call, (error, resolvedData) => {
        if (!error) {
          this.event.trigger('newCall', [call]);
        }
      });
    });
    opt.event.udapp.register('transactionExecuted', (error, from, to, data, lookupOnly, txResult) => {
      if (error) return;
      if (lookupOnly) return; // we go for that case if
      // in VM mode
      // in web3 mode && listen remix txs only

      if (!this._isListening) return; // we don't listen

      if (this._loopId && this.executionContext.getProvider() !== 'vm') return; // we seems to already listen on a "web3" network

      this.executionContext.web3().eth.getTransaction(txResult.transactionHash, (error, tx) => {
        if (error) return console.log(error);
        addExecutionCosts(txResult, tx);
        tx.envMode = this.executionContext.getProvider();
        tx.status = txResult.result.status; // 0x0 or 0x1

        this._resolve([tx], () => {});
      });
    });

    function addExecutionCosts(txResult, tx) {
      if (txResult && txResult.result) {
        if (txResult.result.execResult) {
          tx.returnValue = txResult.result.execResult.returnValue;
          if (txResult.result.execResult.gasUsed) tx.executionCost = txResult.result.execResult.gasUsed.toString(10);
        }

        if (txResult.result.gasUsed) tx.transactionCost = txResult.result.gasUsed.toString(10);
      }
    }
  }
  /**
    * define if txlistener should listen on the network or if only tx created from remix are managed
    *
    * @param {Bool} type - true if listen on the network
    */


  setListenOnNetwork(listenOnNetwork) {
    this._listenOnNetwork = listenOnNetwork;

    if (this._loopId) {
      clearInterval(this._loopId);
    }

    if (this._listenOnNetwork) {
      this._startListenOnNetwork();
    }
  }
  /**
    * reset recorded transactions
    */


  init() {
    this.blocks = [];
    this.lastBlock = null;
  }
  /**
    * start listening for incoming transactions
    *
    * @param {String} type - type/name of the provider to add
    * @param {Object} obj  - provider
    */


  startListening() {
    this.init();
    this._isListening = true;

    if (this._listenOnNetwork && this.executionContext.getProvider() !== 'vm') {
      this._startListenOnNetwork();
    }
  }
  /**
   * stop listening for incoming transactions. do not reset the recorded pool.
   *
   * @param {String} type - type/name of the provider to add
   * @param {Object} obj  - provider
   */


  stopListening() {
    if (this._loopId) {
      clearInterval(this._loopId);
    }

    this._loopId = null;
    this._isListening = false;
  }

  _startListenOnNetwork() {
    this._loopId = setInterval(() => {
      const currentLoopId = this._loopId;
      this.executionContext.web3().eth.getBlockNumber((error, blockNumber) => {
        if (this._loopId === null) return;
        if (error) return console.log(error);

        if (currentLoopId === this._loopId && (!this.lastBlock || blockNumber > this.lastBlock)) {
          if (!this.lastBlock) this.lastBlock = blockNumber - 1;
          let current = this.lastBlock + 1;
          this.lastBlock = blockNumber;

          while (blockNumber >= current) {
            try {
              this._manageBlock(current);
            } catch (e) {
              console.log(e);
            }

            current++;
          }
        }
      });
    }, 2000);
  }

  _manageBlock(blockNumber) {
    this.executionContext.web3().eth.getBlock(blockNumber, true, (error, result) => {
      if (!error) {
        this._newBlock(Object.assign({
          type: 'web3'
        }, result));
      }
    });
  }
  /**
    * try to resolve the contract name from the given @arg address
    *
    * @param {String} address - contract address to resolve
    * @return {String} - contract name
    */


  resolvedContract(address) {
    if (this._resolvedContracts[address]) return this._resolvedContracts[address].name;
    return null;
  }
  /**
    * try to resolve the transaction from the given @arg txHash
    *
    * @param {String} txHash - contract address to resolve
    * @return {String} - contract name
    */


  resolvedTransaction(txHash) {
    return this._resolvedTransactions[txHash];
  }

  _newBlock(block) {
    this.blocks.push(block);

    this._resolve(block.transactions, () => {
      this.event.trigger('newBlock', [block]);
    });
  }

  _resolve(transactions, callback) {
    async.each(transactions, (tx, cb) => {
      this._api.resolveReceipt(tx, (error, receipt) => {
        if (error) return cb(error);

        this._resolveTx(tx, receipt, (error, resolvedData) => {
          if (error) cb(error);

          if (resolvedData) {
            this.event.trigger('txResolved', [tx, receipt, resolvedData]);
          }

          this.event.trigger('newTransaction', [tx, receipt]);
          cb();
        });
      });
    }, () => {
      callback();
    });
  }

  _resolveTx(tx, receipt, cb) {
    const contracts = this._api.contracts();

    if (!contracts) return cb();
    let fun;
    let contract;

    if (!tx.to || tx.to === '0x0') {
      // testrpc returns 0x0 in that case
      // contract creation / resolve using the creation bytes code
      // if web3: we have to call getTransactionReceipt to get the created address
      // if VM: created address already included
      const code = tx.input;
      contract = this._tryResolveContract(code, contracts, true);

      if (contract) {
        let address = receipt.contractAddress;
        this._resolvedContracts[address] = contract;
        fun = this._resolveFunction(contract, tx, true);

        if (this._resolvedTransactions[tx.hash]) {
          this._resolvedTransactions[tx.hash].contractAddress = address;
        }

        return cb(null, {
          to: null,
          contractName: contract.name,
          function: fun,
          creationAddress: address
        });
      }

      return cb();
    } else {
      // first check known contract, resolve against the `runtimeBytecode` if not known
      contract = this._resolvedContracts[tx.to];

      if (!contract) {
        this.executionContext.web3().eth.getCode(tx.to, (error, code) => {
          if (error) return cb(error);

          if (code) {
            const contract = this._tryResolveContract(code, contracts, false);

            if (contract) {
              this._resolvedContracts[tx.to] = contract;

              const fun = this._resolveFunction(contract, tx, false);

              return cb(null, {
                to: tx.to,
                contractName: contract.name,
                function: fun
              });
            }
          }

          return cb();
        });
        return;
      }

      if (contract) {
        fun = this._resolveFunction(contract, tx, false);
        return cb(null, {
          to: tx.to,
          contractName: contract.name,
          function: fun
        });
      }

      return cb();
    }
  }

  _resolveFunction(contract, tx, isCtor) {
    if (!contract) {
      console.log('txListener: cannot resolve contract - contract is null');
      return;
    }

    const abi = contract.object.abi;
    const inputData = tx.input.replace('0x', '');

    if (!isCtor) {
      const methodIdentifiers = contract.object.evm.methodIdentifiers;

      for (let fn in methodIdentifiers) {
        if (methodIdentifiers[fn] === inputData.substring(0, 8)) {
          const fnabi = txHelper.getFunction(abi, fn);
          this._resolvedTransactions[tx.hash] = {
            contractName: contract.name,
            to: tx.to,
            fn: fn,
            params: this._decodeInputParams(inputData.substring(8), fnabi)
          };

          if (tx.returnValue) {
            this._resolvedTransactions[tx.hash].decodedReturnValue = txFormat.decodeResponse(tx.returnValue, fnabi);
          }

          return this._resolvedTransactions[tx.hash];
        }
      } // receive function


      if (!inputData && txHelper.getReceiveInterface(abi)) {
        this._resolvedTransactions[tx.hash] = {
          contractName: contract.name,
          to: tx.to,
          fn: '(receive)',
          params: null
        };
      } else {
        // fallback function
        this._resolvedTransactions[tx.hash] = {
          contractName: contract.name,
          to: tx.to,
          fn: '(fallback)',
          params: null
        };
      }
    } else {
      const bytecode = contract.object.evm.bytecode.object;
      let params = null;

      if (bytecode && bytecode.length) {
        params = this._decodeInputParams(inputData.substring(bytecode.length), txHelper.getConstructorInterface(abi));
      }

      this._resolvedTransactions[tx.hash] = {
        contractName: contract.name,
        to: null,
        fn: '(constructor)',
        params: params
      };
    }

    return this._resolvedTransactions[tx.hash];
  }

  _tryResolveContract(codeToResolve, compiledContracts, isCreation) {
    let found = null;
    txHelper.visitContracts(compiledContracts, contract => {
      const bytes = isCreation ? contract.object.evm.bytecode.object : contract.object.evm.deployedBytecode.object;

      if (codeUtil.compareByteCode(codeToResolve, '0x' + bytes)) {
        found = contract;
        return true;
      }
    });
    return found;
  }

  _decodeInputParams(data, abi) {
    data = ethJSUtil.toBuffer('0x' + data);
    if (!data.length) data = new Uint8Array(32 * abi.inputs.length); // ensuring the data is at least filled by 0 cause `AbiCoder` throws if there's not engouh data

    const inputTypes = [];

    for (let i = 0; i < abi.inputs.length; i++) {
      const type = abi.inputs[i].type;
      inputTypes.push(type.indexOf('tuple') === 0 ? txHelper.makeFullTypeDefinition(abi.inputs[i]) : type);
    }

    const abiCoder = new ethers.utils.AbiCoder();
    const decoded = abiCoder.decode(inputTypes, data);
    const ret = {};

    for (var k in abi.inputs) {
      ret[abi.inputs[k].type + ' ' + abi.inputs[k].name] = decoded[k];
    }

    return ret;
  }

}

module.exports = TxListener;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/txRunner.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/txRunner.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const EthJSTX = __webpack_require__(/*! ethereumjs-tx */ "../../../node_modules/ethereumjs-tx/dist/index.js").Transaction;

const EthJSBlock = __webpack_require__(/*! ethereumjs-block */ "../../../node_modules/ethereumjs-block/index.js");

const ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const BN = ethJSUtil.BN;

const defaultExecutionContext = __webpack_require__(/*! ./execution-context */ "../../../dist/libs/remix-lib/src/execution/execution-context.js");

const EventManager = __webpack_require__(/*! ../eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

class TxRunner {
  constructor(vmaccounts, api, executionContext) {
    this.event = new EventManager(); // has a default for now for backwards compatability

    this.executionContext = executionContext || defaultExecutionContext;
    this._api = api;
    this.blockNumber = 0;
    this.runAsync = true;

    if (this.executionContext.isVM()) {
      // this.blockNumber = 1150000 // The VM is running in Homestead mode, which started at this block.
      this.blockNumber = 0; // The VM is running in Homestead mode, which started at this block.

      this.runAsync = false; // We have to run like this cause the VM Event Manager does not support running multiple txs at the same time.
    }

    this.pendingTxs = {};
    this.vmaccounts = vmaccounts;
    this.queusTxs = [];
    this.blocks = [];
  }

  rawRun(args, confirmationCb, gasEstimationForceSend, promptCb, cb) {
    let timestamp = Date.now();

    if (args.timestamp) {
      timestamp = args.timestamp;
    }

    run(this, args, timestamp, confirmationCb, gasEstimationForceSend, promptCb, cb);
  }

  _executeTx(tx, gasPrice, api, promptCb, callback) {
    if (gasPrice) tx.gasPrice = this.executionContext.web3().utils.toHex(gasPrice);

    if (api.personalMode()) {
      promptCb(value => {
        this._sendTransaction(this.executionContext.web3().personal.sendTransaction, tx, value, callback);
      }, () => {
        return callback('Canceled by user.');
      });
    } else {
      this._sendTransaction(this.executionContext.web3().eth.sendTransaction, tx, null, callback);
    }
  }

  _sendTransaction(sendTx, tx, pass, callback) {
    const cb = (err, resp) => {
      if (err) {
        return callback(err, resp);
      }

      this.event.trigger('transactionBroadcasted', [resp]);

      var listenOnResponse = () => {
        // eslint-disable-next-line no-async-promise-executor
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          const result = yield tryTillReceiptAvailable(resp, this.executionContext);
          tx = yield tryTillTxAvailable(resp, this.executionContext);
          resolve({
            result,
            tx,
            transactionHash: result ? result.transactionHash : null
          });
        }));
      };

      listenOnResponse().then(txData => {
        callback(null, txData);
      }).catch(error => {
        callback(error);
      });
    };

    const args = pass !== null ? [tx, pass, cb] : [tx, cb];

    try {
      sendTx.apply({}, args);
    } catch (e) {
      return callback(`Send transaction failed: ${e.message} . if you use an injected provider, please check it is properly unlocked. `);
    }
  }

  execute(args, confirmationCb, gasEstimationForceSend, promptCb, callback) {
    let data = args.data;

    if (data.slice(0, 2) !== '0x') {
      data = '0x' + data;
    }

    if (!this.executionContext.isVM()) {
      this.runInNode(args.from, args.to, data, args.value, args.gasLimit, args.useCall, confirmationCb, gasEstimationForceSend, promptCb, callback);
    } else {
      try {
        this.runInVm(args.from, args.to, data, args.value, args.gasLimit, args.useCall, args.timestamp, callback);
      } catch (e) {
        callback(e, null);
      }
    }
  }

  runInVm(from, to, data, value, gasLimit, useCall, timestamp, callback) {
    const self = this;
    const account = self.vmaccounts[from];

    if (!account) {
      return callback('Invalid account selected');
    }

    this.executionContext.vm().stateManager.getAccount(Buffer.from(from.replace('0x', ''), 'hex'), (err, res) => {
      if (err) {
        callback('Account not found');
      } else {
        // See https://github.com/ethereumjs/ethereumjs-tx/blob/master/docs/classes/transaction.md#constructor
        // for initialization fields and their types
        value = value ? parseInt(value) : 0;
        const tx = new EthJSTX({
          nonce: new BN(res.nonce),
          gasPrice: '0x1',
          gasLimit: gasLimit,
          to: to,
          value: value,
          data: Buffer.from(data.slice(2), 'hex')
        });
        tx.sign(account.privateKey);
        const coinbases = ['0x0e9281e9c6a0808672eaba6bd1220e144c9bb07a', '0x8945a1288dc78a6d8952a92c77aee6730b414778', '0x94d76e24f818426ae84aa404140e8d5f60e10e7e'];
        const difficulties = [new BN('69762765929000', 10), new BN('70762765929000', 10), new BN('71762765929000', 10)];
        const block = new EthJSBlock({
          header: {
            timestamp: timestamp || new Date().getTime() / 1000 | 0,
            number: self.blockNumber,
            coinbase: coinbases[self.blockNumber % coinbases.length],
            difficulty: difficulties[self.blockNumber % difficulties.length],
            gasLimit: new BN(gasLimit, 10).imuln(2)
          },
          transactions: [tx],
          uncleHeaders: []
        });

        if (!useCall) {
          ++self.blockNumber;
          this.runBlockInVm(tx, block, callback);
        } else {
          this.executionContext.vm().stateManager.checkpoint(() => {
            this.runBlockInVm(tx, block, (err, result) => {
              this.executionContext.vm().stateManager.revert(() => {
                callback(err, result);
              });
            });
          });
        }
      }
    });
  }

  runBlockInVm(tx, block, callback) {
    this.executionContext.vm().runBlock({
      block: block,
      generate: true,
      skipBlockValidation: true,
      skipBalance: false
    }).then(results => {
      let result = results.results[0];

      if (result) {
        const status = result.execResult.exceptionError ? 0 : 1;
        result.status = `0x${status}`;
      }

      this.executionContext.addBlock(block);
      this.executionContext.trackTx('0x' + tx.hash().toString('hex'), block);
      callback(null, {
        result: result,
        transactionHash: ethJSUtil.bufferToHex(Buffer.from(tx.hash()))
      });
    }).catch(function (err) {
      callback(err);
    });
  }

  runInNode(from, to, data, value, gasLimit, useCall, confirmCb, gasEstimationForceSend, promptCb, callback) {
    const tx = {
      from: from,
      to: to,
      data: data,
      value: value
    };

    if (useCall) {
      tx.gas = gasLimit;
      return this.executionContext.web3().eth.call(tx, function (error, result) {
        callback(error, {
          result: result,
          transactionHash: result ? result.transactionHash : null
        });
      });
    }

    this.executionContext.web3().eth.estimateGas(tx, (err, gasEstimation) => {
      gasEstimationForceSend(err, () => {
        // callback is called whenever no error
        tx.gas = !gasEstimation ? gasLimit : gasEstimation;

        if (this._api.config.getUnpersistedProperty('doNotShowTransactionConfirmationAgain')) {
          return this._executeTx(tx, null, this._api, promptCb, callback);
        }

        this._api.detectNetwork((err, network) => {
          if (err) {
            console.log(err);
            return;
          }

          confirmCb(network, tx, tx.gas, gasPrice => {
            return this._executeTx(tx, gasPrice, this._api, promptCb, callback);
          }, error => {
            callback(error);
          });
        });
      }, () => {
        const blockGasLimit = this.executionContext.currentblockGasLimit(); // NOTE: estimateGas very likely will return a large limit if execution of the code failed
        //       we want to be able to run the code in order to debug and find the cause for the failure

        if (err) return callback(err);
        let warnEstimation = ' An important gas estimation might also be the sign of a problem in the contract code. Please check loops and be sure you did not sent value to a non payable function (that\'s also the reason of strong gas estimation). ';
        warnEstimation += ' ' + err;

        if (gasEstimation > gasLimit) {
          return callback('Gas required exceeds limit: ' + gasLimit + '. ' + warnEstimation);
        }

        if (gasEstimation > blockGasLimit) {
          return callback('Gas required exceeds block gas limit: ' + gasLimit + '. ' + warnEstimation);
        }
      });
    });
  }

}

function tryTillReceiptAvailable(txhash, executionContext) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      executionContext.web3().eth.getTransactionReceipt(txhash, (err, receipt) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (err || !receipt) {
          // Try again with a bit of delay if error or if result still null
          yield pause();
          return resolve(yield tryTillReceiptAvailable(txhash, executionContext));
        } else {
          return resolve(receipt);
        }
      }));
    });
  });
}

function tryTillTxAvailable(txhash, executionContext) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      executionContext.web3().eth.getTransaction(txhash, (err, tx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (err || !tx) {
          // Try again with a bit of delay if error or if result still null
          yield pause();
          return resolve(yield tryTillTxAvailable(txhash, executionContext));
        } else {
          return resolve(tx);
        }
      }));
    });
  });
}

function pause() {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      setTimeout(resolve, 500);
    });
  });
}

function run(self, tx, stamp, confirmationCb, gasEstimationForceSend, promptCb, callback) {
  if (!self.runAsync && Object.keys(self.pendingTxs).length) {
    self.queusTxs.push({
      tx,
      stamp,
      callback
    });
  } else {
    self.pendingTxs[stamp] = tx;
    self.execute(tx, confirmationCb, gasEstimationForceSend, promptCb, function (error, result) {
      delete self.pendingTxs[stamp];
      callback(error, result);

      if (self.queusTxs.length) {
        const next = self.queusTxs.pop();
        run(self, next.tx, next.stamp, next.callback);
      }
    });
  }
}

module.exports = TxRunner;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/execution/typeConversion.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/execution/typeConversion.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const BN = ethJSUtil.BN;
module.exports = {
  toInt: h => {
    if (h.indexOf && h.indexOf('0x') === 0) {
      return new BN(h.replace('0x', ''), 16).toString(10);
    } else if (h.constructor && h.constructor.name === 'BigNumber' || BN.isBN(h)) {
      return h.toString(10);
    }

    return h;
  },
  stringify: stringify
};

function stringify(v) {
  try {
    if (v instanceof Array) {
      const ret = [];

      for (var k in v) {
        ret.push(stringify(v[k]));
      }

      return ret;
    } else if (BN.isBN(v) || v.constructor && v.constructor.name === 'BigNumber') {
      return v.toString(10);
    } else if (v._isBuffer) {
      return ethJSUtil.bufferToHex(v);
    } else if (typeof v === 'object') {
      const retObject = {};

      for (let i in v) {
        retObject[i] = stringify(v[i]);
      }

      return retObject;
    } else {
      return v;
    }
  } catch (e) {
    console.log(e);
    return v;
  }
}

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/helpers/compilerHelper.js":
/*!**************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/helpers/compilerHelper.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  compilerInput: compilerInput
};

function compilerInput(contracts) {
  return JSON.stringify({
    language: 'Solidity',
    sources: {
      'test.sol': {
        content: contracts
      }
    },
    settings: {
      optimizer: {
        enabled: false,
        runs: 200
      },
      outputSelection: {
        '*': {
          '': ['legacyAST', 'ast'],
          '*': ['abi', 'metadata', 'evm.legacyAssembly', 'evm.bytecode', 'evm.deployedBytecode', 'evm.methodIdentifiers', 'evm.gasEstimates']
        }
      }
    }
  });
}

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/helpers/traceHelper.js":
/*!***********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/helpers/traceHelper.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ui = __webpack_require__(/*! ./uiHelper */ "../../../dist/libs/remix-lib/src/helpers/uiHelper.js");

module.exports = {
  // vmTraceIndex has to point to a CALL, CODECALL, ...
  resolveCalledAddress: function (vmTraceIndex, trace) {
    const step = trace[vmTraceIndex];

    if (this.isCreateInstruction(step)) {
      return this.contractCreationToken(vmTraceIndex);
    } else if (this.isCallInstruction(step)) {
      const stack = step.stack; // callcode, delegatecall, ...

      return ui.normalizeHexAddress(stack[stack.length - 2]);
    }

    return undefined;
  },
  isCallInstruction: function (step) {
    return step.op === 'CALL' || step.op === 'CALLCODE' || step.op === 'CREATE' || step.op === 'DELEGATECALL';
  },
  isCreateInstruction: function (step) {
    return step.op === 'CREATE';
  },
  isReturnInstruction: function (step) {
    return step.op === 'RETURN';
  },
  isJumpDestInstruction: function (step) {
    return step.op === 'JUMPDEST';
  },
  isStopInstruction: function (step) {
    return step.op === 'STOP';
  },
  isRevertInstruction: function (step) {
    return step.op === 'REVERT';
  },
  isSSTOREInstruction: function (step) {
    return step.op === 'SSTORE';
  },
  isSHA3Instruction: function (step) {
    return step.op === 'SHA3';
  },
  newContextStorage: function (step) {
    return step.op === 'CREATE' || step.op === 'CALL';
  },
  isCallToPrecompiledContract: function (index, trace) {
    // if stack empty => this is not a precompiled contract
    const step = trace[index];

    if (this.isCallInstruction(step)) {
      return index + 1 < trace.length && trace[index + 1].stack.length !== 0;
    } else {
      return false;
    }
  },
  contractCreationToken: function (index) {
    return '(Contract Creation - Step ' + index + ')';
  },
  isContractCreation: function (address) {
    return address.indexOf('(Contract Creation - Step') !== -1;
  }
};

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/helpers/txResultHelper.js":
/*!**************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/helpers/txResultHelper.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const {
  bufferToHex,
  isHexString
} = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

function convertToPrefixedHex(input) {
  if (input === undefined || input === null || isHexString(input)) {
    return input;
  } else if (Buffer.isBuffer(input)) {
    return bufferToHex(input);
  }

  return '0x' + input.toString(16);
}
/*
 txResult.result can be 3 different things:
 - VM call or tx: ethereumjs-vm result object
 - Node transaction: object returned from eth.getTransactionReceipt()
 - Node call: return value from function call (not an object)

 Also, VM results use BN and Buffers, Node results use hex strings/ints,
 So we need to normalize the values to prefixed hex strings
*/


function resultToRemixTx(txResult) {
  const {
    result,
    transactionHash
  } = txResult;
  const {
    status,
    execResult,
    gasUsed,
    createdAddress,
    contractAddress
  } = result;
  let returnValue, errorMessage;

  if (isHexString(result)) {
    returnValue = result;
  } else if (execResult !== undefined) {
    returnValue = execResult.returnValue;
    errorMessage = execResult.exceptionError;
  }

  return {
    transactionHash,
    status,
    gasUsed: convertToPrefixedHex(gasUsed),
    error: errorMessage,
    return: convertToPrefixedHex(returnValue),
    createdAddress: convertToPrefixedHex(createdAddress || contractAddress)
  };
}

module.exports = {
  resultToRemixTx
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/helpers/uiHelper.js":
/*!********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/helpers/uiHelper.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  formatMemory: function (mem, width) {
    const ret = {};

    if (!mem) {
      return ret;
    }

    if (!mem.substr) {
      mem = mem.join(''); // geth returns an array, eth return raw string
    }

    for (let k = 0; k < mem.length; k += width * 2) {
      const memory = mem.substr(k, width * 2);
      const content = this.tryConvertAsciiFormat(memory);
      ret['0x' + (k / 2).toString(16)] = content.raw + '\t' + content.ascii;
    }

    return ret;
  },
  tryConvertAsciiFormat: function (memorySlot) {
    const ret = {
      ascii: '',
      raw: ''
    };

    for (let k = 0; k < memorySlot.length; k += 2) {
      const raw = memorySlot.substr(k, 2);
      let ascii = String.fromCharCode(parseInt(raw, 16));
      ascii = ascii.replace(/[^\w\s]/, '?');

      if (ascii === '') {
        ascii = '?';
      }

      ret.ascii += ascii;
      ret.raw += raw;
    }

    return ret;
  },

  /**
   * format @args css1, css2, css3 to css inline style
   *
   * @param {Object} css1 - css inline declaration
   * @param {Object} css2 - css inline declaration
   * @param {Object} css3 - css inline declaration
   * @param {Object} ...
   * @return {String} css inline style
   *                  if the key start with * the value is direcly appended to the inline style (which should be already inline style formatted)
   *                  used if multiple occurences of the same key is needed
   */
  formatCss: function (css1, css2) {
    let ret = '';

    for (let arg in arguments) {
      for (let k in arguments[arg]) {
        if (arguments[arg][k] && ret.indexOf(k) === -1) {
          if (k.indexOf('*') === 0) {
            ret += arguments[arg][k];
          } else {
            ret += k + ':' + arguments[arg][k] + ';';
          }
        }
      }
    }

    return ret;
  },
  normalizeHex: function (hex) {
    if (hex.indexOf('0x') === 0) {
      hex = hex.replace('0x', '');
    }

    hex = hex.replace(/^0+/, '');
    return '0x' + hex;
  },
  normalizeHexAddress: function (hex) {
    if (hex.indexOf('0x') === 0) hex = hex.replace('0x', '');

    if (hex.length >= 40) {
      const reg = /(.{40})$/.exec(hex);

      if (reg) {
        return '0x' + reg[0];
      }
    } else {
      return '0x' + new Array(40 - hex.length + 1).join('0') + hex;
    }
  },
  runInBrowser: function () {
    return typeof window !== 'undefined';
  }
};

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/init.js":
/*!********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/init.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

module.exports = {
  loadWeb3: function (url) {
    if (!url) url = 'http://localhost:8545';
    const web3 = new Web3();
    web3.setProvider(new web3.providers.HttpProvider(url));
    this.extend(web3);
    return web3;
  },
  extendWeb3: function (web3) {
    this.extend(web3);
  },
  setProvider: function (web3, url) {
    web3.setProvider(new web3.providers.HttpProvider(url));
  },
  web3DebugNode: function (network) {
    if (web3DebugNodes[network]) {
      return this.loadWeb3(web3DebugNodes[network]);
    }

    return null;
  },
  extend: function (web3) {
    if (!web3.extend) {
      return;
    } // DEBUG


    const methods = [];

    if (!(web3.debug && web3.debug.preimage)) {
      methods.push(new web3.extend.Method({
        name: 'preimage',
        call: 'debug_preimage',
        inputFormatter: [null],
        params: 1
      }));
    }

    if (!(web3.debug && web3.debug.traceTransaction)) {
      methods.push(new web3.extend.Method({
        name: 'traceTransaction',
        call: 'debug_traceTransaction',
        inputFormatter: [null, null],
        params: 2
      }));
    }

    if (!(web3.debug && web3.debug.storageRangeAt)) {
      methods.push(new web3.extend.Method({
        name: 'storageRangeAt',
        call: 'debug_storageRangeAt',
        inputFormatter: [null, null, null, null, null],
        params: 5
      }));
    }

    if (methods.length > 0) {
      web3.extend({
        property: 'debug',
        methods: methods,
        properties: []
      });
    }
  }
};
const web3DebugNodes = {
  'Main': 'https://gethmainnet.komputing.org',
  'Rinkeby': 'https://remix-rinkeby.ethdevops.io',
  'Ropsten': 'https://remix-ropsten.ethdevops.io',
  'Goerli': 'https://remix-goerli.ethdevops.io',
  'Kovan': 'https://remix-kovan.ethdevops.io'
};

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/offsetToLineColumnConverter.js":
/*!*******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/offsetToLineColumnConverter.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const SourceMappingDecoder = __webpack_require__(/*! ./sourceMappingDecoder */ "../../../dist/libs/remix-lib/src/sourceMappingDecoder.js");

function offsetToColumnConverter(compilerEvent) {
  this.lineBreakPositionsByContent = {};
  this.sourceMappingDecoder = new SourceMappingDecoder();
  var self = this;

  if (compilerEvent) {
    compilerEvent.register('compilationFinished', (success, data, source) => {
      self.clear();
    });
  }
}

offsetToColumnConverter.prototype.offsetToLineColumn = function (rawLocation, file, sources, asts) {
  if (!this.lineBreakPositionsByContent[file]) {
    for (let filename in asts) {
      const source = asts[filename]; // source id was string before. in newer versions it has been changed to an integer so we need to check the type here

      if (typeof source.id === 'string') source.id = parseInt(source.id, 10);

      if (source.id === file) {
        this.lineBreakPositionsByContent[file] = this.sourceMappingDecoder.getLinebreakPositions(sources[filename].content);
        break;
      }
    }
  }

  return this.sourceMappingDecoder.convertOffsetToLineColumn(rawLocation, this.lineBreakPositionsByContent[file]);
};

offsetToColumnConverter.prototype.clear = function () {
  this.lineBreakPositionsByContent = {};
};

module.exports = offsetToColumnConverter;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/sourceLocationTracker.js":
/*!*************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/sourceLocationTracker.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventManager = __webpack_require__(/*! ./eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

const helper = __webpack_require__(/*! ./helpers/traceHelper */ "../../../dist/libs/remix-lib/src/helpers/traceHelper.js");

const SourceMappingDecoder = __webpack_require__(/*! ./sourceMappingDecoder */ "../../../dist/libs/remix-lib/src/sourceMappingDecoder.js");

const util = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-lib/src/util.js");
/**
 * Process the source code location for the current executing bytecode
 */


function SourceLocationTracker(_codeManager) {
  this.codeManager = _codeManager;
  this.event = new EventManager();
  this.sourceMappingDecoder = new SourceMappingDecoder();
  this.sourceMapByAddress = {};
}
/**
 * Return the source location associated with the given @arg index
 *
 * @param {String} address - contract address from which the source location is retrieved
 * @param {Int} index - index in the instruction list from where the source location is retrieved
 * @param {Object} contractDetails - AST of compiled contracts
 * @param {Function} cb - callback function
 */


SourceLocationTracker.prototype.getSourceLocationFromInstructionIndex = function (address, index, contracts, cb) {
  extractSourceMap(this, this.codeManager, address, contracts, (error, sourceMap) => {
    if (error) {
      cb(error);
    } else {
      cb(null, this.sourceMappingDecoder.atIndex(index, sourceMap));
    }
  });
};
/**
 * Return the source location associated with the given @arg pc
 *
 * @param {String} address - contract address from which the source location is retrieved
 * @param {Int} vmtraceStepIndex - index of the current code in the vmtrace
 * @param {Object} contractDetails - AST of compiled contracts
 * @param {Function} cb - callback function
 */


SourceLocationTracker.prototype.getSourceLocationFromVMTraceIndex = function (address, vmtraceStepIndex, contracts, cb) {
  extractSourceMap(this, this.codeManager, address, contracts, (error, sourceMap) => {
    if (!error) {
      this.codeManager.getInstructionIndex(address, vmtraceStepIndex, (error, index) => {
        if (error) {
          cb(error);
        } else {
          cb(null, this.sourceMappingDecoder.atIndex(index, sourceMap));
        }
      });
    } else {
      cb(error);
    }
  });
};

SourceLocationTracker.prototype.clearCache = function () {
  this.sourceMapByAddress = {};
};

function getSourceMap(address, code, contracts) {
  const isCreation = helper.isContractCreation(address);
  let bytes;

  for (let file in contracts) {
    for (let contract in contracts[file]) {
      const bytecode = contracts[file][contract].evm.bytecode;
      const deployedBytecode = contracts[file][contract].evm.deployedBytecode;
      if (!deployedBytecode) continue;
      bytes = isCreation ? bytecode.object : deployedBytecode.object;

      if (util.compareByteCode(code, '0x' + bytes)) {
        return isCreation ? bytecode.sourceMap : deployedBytecode.sourceMap;
      }
    }
  }

  return null;
}

function extractSourceMap(self, codeManager, address, contracts, cb) {
  if (self.sourceMapByAddress[address]) return cb(null, self.sourceMapByAddress[address]);
  codeManager.getCode(address, (error, result) => {
    if (!error) {
      const sourceMap = getSourceMap(address, result.bytecode, contracts);

      if (sourceMap) {
        if (!helper.isContractCreation(address)) self.sourceMapByAddress[address] = sourceMap;
        cb(null, sourceMap);
      } else {
        cb('no sourcemap associated with the code ' + address);
      }
    } else {
      cb(error);
    }
  });
}

module.exports = SourceLocationTracker;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/sourceMappingDecoder.js":
/*!************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/sourceMappingDecoder.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const util = __webpack_require__(/*! ./util */ "../../../dist/libs/remix-lib/src/util.js");

const AstWalker = __webpack_require__(/*! ./astWalker */ "../../../dist/libs/remix-lib/src/astWalker.js");
/**
 * Decompress the source mapping given by solc-bin.js
 */


function SourceMappingDecoder() {// s:l:f:j
}
/**
 * get a list of nodes that are at the given @arg position
 *
 * @param {String} astNodeType      - type of node to return
 * @param {Int} position     - cursor position
 * @return {Object} ast object given by the compiler
 */


SourceMappingDecoder.prototype.nodesAtPosition = nodesAtPosition;
/**
 * Decode the source mapping for the given @arg index
 *
 * @param {Integer} index      - source mapping index to decode
 * @param {String} mapping     - compressed source mapping given by solc-bin
 * @return {Object} returns the decompressed source mapping for the given index {start, length, file, jump}
 */

SourceMappingDecoder.prototype.atIndex = atIndex;
/**
 * Decode the given @arg value
 *
 * @param {string} value      - source location to decode ( should be start:length:file )
 * @return {Object} returns the decompressed source mapping {start, length, file}
 */

SourceMappingDecoder.prototype.decode = function (value) {
  if (value) {
    value = value.split(':');
    return {
      start: parseInt(value[0]),
      length: parseInt(value[1]),
      file: parseInt(value[2])
    };
  }
};
/**
 * Decode the source mapping for the given compressed mapping
 *
 * @param {String} mapping     - compressed source mapping given by solc-bin
 * @return {Array} returns the decompressed source mapping. Array of {start, length, file, jump}
 */


SourceMappingDecoder.prototype.decompressAll = function (mapping) {
  const map = mapping.split(';');
  const ret = [];

  for (let k in map) {
    const compressed = map[k].split(':');
    const sourceMap = {
      start: compressed[0] ? parseInt(compressed[0]) : ret[ret.length - 1].start,
      length: compressed[1] ? parseInt(compressed[1]) : ret[ret.length - 1].length,
      file: compressed[2] ? parseInt(compressed[2]) : ret[ret.length - 1].file,
      jump: compressed[3] ? compressed[3] : ret[ret.length - 1].jump
    };
    ret.push(sourceMap);
  }

  return ret;
};
/**
  * Retrieve line/column position of each source char
  *
  * @param {String} source - contract source code
  * @return {Array} returns an array containing offset of line breaks
  */


SourceMappingDecoder.prototype.getLinebreakPositions = function (source) {
  const ret = [];

  for (let pos = source.indexOf('\n'); pos >= 0; pos = source.indexOf('\n', pos + 1)) {
    ret.push(pos);
  }

  return ret;
};
/**
 * Retrieve the line/column position for the given source mapping
 *
 * @param {Object} sourceLocation - object containing attributes {source} and {length}
 * @param {Array} lineBreakPositions - array returned by the function 'getLinebreakPositions'
 * @return {Object} returns an object {start: {line, column}, end: {line, column}} (line/column count start at 0)
 */


SourceMappingDecoder.prototype.convertOffsetToLineColumn = function (sourceLocation, lineBreakPositions) {
  if (sourceLocation.start >= 0 && sourceLocation.length >= 0) {
    return {
      start: convertFromCharPosition(sourceLocation.start, lineBreakPositions),
      end: convertFromCharPosition(sourceLocation.start + sourceLocation.length, lineBreakPositions)
    };
  } else {
    return {
      start: null,
      end: null
    };
  }
};
/**
 * Retrieve the first @arg astNodeType that include the source map at arg instIndex
 *
 * @param {String} astNodeType - node type that include the source map instIndex
 * @param {String} instIndex - instruction index used to retrieve the source map
 * @param {String} sourceMap - source map given by the compilation result
 * @param {Object} ast - ast given by the compilation result
 */


SourceMappingDecoder.prototype.findNodeAtInstructionIndex = findNodeAtInstructionIndex;

function convertFromCharPosition(pos, lineBreakPositions) {
  let line = util.findLowerBound(pos, lineBreakPositions);

  if (lineBreakPositions[line] !== pos) {
    line = line + 1;
  }

  const beginColumn = line === 0 ? 0 : lineBreakPositions[line - 1] + 1;
  const column = pos - beginColumn;
  return {
    line: line,
    column: column
  };
}

function sourceLocationFromAstNode(astNode) {
  if (astNode.src) {
    const split = astNode.src.split(':');
    return {
      start: parseInt(split[0]),
      length: parseInt(split[1]),
      file: parseInt(split[2])
    };
  }

  return null;
}

function findNodeAtInstructionIndex(astNodeType, instIndex, sourceMap, ast) {
  const sourceLocation = atIndex(instIndex, sourceMap);
  return findNodeAtSourceLocation(astNodeType, sourceLocation, ast);
}

function findNodeAtSourceLocation(astNodeType, sourceLocation, ast) {
  const astWalker = new AstWalker();
  const callback = {};
  let found = null;

  callback['*'] = function (node) {
    const nodeLocation = sourceLocationFromAstNode(node);

    if (!nodeLocation) {
      return true;
    }

    if (nodeLocation.start <= sourceLocation.start && nodeLocation.start + nodeLocation.length >= sourceLocation.start + sourceLocation.length) {
      if (astNodeType === node.name) {
        found = node;
        return false;
      } else {
        return true;
      }
    } else {
      return false;
    }
  };

  astWalker.walk(ast.legacyAST, callback);
  return found;
}

function nodesAtPosition(astNodeType, position, ast) {
  const astWalker = new AstWalker();
  const callback = {};
  const found = [];

  callback['*'] = function (node) {
    var nodeLocation = sourceLocationFromAstNode(node);

    if (!nodeLocation) {
      return;
    }

    if (nodeLocation.start <= position && nodeLocation.start + nodeLocation.length >= position) {
      if (!astNodeType || astNodeType === node.name) {
        found.push(node);
        if (astNodeType) return false;
      }

      return true;
    } else {
      return false;
    }
  };

  astWalker.walk(ast.legacyAST, callback);
  return found;
}
/**
 * starts with the given @arg index and move backward until it can find all the values for start, length, file, jump
 * if `file === -1` then the value of the sourcemap should be taken from the previous step,
 * because some steps are internal subroutine for the compiler and doesn't link to any high level code.
 *
 * Solidity source maps format is
 *  - start:length:file:jump
 *  - jump can be 'i', 'o' or '-' (jump 'in' or 'out' of a function)
 *  - if no value is specified ( e.g "5:2" - no mention of 'file' and 'jump' ), actual values are the one of the step before
 *  - if the file (3rd value) has -1, the source maps should be discarded
 *
 *  @param Int index - index in the bytecode to decode source mapping from
 *  @param Array mapping - source maps returned by the compiler. e.g 121:3741:0:-:0;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;121:3741:0;;;;;;;
 *  @return Object { start, length, file, jump }
 */


function atIndex(index, mapping) {
  let ret = {};
  const map = mapping.split(';');

  if (index >= map.length) {
    index = map.length - 1;
  }

  for (let k = index; k >= 0; k--) {
    let current = map[k];

    if (!current.length) {
      continue;
    }

    current = current.split(':');

    if (current[2] === '-1') {
      // if the current step has -1 for the file attribute, we discard it
      // case: 'file' is not yet assigned, while processing the srcmap (reverse looping) to find 'start', 'length' (etc..), we tumble on -1 for the file.
      // in that case the step has to be discarded
      if (ret.file === undefined) ret = {};
      continue;
    }

    if (ret.start === undefined && current[0] && current[0] !== '-1' && current[0].length) {
      ret.start = parseInt(current[0]);
    }

    if (ret.length === undefined && current[1] && current[1] !== '-1' && current[1].length) {
      ret.length = parseInt(current[1]);
    }

    if (ret.file === undefined && current[2] && current[2] !== '-1' && current[2].length) {
      ret.file = parseInt(current[2]);
    }

    if (ret.jump === undefined && current[3] && current[3].length) {
      ret.jump = current[3];
    }

    if (ret.start !== undefined && ret.length !== undefined && ret.file !== undefined && ret.jump !== undefined) {
      break;
    }
  }

  return ret;
}

module.exports = SourceMappingDecoder;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/storage.js":
/*!***********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/storage.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function Storage(prefix) {
  this.exists = function (name) {
    if (typeof window !== 'undefined') {
      return this.get(name) !== null;
    }
  };

  this.get = function (name) {
    if (typeof window !== 'undefined') {
      return window.localStorage.getItem(prefix + name);
    }
  };

  this.set = function (name, content) {
    try {
      if (typeof window !== 'undefined') {
        window.localStorage.setItem(prefix + name, content);
      }
    } catch (exception) {
      return false;
    }

    return true;
  };

  this.remove = function (name) {
    if (typeof window !== 'undefined') {
      window.localStorage.removeItem(prefix + name);
      return true;
    } else {
      return true;
    }
  };

  this.rename = function (originalName, newName) {
    const content = this.get(originalName);

    if (!this.set(newName, content)) {
      return false;
    }

    this.remove(originalName);
    return true;
  };

  function safeKeys() {
    // NOTE: this is a workaround for some browsers
    if (typeof window !== 'undefined') {
      return Object.keys(window.localStorage).filter(function (item) {
        return item !== null && item !== undefined;
      });
    } else {
      return [];
    }
  }

  this.keys = function () {
    return safeKeys() // filter any names not including the prefix
    .filter(function (item) {
      return item.indexOf(prefix, 0) === 0;
    }) // remove prefix from filename and add the 'browser' path
    .map(function (item) {
      return item.substr(prefix.length);
    });
  }; // on startup, upgrade the old storage layout


  if (typeof window !== 'undefined') {
    safeKeys().forEach(function (name) {
      if (name.indexOf('sol-cache-file-', 0) === 0) {
        var content = window.localStorage.getItem(name);
        window.localStorage.setItem(name.replace(/^sol-cache-file-/, 'sol:'), content);
        window.localStorage.removeItem(name);
      }
    });
  } // remove obsolete key


  if (typeof window !== 'undefined') {
    window.localStorage.removeItem('editor-size-cache');
  }
}

module.exports = Storage;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/trace/traceAnalyser.js":
/*!***********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/trace/traceAnalyser.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const traceHelper = __webpack_require__(/*! ../helpers/traceHelper */ "../../../dist/libs/remix-lib/src/helpers/traceHelper.js");

function TraceAnalyser(_cache) {
  this.traceCache = _cache;
  this.trace = null;
}

TraceAnalyser.prototype.analyse = function (trace, tx, callback) {
  this.trace = trace;
  this.traceCache.pushStoreChanges(0, tx.to);
  let context = {
    storageContext: [tx.to],
    currentCallIndex: 0,
    lastCallIndex: 0
  };
  const callStack = [tx.to];
  this.traceCache.pushCall(trace[0], 0, callStack[0], callStack.slice(0));

  if (traceHelper.isContractCreation(tx.to)) {
    this.traceCache.pushContractCreation(tx.to, tx.input);
  }

  this.buildCalldata(0, this.trace[0], tx, true);

  for (let k = 0; k < this.trace.length; k++) {
    const step = this.trace[k];
    this.buildMemory(k, step);
    context = this.buildDepth(k, step, tx, callStack, context);
    context = this.buildStorage(k, step, context);
    this.buildReturnValues(k, step);
  }

  callback(null, true);
};

TraceAnalyser.prototype.buildReturnValues = function (index, step) {
  if (traceHelper.isReturnInstruction(step)) {
    let offset = 2 * parseInt(step.stack[step.stack.length - 1], 16);
    const size = 2 * parseInt(step.stack[step.stack.length - 2], 16);
    const memory = this.trace[this.traceCache.memoryChanges[this.traceCache.memoryChanges.length - 1]].memory;
    const noOfReturnParams = size / 64;
    const memoryInString = memory.join('');
    let returnParamsObj = [];

    for (let i = 0; i < noOfReturnParams; i++) {
      returnParamsObj.push('0x' + memoryInString.substring(offset, offset + 64));
      offset += 64;
    }

    this.traceCache.pushReturnValue(index, returnParamsObj);
  }
};

TraceAnalyser.prototype.buildCalldata = function (index, step, tx, newContext) {
  let calldata = '';

  if (index === 0) {
    calldata = tx.input;
    this.traceCache.pushCallDataChanges(index, calldata);
  } else if (!newContext) {
    const lastCall = this.traceCache.callsData[this.traceCache.callDataChanges[this.traceCache.callDataChanges.length - 2]];
    this.traceCache.pushCallDataChanges(index + 1, lastCall);
  } else {
    const memory = this.trace[this.traceCache.memoryChanges[this.traceCache.memoryChanges.length - 1]].memory;
    const callStep = this.trace[index];
    const stack = callStep.stack;
    let offset = '';
    let size = '';

    if (callStep.op === 'DELEGATECALL') {
      offset = 2 * parseInt(stack[stack.length - 3], 16);
      size = 2 * parseInt(stack[stack.length - 4], 16);
    } else {
      offset = 2 * parseInt(stack[stack.length - 4], 16);
      size = 2 * parseInt(stack[stack.length - 5], 16);
    }

    calldata = '0x' + memory.join('').substr(offset, size);
    this.traceCache.pushCallDataChanges(index + 1, calldata);
  }
};

TraceAnalyser.prototype.buildMemory = function (index, step) {
  if (step.memory) {
    this.traceCache.pushMemoryChanges(index);
  }
};

TraceAnalyser.prototype.buildStorage = function (index, step, context) {
  if (traceHelper.newContextStorage(step) && !traceHelper.isCallToPrecompiledContract(index, this.trace)) {
    const calledAddress = traceHelper.resolveCalledAddress(index, this.trace);

    if (calledAddress) {
      context.storageContext.push(calledAddress);
    } else {
      console.log('unable to build storage changes. ' + index + ' does not match with a CALL. storage changes will be corrupted');
    }

    this.traceCache.pushStoreChanges(index + 1, context.storageContext[context.storageContext.length - 1]);
  } else if (traceHelper.isSSTOREInstruction(step)) {
    this.traceCache.pushStoreChanges(index + 1, context.storageContext[context.storageContext.length - 1], step.stack[step.stack.length - 1], step.stack[step.stack.length - 2]);
  } else if (traceHelper.isReturnInstruction(step) || traceHelper.isStopInstruction(step)) {
    context.storageContext.pop();
    this.traceCache.pushStoreChanges(index + 1, context.storageContext[context.storageContext.length - 1]);
  } else if (traceHelper.isRevertInstruction(step)) {
    context.storageContext.pop();
    this.traceCache.resetStoreChanges();
  }

  return context;
};

TraceAnalyser.prototype.buildDepth = function (index, step, tx, callStack, context) {
  if (traceHelper.isCallInstruction(step) && !traceHelper.isCallToPrecompiledContract(index, this.trace)) {
    let newAddress;

    if (traceHelper.isCreateInstruction(step)) {
      newAddress = traceHelper.contractCreationToken(index);
      callStack.push(newAddress);
      const lastMemoryChange = this.traceCache.memoryChanges[this.traceCache.memoryChanges.length - 1];
      this.traceCache.pushContractCreationFromMemory(index, newAddress, this.trace, lastMemoryChange);
    } else {
      newAddress = traceHelper.resolveCalledAddress(index, this.trace);

      if (newAddress) {
        callStack.push(newAddress);
      } else {
        console.log('unable to build depth changes. ' + index + ' does not match with a CALL. depth changes will be corrupted');
      }
    }

    this.traceCache.pushCall(step, index + 1, newAddress, callStack.slice(0));
    this.buildCalldata(index, step, tx, true);
    this.traceCache.pushSteps(index, context.currentCallIndex);
    context.lastCallIndex = context.currentCallIndex;
    context.currentCallIndex = 0;
  } else if (traceHelper.isReturnInstruction(step) || traceHelper.isStopInstruction(step) || step.error || step.invalidDepthChange) {
    if (index < this.trace.length) {
      callStack.pop();
      this.traceCache.pushCall(step, index + 1, null, callStack.slice(0), step.error || step.invalidDepthChange);
      this.buildCalldata(index, step, tx, false);
      this.traceCache.pushSteps(index, context.currentCallIndex);
      context.currentCallIndex = context.lastCallIndex + 1;
    }
  } else {
    this.traceCache.pushSteps(index, context.currentCallIndex);
    context.currentCallIndex++;
  }

  return context;
};

module.exports = TraceAnalyser;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/trace/traceCache.js":
/*!********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/trace/traceCache.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const helper = __webpack_require__(/*! ../util */ "../../../dist/libs/remix-lib/src/util.js");

function TraceCache() {
  this.init();
}

TraceCache.prototype.init = function () {
  // ...Changes contains index in the vmtrace of the corresponding changes
  this.returnValues = {};
  this.currentCall = null;
  this.callsTree = null;
  this.callsData = {};
  this.contractCreation = {};
  this.steps = {};
  this.addresses = [];
  this.callDataChanges = [];
  this.memoryChanges = [];
  this.storageChanges = [];
  this.sstore = {}; // all sstore occurence in the trace
};

TraceCache.prototype.pushSteps = function (index, currentCallIndex) {
  this.steps[index] = currentCallIndex;
};

TraceCache.prototype.pushCallDataChanges = function (value, calldata) {
  this.callDataChanges.push(value);
  this.callsData[value] = calldata;
};

TraceCache.prototype.pushMemoryChanges = function (value) {
  this.memoryChanges.push(value);
}; // outOfGas has been removed because gas left logging is apparently made differently
// in the vm/geth/eth. TODO add the error property (with about the error in all clients)


TraceCache.prototype.pushCall = function (step, index, address, callStack, reverted) {
  let validReturnStep = step.op === 'RETURN' || step.op === 'STOP';

  if (validReturnStep || reverted) {
    if (this.currentCall) {
      this.currentCall.call.return = index - 1;

      if (!validReturnStep) {
        this.currentCall.call.reverted = reverted;
      }

      var parent = this.currentCall.parent;
      this.currentCall = parent ? {
        call: parent.call,
        parent: parent.parent
      } : null;
    }
  } else {
    let call = {
      op: step.op,
      address: address,
      callStack: callStack,
      calls: {},
      start: index
    };
    this.addresses.push(address);

    if (this.currentCall) {
      this.currentCall.call.calls[index] = call;
    } else {
      this.callsTree = {
        call: call
      };
    }

    this.currentCall = {
      call: call,
      parent: this.currentCall
    };
  }
};

TraceCache.prototype.pushReturnValue = function (step, value) {
  this.returnValues[step] = value;
};

TraceCache.prototype.pushContractCreationFromMemory = function (index, token, trace, lastMemoryChange) {
  const memory = trace[lastMemoryChange].memory;
  const stack = trace[index].stack;
  const offset = 2 * parseInt(stack[stack.length - 2], 16);
  const size = 2 * parseInt(stack[stack.length - 3], 16);
  this.contractCreation[token] = '0x' + memory.join('').substr(offset, size);
};

TraceCache.prototype.pushContractCreation = function (token, code) {
  this.contractCreation[token] = code;
};

TraceCache.prototype.resetStoreChanges = function (index, address, key, value) {
  this.sstore = {};
  this.storageChanges = [];
};

TraceCache.prototype.pushStoreChanges = function (index, address, key, value) {
  this.sstore[index] = {
    'address': address,
    'key': key,
    'value': value,
    'hashedKey': helper.sha3_256(key)
  };
  this.storageChanges.push(index);
};

TraceCache.prototype.accumulateStorageChanges = function (index, address, storage) {
  const ret = Object.assign({}, storage);

  for (var k in this.storageChanges) {
    const changesIndex = this.storageChanges[k];

    if (changesIndex > index) {
      return ret;
    }

    var sstore = this.sstore[changesIndex];

    if (sstore.address === address && sstore.key) {
      ret[sstore.hashedKey] = {
        key: sstore.key,
        value: sstore.value
      };
    }
  }

  return ret;
};

module.exports = TraceCache;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/trace/traceManager.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/trace/traceManager.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const TraceAnalyser = __webpack_require__(/*! ./traceAnalyser */ "../../../dist/libs/remix-lib/src/trace/traceAnalyser.js");

const TraceRetriever = __webpack_require__(/*! ./traceRetriever */ "../../../dist/libs/remix-lib/src/trace/traceRetriever.js");

const TraceCache = __webpack_require__(/*! ./traceCache */ "../../../dist/libs/remix-lib/src/trace/traceCache.js");

const TraceStepManager = __webpack_require__(/*! ./traceStepManager */ "../../../dist/libs/remix-lib/src/trace/traceStepManager.js");

const traceHelper = __webpack_require__(/*! ../helpers/traceHelper */ "../../../dist/libs/remix-lib/src/helpers/traceHelper.js");

const util = __webpack_require__(/*! ../util */ "../../../dist/libs/remix-lib/src/util.js");

function TraceManager(options) {
  this.web3 = options.web3;
  this.isLoading = false;
  this.trace = null;
  this.traceCache = new TraceCache();
  this.traceAnalyser = new TraceAnalyser(this.traceCache);
  this.traceRetriever = new TraceRetriever({
    web3: this.web3
  });
  this.traceStepManager = new TraceStepManager(this.traceAnalyser);
  this.tx;
} // init section


TraceManager.prototype.resolveTrace = function (tx, callback) {
  this.tx = tx;
  this.init();
  if (!this.web3) callback('web3 not loaded', false);
  this.isLoading = true;
  var self = this;
  this.traceRetriever.getTrace(tx.hash, (error, result) => {
    if (error) {
      console.log(error);
      self.isLoading = false;
      callback(error, false);
    } else {
      if (result.structLogs.length > 0) {
        self.trace = result.structLogs;
        self.traceAnalyser.analyse(result.structLogs, tx, function (error, result) {
          if (error) {
            self.isLoading = false;
            console.log(error);
            callback(error, false);
          } else {
            self.isLoading = false;
            callback(null, true);
          }
        });
      } else {
        var mes = tx.hash + ' is not a contract invocation or contract creation.';
        console.log(mes);
        self.isLoading = false;
        callback(mes, false);
      }
    }
  });
};

TraceManager.prototype.init = function () {
  this.trace = null;
  this.traceCache.init();
}; // API section


TraceManager.prototype.inRange = function (step) {
  return this.isLoaded() && step >= 0 && step < this.trace.length;
};

TraceManager.prototype.isLoaded = function () {
  return !this.isLoading && this.trace !== null;
};

TraceManager.prototype.getLength = function (callback) {
  if (!this.trace) {
    callback('no trace available', null);
  } else {
    callback(null, this.trace.length);
  }
};

TraceManager.prototype.accumulateStorageChanges = function (index, address, storageOrigin, callback) {
  const storage = this.traceCache.accumulateStorageChanges(index, address, storageOrigin);
  callback(null, storage);
};

TraceManager.prototype.getAddresses = function (callback) {
  callback(null, this.traceCache.addresses);
};

TraceManager.prototype.getCallDataAt = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  const callDataChange = util.findLowerBoundValue(stepIndex, this.traceCache.callDataChanges);
  if (callDataChange === null) return callback('no calldata found', null);
  callback(null, [this.traceCache.callsData[callDataChange]]);
};

TraceManager.prototype.buildCallPath = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  const callsPath = util.buildCallPath(stepIndex, this.traceCache.callsTree.call);
  if (callsPath === null) return callback('no call path built', null);
  callback(null, callsPath);
};

TraceManager.prototype.getCallStackAt = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  const call = util.findCall(stepIndex, this.traceCache.callsTree.call);
  if (call === null) return callback('no callstack found', null);
  callback(null, call.callStack);
};

TraceManager.prototype.getStackAt = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  let stack;

  if (this.trace[stepIndex] && this.trace[stepIndex].stack) {
    // there's always a stack
    stack = this.trace[stepIndex].stack.slice(0);
    stack.reverse();
    callback(null, stack);
  } else {
    callback('no stack found', null);
  }
};

TraceManager.prototype.getLastCallChangeSince = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  const callChange = util.findCall(stepIndex, this.traceCache.callsTree.call);

  if (callChange === null) {
    callback(null, 0);
  } else {
    callback(null, callChange);
  }
};

TraceManager.prototype.getCurrentCalledAddressAt = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  this.getLastCallChangeSince(stepIndex, function (error, resp) {
    if (error) {
      callback(error, null);
    } else {
      if (resp) {
        callback(null, resp.address);
      } else {
        callback('unable to get current called address. ' + stepIndex + ' does not match with a CALL');
      }
    }
  });
};

TraceManager.prototype.getContractCreationCode = function (token, callback) {
  if (this.traceCache.contractCreation[token]) {
    callback(null, this.traceCache.contractCreation[token]);
  } else {
    callback('no contract creation named ' + token, null);
  }
};

TraceManager.prototype.getMemoryAt = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  const lastChanges = util.findLowerBoundValue(stepIndex, this.traceCache.memoryChanges);
  if (lastChanges === null) return callback('no memory found', null);
  callback(null, this.trace[lastChanges].memory);
};

TraceManager.prototype.getCurrentPC = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  callback(null, this.trace[stepIndex].pc);
};

TraceManager.prototype.getReturnValue = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  if (!this.traceCache.returnValues[stepIndex]) {
    callback('current step is not a return step');
  } else {
    callback(null, this.traceCache.returnValues[stepIndex]);
  }
};

TraceManager.prototype.getCurrentStep = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  callback(null, this.traceCache.steps[stepIndex]);
};

TraceManager.prototype.getMemExpand = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  callback(null, this.trace[stepIndex].memexpand ? this.trace[stepIndex].memexpand : '');
};

TraceManager.prototype.getStepCost = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  callback(null, this.trace[stepIndex].gasCost);
};

TraceManager.prototype.getRemainingGas = function (stepIndex, callback) {
  const check = this.checkRequestedStep(stepIndex);

  if (check) {
    return callback(check, null);
  }

  callback(null, this.trace[stepIndex].gas);
};

TraceManager.prototype.isCreationStep = function (stepIndex) {
  return traceHelper.isCreateInstruction(this.trace[stepIndex]);
}; // step section


TraceManager.prototype.findStepOverBack = function (currentStep) {
  return this.traceStepManager.findStepOverBack(currentStep);
};

TraceManager.prototype.findStepOverForward = function (currentStep) {
  return this.traceStepManager.findStepOverForward(currentStep);
};

TraceManager.prototype.findNextCall = function (currentStep) {
  return this.traceStepManager.findNextCall(currentStep);
};

TraceManager.prototype.findStepOut = function (currentStep) {
  return this.traceStepManager.findStepOut(currentStep);
}; // util


TraceManager.prototype.checkRequestedStep = function (stepIndex) {
  if (!this.trace) {
    return 'trace not loaded';
  } else if (stepIndex >= this.trace.length) {
    return 'trace smaller than requested';
  }

  return undefined;
};

TraceManager.prototype.waterfall = function (calls, stepindex, cb) {
  let ret = [];
  let retError = null;

  for (var call in calls) {
    calls[call].apply(this, [stepindex, function (error, result) {
      retError = error;
      ret.push({
        error: error,
        value: result
      });
    }]);
  }

  cb(retError, ret);
};

module.exports = TraceManager;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/trace/traceRetriever.js":
/*!************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/trace/traceRetriever.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function TraceRetriever(options) {
  this.web3 = options.web3;
}

TraceRetriever.prototype.getTrace = function (txHash, callback) {
  const options = {
    disableStorage: true,
    disableMemory: false,
    disableStack: false,
    fullStorage: false
  };
  this.web3.debug.traceTransaction(txHash, options, function (error, result) {
    callback(error, result);
  });
};

module.exports = TraceRetriever;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/trace/traceStepManager.js":
/*!**************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/trace/traceStepManager.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const traceHelper = __webpack_require__(/*! ../helpers/traceHelper */ "../../../dist/libs/remix-lib/src/helpers/traceHelper.js");

const util = __webpack_require__(/*! ../util */ "../../../dist/libs/remix-lib/src/util.js");

function TraceStepManager(_traceAnalyser) {
  this.traceAnalyser = _traceAnalyser;
}

TraceStepManager.prototype.isCallInstruction = function (index) {
  const state = this.traceAnalyser.trace[index];
  return traceHelper.isCallInstruction(state) && !traceHelper.isCallToPrecompiledContract(index, this.traceAnalyser.trace);
};

TraceStepManager.prototype.isReturnInstruction = function (index) {
  const state = this.traceAnalyser.trace[index];
  return traceHelper.isReturnInstruction(state);
};

TraceStepManager.prototype.findStepOverBack = function (currentStep) {
  if (this.isReturnInstruction(currentStep)) {
    const call = util.findCall(currentStep, this.traceAnalyser.traceCache.callsTree.call);
    return call.start > 0 ? call.start - 1 : 0;
  } else {
    return currentStep > 0 ? currentStep - 1 : 0;
  }
};

TraceStepManager.prototype.findStepOverForward = function (currentStep) {
  if (this.isCallInstruction(currentStep)) {
    const call = util.findCall(currentStep + 1, this.traceAnalyser.traceCache.callsTree.call);
    return call.return + 1 < this.traceAnalyser.trace.length ? call.return + 1 : this.traceAnalyser.trace.length - 1;
  } else {
    return this.traceAnalyser.trace.length >= currentStep + 1 ? currentStep + 1 : currentStep;
  }
};

TraceStepManager.prototype.findNextCall = function (currentStep) {
  const call = util.findCall(currentStep, this.traceAnalyser.traceCache.callsTree.call);
  const subCalls = Object.keys(call.calls);

  if (subCalls.length) {
    var callStart = util.findLowerBound(currentStep, subCalls) + 1;

    if (subCalls.length > callStart) {
      return subCalls[callStart] - 1;
    } else {
      return currentStep;
    }
  } else {
    return currentStep;
  }
};

TraceStepManager.prototype.findStepOut = function (currentStep) {
  const call = util.findCall(currentStep, this.traceAnalyser.traceCache.callsTree.call);
  return call.return;
};

module.exports = TraceStepManager;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/universalDapp.js":
/*!*****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/universalDapp.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

const {
  BN,
  privateToAddress,
  isValidPrivate,
  stripHexPrefix,
  toChecksumAddress
} = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const crypto = __webpack_require__(/*! crypto */ "../../../node_modules/crypto-browserify/index.js");

const {
  EventEmitter
} = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

const TxRunner = __webpack_require__(/*! ./execution/txRunner */ "../../../dist/libs/remix-lib/src/execution/txRunner.js");

const txHelper = __webpack_require__(/*! ./execution/txHelper */ "../../../dist/libs/remix-lib/src/execution/txHelper.js");

const EventManager = __webpack_require__(/*! ./eventManager */ "../../../dist/libs/remix-lib/src/eventManager.js");

const defaultExecutionContext = __webpack_require__(/*! ./execution/execution-context */ "../../../dist/libs/remix-lib/src/execution/execution-context.js");

const {
  resultToRemixTx
} = __webpack_require__(/*! ./helpers/txResultHelper */ "../../../dist/libs/remix-lib/src/helpers/txResultHelper.js");

module.exports = class UniversalDApp {
  constructor(config, executionContext) {
    this.events = new EventEmitter();
    this.event = new EventManager(); // has a default for now for backwards compatability

    this.executionContext = executionContext || defaultExecutionContext;
    this.config = config;
    this.txRunner = new TxRunner({}, {
      config: config,
      detectNetwork: cb => {
        this.executionContext.detectNetwork(cb);
      },
      personalMode: () => {
        return this.executionContext.getProvider() === 'web3' ? this.config.get('settings/personal-mode') : false;
      }
    }, this.executionContext);
    this.accounts = {};
    this.executionContext.event.register('contextChanged', this.resetEnvironment.bind(this));
  } // TODO : event should be triggered by Udapp instead of TxListener

  /** Listen on New Transaction. (Cannot be done inside constructor because txlistener doesn't exist yet) */


  startListening(txlistener) {
    txlistener.event.register('newTransaction', tx => {
      this.events.emit('newTransaction', tx);
    });
  }

  resetEnvironment() {
    this.accounts = {};

    if (this.executionContext.isVM()) {
      this._addAccount('3cd7232cd6f3fc66a57a6bedc1a8ed6c228fff0a327e169c2bcc5e869ed49511', '0x56BC75E2D63100000');

      this._addAccount('2ac6c190b09897cd8987869cc7b918cfea07ee82038d492abce033c75c1b1d0c', '0x56BC75E2D63100000');

      this._addAccount('dae9801649ba2d95a21e688b56f77905e5667c44ce868ec83f82e838712a2c7a', '0x56BC75E2D63100000');

      this._addAccount('d74aa6d18aa79a05f3473dd030a97d3305737cbc8337d940344345c1f6b72eea', '0x56BC75E2D63100000');

      this._addAccount('71975fbf7fe448e004ac7ae54cad0a383c3906055a65468714156a07385e96ce', '0x56BC75E2D63100000');
    } // TODO: most params here can be refactored away in txRunner


    this.txRunner = new TxRunner(this.accounts, {
      // TODO: only used to check value of doNotShowTransactionConfirmationAgain property
      config: this.config,
      // TODO: to refactor, TxRunner already has access to executionContext
      detectNetwork: cb => {
        this.executionContext.detectNetwork(cb);
      },
      personalMode: () => {
        return this.executionContext.getProvider() === 'web3' ? this.config.get('settings/personal-mode') : false;
      }
    }, this.executionContext);
    this.txRunner.event.register('transactionBroadcasted', txhash => {
      this.executionContext.detectNetwork((error, network) => {
        if (error || !network) return;
        this.event.trigger('transactionBroadcasted', [txhash, network.name]);
      });
    });
  }

  resetAPI(transactionContextAPI) {
    this.transactionContextAPI = transactionContextAPI;
  }
  /**
   * Create a VM Account
   * @param {{privateKey: string, balance: string}} newAccount The new account to create
   */


  createVMAccount(newAccount) {
    const {
      privateKey,
      balance
    } = newAccount;

    if (this.executionContext.getProvider() !== 'vm') {
      throw new Error('plugin API does not allow creating a new account through web3 connection. Only vm mode is allowed');
    }

    this._addAccount(privateKey, balance);

    const privKey = Buffer.from(privateKey, 'hex');
    return '0x' + privateToAddress(privKey).toString('hex');
  }

  newAccount(password, passwordPromptCb, cb) {
    if (!this.executionContext.isVM()) {
      if (!this.config.get('settings/personal-mode')) {
        return cb('Not running in personal mode');
      }

      passwordPromptCb(passphrase => {
        this.executionContext.web3().personal.newAccount(passphrase, cb);
      });
    } else {
      let privateKey;

      do {
        privateKey = crypto.randomBytes(32);
      } while (!isValidPrivate(privateKey));

      this._addAccount(privateKey, '0x56BC75E2D63100000');

      cb(null, '0x' + privateToAddress(privateKey).toString('hex'));
    }
  }
  /** Add an account to the list of account (only for Javascript VM) */


  _addAccount(privateKey, balance) {
    if (!this.executionContext.isVM()) {
      throw new Error('_addAccount() cannot be called in non-VM mode');
    }

    if (this.accounts) {
      privateKey = Buffer.from(privateKey, 'hex');
      const address = privateToAddress(privateKey); // FIXME: we don't care about the callback, but we should still make this proper

      let stateManager = this.executionContext.vm().stateManager;
      stateManager.getAccount(address, (error, account) => {
        if (error) return console.log(error);
        account.balance = balance || '0xf00000000000000001';
        stateManager.putAccount(address, account, function cb(error) {
          if (error) console.log(error);
        });
      });
      this.accounts[toChecksumAddress('0x' + address.toString('hex'))] = {
        privateKey,
        nonce: 0
      };
    }
  }
  /** Return the list of accounts */


  getAccounts(cb) {
    return new Promise((resolve, reject) => {
      const provider = this.executionContext.getProvider();

      switch (provider) {
        case 'vm':
          {
            if (!this.accounts) {
              if (cb) cb('No accounts?');
              reject('No accounts?');
              return;
            }

            if (cb) cb(null, Object.keys(this.accounts));
            resolve(Object.keys(this.accounts));
          }
          break;

        case 'web3':
          {
            if (this.config.get('settings/personal-mode')) {
              return this.executionContext.web3().personal.getListAccounts((error, accounts) => {
                if (cb) cb(error, accounts);
                if (error) return reject(error);
                resolve(accounts);
              });
            } else {
              this.executionContext.web3().eth.getAccounts((error, accounts) => {
                if (cb) cb(error, accounts);
                if (error) return reject(error);
                resolve(accounts);
              });
            }
          }
          break;

        case 'injected':
          {
            this.executionContext.web3().eth.getAccounts((error, accounts) => {
              if (cb) cb(error, accounts);
              if (error) return reject(error);
              resolve(accounts);
            });
          }
      }
    });
  }
  /** Get the balance of an address */


  getBalance(address, cb) {
    address = stripHexPrefix(address);

    if (!this.executionContext.isVM()) {
      this.executionContext.web3().eth.getBalance(address, (err, res) => {
        if (err) {
          cb(err);
        } else {
          cb(null, res.toString(10));
        }
      });
    } else {
      if (!this.accounts) {
        return cb('No accounts?');
      }

      this.executionContext.vm().stateManager.getAccount(Buffer.from(address, 'hex'), (err, res) => {
        if (err) {
          cb('Account not found');
        } else {
          cb(null, new BN(res.balance).toString(10));
        }
      });
    }
  }
  /** Get the balance of an address, and convert wei to ether */


  getBalanceInEther(address, callback) {
    this.getBalance(address, (error, balance) => {
      if (error) {
        callback(error);
      } else {
        callback(null, this.executionContext.web3().utils.fromWei(balance, 'ether'));
      }
    });
  }

  pendingTransactionsCount() {
    return Object.keys(this.txRunner.pendingTxs).length;
  }
  /**
    * deploy the given contract
    *
    * @param {String} data    - data to send with the transaction ( return of txFormat.buildData(...) ).
    * @param {Function} callback    - callback.
    */


  createContract(data, confirmationCb, continueCb, promptCb, callback) {
    this.runTx({
      data: data,
      useCall: false
    }, confirmationCb, continueCb, promptCb, (error, txResult) => {
      // see universaldapp.js line 660 => 700 to check possible values of txResult (error case)
      callback(error, txResult);
    });
  }
  /**
    * call the current given contract
    *
    * @param {String} to    - address of the contract to call.
    * @param {String} data    - data to send with the transaction ( return of txFormat.buildData(...) ).
    * @param {Object} funAbi    - abi definition of the function to call.
    * @param {Function} callback    - callback.
    */


  callFunction(to, data, funAbi, confirmationCb, continueCb, promptCb, callback) {
    const useCall = funAbi.stateMutability === 'view' || funAbi.stateMutability === 'pure';
    this.runTx({
      to,
      data,
      useCall
    }, confirmationCb, continueCb, promptCb, (error, txResult) => {
      // see universaldapp.js line 660 => 700 to check possible values of txResult (error case)
      callback(error, txResult);
    });
  }
  /**
   * call the current given contract
   *
   * @param {String} to    - address of the contract to call.
   * @param {String} data    - data to send with the transaction ( return of txFormat.buildData(...) ).
   * @param {Function} callback    - callback.
   */


  sendRawTransaction(to, data, confirmationCb, continueCb, promptCb, callback) {
    this.runTx({
      to,
      data,
      useCall: false
    }, confirmationCb, continueCb, promptCb, (error, txResult) => {
      // see universaldapp.js line 660 => 700 to check possible values of txResult (error case)
      callback(error, txResult);
    });
  }

  context() {
    return this.executionContext.isVM() ? 'memory' : 'blockchain';
  }

  getABI(contract) {
    return txHelper.sortAbiFunction(contract.abi);
  }

  getFallbackInterface(contractABI) {
    return txHelper.getFallbackInterface(contractABI);
  }

  getReceiveInterface(contractABI) {
    return txHelper.getReceiveInterface(contractABI);
  }

  getInputs(funABI) {
    if (!funABI.inputs) {
      return '';
    }

    return txHelper.inputParametersDeclarationToString(funABI.inputs);
  }
  /**
   * This function send a tx only to javascript VM or testnet, will return an error for the mainnet
   * SHOULD BE TAKEN CAREFULLY!
   *
   * @param {Object} tx    - transaction.
   */


  sendTransaction(tx) {
    return new Promise((resolve, reject) => {
      this.executionContext.detectNetwork((error, network) => {
        if (error) return reject(error);

        if (network.name === 'Main' && network.id === '1') {
          return reject(new Error('It is not allowed to make this action against mainnet'));
        }

        this.silentRunTx(tx, (error, result) => {
          if (error) return reject(error);

          try {
            resolve(resultToRemixTx(result));
          } catch (e) {
            reject(e);
          }
        });
      });
    });
  }
  /**
   * This function send a tx without alerting the user (if mainnet or if gas estimation too high).
   * SHOULD BE TAKEN CAREFULLY!
   *
   * @param {Object} tx    - transaction.
   * @param {Function} callback    - callback.
   */


  silentRunTx(tx, cb) {
    this.txRunner.rawRun(tx, (network, tx, gasEstimation, continueTxExecution, cancelCb) => {
      continueTxExecution();
    }, (error, continueTxExecution, cancelCb) => {
      if (error) {
        cb(error);
      } else {
        continueTxExecution();
      }
    }, (okCb, cancelCb) => {
      okCb();
    }, cb);
  }

  runTx(args, confirmationCb, continueCb, promptCb, cb) {
    const self = this;
    async.waterfall([function getGasLimit(next) {
      if (self.transactionContextAPI.getGasLimit) {
        return self.transactionContextAPI.getGasLimit(next);
      }

      next(null, 3000000);
    }, function queryValue(gasLimit, next) {
      if (args.value) {
        return next(null, args.value, gasLimit);
      }

      if (args.useCall || !self.transactionContextAPI.getValue) {
        return next(null, 0, gasLimit);
      }

      self.transactionContextAPI.getValue(function (err, value) {
        next(err, value, gasLimit);
      });
    }, function getAccount(value, gasLimit, next) {
      if (args.from) {
        return next(null, args.from, value, gasLimit);
      }

      if (self.transactionContextAPI.getAddress) {
        return self.transactionContextAPI.getAddress(function (err, address) {
          next(err, address, value, gasLimit);
        });
      }

      self.getAccounts(function (err, accounts) {
        let address = accounts[0];
        if (err) return next(err);
        if (!address) return next('No accounts available');

        if (self.executionContext.isVM() && !self.accounts[address]) {
          return next('Invalid account selected');
        }

        next(null, address, value, gasLimit);
      });
    }, function runTransaction(fromAddress, value, gasLimit, next) {
      const tx = {
        to: args.to,
        data: args.data.dataHex,
        useCall: args.useCall,
        from: fromAddress,
        value: value,
        gasLimit: gasLimit,
        timestamp: args.data.timestamp
      };
      const payLoad = {
        funAbi: args.data.funAbi,
        funArgs: args.data.funArgs,
        contractBytecode: args.data.contractBytecode,
        contractName: args.data.contractName,
        contractABI: args.data.contractABI,
        linkReferences: args.data.linkReferences
      };
      let timestamp = Date.now();

      if (tx.timestamp) {
        timestamp = tx.timestamp;
      }

      self.event.trigger('initiatingTransaction', [timestamp, tx, payLoad]);
      self.txRunner.rawRun(tx, confirmationCb, continueCb, promptCb, function (error, result) {
        let eventName = tx.useCall ? 'callExecuted' : 'transactionExecuted';
        self.event.trigger(eventName, [error, tx.from, tx.to, tx.data, tx.useCall, result, timestamp, payLoad]);

        if (error && typeof error !== 'string') {
          if (error.message) error = error.message;else {
            // eslint-disable-next-line no-empty
            try {
              error = 'error: ' + JSON.stringify(error);
            } catch (e) {}
          }
        }

        next(error, result);
      });
    }], cb);
  }

};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/util.js":
/*!********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/util.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ethutil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");
/*
 contains misc util: @TODO should be splitted
  - hex conversion
  - binary search
  - CALL related look up
  - sha3 calculation
  - swarm hash extraction
  - bytecode comparison
*/


module.exports = {
  /*
    ints: IntArray
  */
  hexConvert: function (ints) {
    let ret = '0x';

    for (let i = 0; i < ints.length; i++) {
      const h = ints[i];

      if (h) {
        ret += (h <= 0xf ? '0' : '') + h.toString(16);
      } else {
        ret += '00';
      }
    }

    return ret;
  },

  /**
   * Converts a hex string to an array of integers.
   */
  hexToIntArray: function (hexString) {
    if (hexString.slice(0, 2) === '0x') {
      hexString = hexString.slice(2);
    }

    const integers = [];

    for (let i = 0; i < hexString.length; i += 2) {
      integers.push(parseInt(hexString.slice(i, i + 2), 16));
    }

    return integers;
  },

  /*
    ints: list of BNs
  */
  hexListFromBNs: function (bnList) {
    const ret = [];

    for (let k in bnList) {
      const v = bnList[k];

      if (ethutil.BN.isBN(v)) {
        ret.push('0x' + v.toString('hex', 64));
      } else {
        ret.push('0x' + new ethutil.BN(v).toString('hex', 64)); // TEMP FIX TO REMOVE ONCE https://github.com/ethereumjs/ethereumjs-vm/pull/293 is released
      }
    }

    return ret;
  },

  /*
    ints: list of IntArrays
  */
  hexListConvert: function (intsList) {
    const ret = [];

    for (let k in intsList) {
      ret.push(this.hexConvert(intsList[k]));
    }

    return ret;
  },

  /*
    ints: ints: IntArray
  */
  formatMemory: function (mem) {
    const hexMem = this.hexConvert(mem).substr(2);
    const ret = [];

    for (let k = 0; k < hexMem.length; k += 32) {
      const row = hexMem.substr(k, 32);
      ret.push(row);
    }

    return ret;
  },

  /*
    Binary Search:
    Assumes that @arg array is sorted increasingly
    return largest i such that array[i] <= target; return -1 if array[0] > target || array is empty
  */
  findLowerBound: function (target, array) {
    let start = 0;
    let length = array.length;

    while (length > 0) {
      const half = length >> 1;
      const middle = start + half;

      if (array[middle] <= target) {
        length = length - 1 - half;
        start = middle + 1;
      } else {
        length = half;
      }
    }

    return start - 1;
  },

  /*
    Binary Search:
    Assumes that @arg array is sorted increasingly
    return largest array[i] such that array[i] <= target; return null if array[0] > target || array is empty
  */
  findLowerBoundValue: function (target, array) {
    const index = this.findLowerBound(target, array);
    return index >= 0 ? array[index] : null;
  },

  /*
    Binary Search:
    Assumes that @arg array is sorted increasingly
    return Return i such that |array[i] - target| is smallest among all i and -1 for an empty array.
    Returns the smallest i for multiple candidates.
  */
  findClosestIndex: function (target, array) {
    if (array.length === 0) {
      return -1;
    }

    const index = this.findLowerBound(target, array);

    if (index < 0) {
      return 0;
    } else if (index >= array.length - 1) {
      return array.length - 1;
    } else {
      const middle = (array[index] + array[index + 1]) / 2;
      return target <= middle ? index : index + 1;
    }
  },

  /**
    * Find the call from @args rootCall which contains @args index (recursive)
    *
    * @param {Int} index - index of the vmtrace
    * @param {Object} rootCall  - call tree, built by the trace analyser
    * @return {Object} - return the call which include the @args index
    */
  findCall: findCall,

  /**
   * Find calls path from @args rootCall which leads to @args index (recursive)
   *
   * @param {Int} index - index of the vmtrace
   * @param {Object} rootCall  - call tree, built by the trace analyser
   * @return {Array} - return the calls path to @args index
   */
  buildCallPath: buildCallPath,

  /**
  * sha3 the given @arg value (left pad to 32 bytes)
  *
  * @param {String} value - value to sha3
  * @return {Object} - return sha3ied value
  */
  sha3_256: function (value) {
    if (typeof value === 'string' && value.indexOf('0x') !== 0) {
      value = '0x' + value;
    }

    let ret = ethutil.bufferToHex(ethutil.setLengthLeft(value, 32));
    ret = ethutil.keccak(ret);
    return ethutil.bufferToHex(ret);
  },

  /**
    * return a regex which extract the swarmhash from the bytecode.
    *
    * @return {RegEx}
    */
  swarmHashExtraction: function () {
    return /a165627a7a72305820([0-9a-f]{64})0029$/;
  },

  /**
    * return a regex which extract the swarmhash from the bytecode, from POC 0.3
    *
    * @return {RegEx}
    */
  swarmHashExtractionPOC31: function () {
    return /a265627a7a72315820([0-9a-f]{64})64736f6c6343([0-9a-f]{6})0032$/;
  },

  /**
    * return a regex which extract the swarmhash from the bytecode, from POC 0.3
    *
    * @return {RegEx}
    */
  swarmHashExtractionPOC32: function () {
    return /a265627a7a72305820([0-9a-f]{64})64736f6c6343([0-9a-f]{6})0032$/;
  },

  /**
    * return a regex which extract the cbor encoded metadata : {"ipfs": <IPFS hash>, "solc": <compiler version>} from the bytecode.
    * ref https://solidity.readthedocs.io/en/v0.6.6/metadata.html?highlight=ipfs#encoding-of-the-metadata-hash-in-the-bytecode
    * @return {RegEx}
    */
  cborEncodedValueExtraction: function () {
    return /64697066735822([0-9a-f]{68})64736f6c6343([0-9a-f]{6})0033$/;
  },
  extractcborMetadata: function (value) {
    return value.replace(this.cborEncodedValueExtraction(), '');
  },
  extractSwarmHash: function (value) {
    value = value.replace(this.swarmHashExtraction(), '');
    value = value.replace(this.swarmHashExtractionPOC31(), '');
    value = value.replace(this.swarmHashExtractionPOC32(), '');
    return value;
  },

  /**
    * Compare bytecode. return true if the code is equal (handle swarm hash and library references)
    * @param {String} code1 - the bytecode that is actually deployed (contains resolved library reference and a potentially different swarmhash)
    * @param {String} code2 - the bytecode generated by the compiler (contains unresolved library reference and a potentially different swarmhash)
                              this will return false if the generated bytecode is empty (asbtract contract cannot be deployed)
    *
    * @return {bool}
    */
  compareByteCode: function (code1, code2) {
    if (code1 === code2) return true;
    if (code2 === '0x') return false; // abstract contract. see comment

    if (code2.substr(2, 46) === '7300000000000000000000000000000000000000003014') {
      // testing the following signature: PUSH20 00..00 ADDRESS EQ
      // in the context of a library, that slot contains the address of the library (pushed by the compiler to avoid calling library other than with a DELEGATECALL)
      // if code2 is not a library, well we still suppose that the comparison remain relevant even if we remove some information from `code1`
      code1 = replaceLibReference(code1, 4);
    }

    let pos = -1;

    while ((pos = code2.search(/__(.*)__/)) !== -1) {
      code2 = replaceLibReference(code2, pos);
      code1 = replaceLibReference(code1, pos);
    }

    code1 = this.extractSwarmHash(code1);
    code1 = this.extractcborMetadata(code1);
    code2 = this.extractSwarmHash(code2);
    code2 = this.extractcborMetadata(code2);

    if (code1 && code2 && code1.indexOf(code2) === 0) {
      return true;
    }

    return false;
  },
  groupBy: groupBy,
  concatWithSeperator: concatWithSeperator,
  escapeRegExp: escapeRegExp
};

function replaceLibReference(code, pos) {
  return code.substring(0, pos) + '0000000000000000000000000000000000000000' + code.substring(pos + 40);
}

function buildCallPath(index, rootCall) {
  const ret = [];
  findCallInternal(index, rootCall, ret);
  return ret;
}

function findCall(index, rootCall) {
  const ret = buildCallPath(index, rootCall);
  return ret[ret.length - 1];
}

function findCallInternal(index, rootCall, callsPath) {
  const calls = Object.keys(rootCall.calls);
  const ret = rootCall;
  callsPath.push(rootCall);

  for (let k in calls) {
    let subCall = rootCall.calls[calls[k]];

    if (index >= subCall.start && index <= subCall.return) {
      findCallInternal(index, subCall, callsPath);
      break;
    }
  }

  return ret;
}
/* util extracted out from remix-ide. @TODO split this file, cause it mix real util fn with solidity related stuff ... */


function groupBy(arr, key) {
  return arr.reduce((sum, item) => {
    const groupByVal = item[key];
    const groupedItems = sum[groupByVal] || [];
    groupedItems.push(item);
    sum[groupByVal] = groupedItems;
    return sum;
  }, {});
}

function concatWithSeperator(list, seperator) {
  return list.reduce((sum, item) => sum + item + seperator, '').slice(0, -seperator.length);
}

function escapeRegExp(str) {
  return str.replace(/[-[\]/{}()+?.\\^$|]/g, '\\$&');
}

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/web3Provider/dummyProvider.js":
/*!******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/web3Provider/dummyProvider.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function dummyProvider() {
  this.eth = {};
  this.debug = {};

  this.eth.getCode = (address, cb) => {
    return this.getCode(address, cb);
  };

  this.eth.getTransaction = (hash, cb) => {
    return this.getTransaction(hash, cb);
  };

  this.eth.getTransactionFromBlock = (blockNumber, txIndex, cb) => {
    return this.getTransactionFromBlock(blockNumber, txIndex, cb);
  };

  this.eth.getBlockNumber = cb => {
    return this.getBlockNumber(cb);
  };

  this.debug.traceTransaction = (hash, options, cb) => {
    return this.traceTransaction(hash, options, cb);
  };

  this.debug.storageRangeAt = (blockNumber, txIndex, address, start, end, maxLength, cb) => {
    return this.storageRangeAt(blockNumber, txIndex, address, start, end, maxLength, cb);
  };

  this.providers = {
    'HttpProvider': function (url) {}
  };
  this.currentProvider = {
    'host': ''
  };
}

dummyProvider.prototype.getCode = function (address, cb) {
  cb(null, '');
};

dummyProvider.prototype.setProvider = function (provider) {};

dummyProvider.prototype.traceTransaction = function (txHash, options, cb) {
  if (cb) {
    cb(null, {});
  }

  return {};
};

dummyProvider.prototype.storageRangeAt = function (blockNumber, txIndex, address, start, end, maxLength, cb) {
  if (cb) {
    cb(null, {});
  }

  return {};
};

dummyProvider.prototype.getBlockNumber = function (cb) {
  cb(null, '');
};

dummyProvider.prototype.getTransaction = function (txHash, cb) {
  if (cb) {
    cb(null, {});
  }

  return {};
};

dummyProvider.prototype.getTransactionFromBlock = function (blockNumber, txIndex, cb) {
  if (cb) {
    cb(null, {});
  }

  return {};
};

module.exports = dummyProvider;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/web3Provider/web3Providers.js":
/*!******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/web3Provider/web3Providers.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Web3VMProvider = __webpack_require__(/*! ./web3VmProvider */ "../../../dist/libs/remix-lib/src/web3Provider/web3VmProvider.js");

const init = __webpack_require__(/*! ../init */ "../../../dist/libs/remix-lib/src/init.js");

function Web3Providers() {
  this.modes = {};
}

Web3Providers.prototype.addProvider = function (type, obj) {
  if (type === 'INTERNAL') {
    const web3 = init.loadWeb3();
    this.addWeb3(type, web3);
  } else if (type === 'vm') {
    this.addVM(type, obj);
  } else {
    init.extendWeb3(obj);
    this.addWeb3(type, obj);
  }
};

Web3Providers.prototype.get = function (type, cb) {
  if (this.modes[type]) {
    cb(null, this.modes[type]);
  } else {
    cb('error: this provider has not been setup (' + type + ')', null);
  }
};

Web3Providers.prototype.addWeb3 = function (type, web3) {
  this.modes[type] = web3;
};

Web3Providers.prototype.addVM = function (type, vm) {
  const vmProvider = new Web3VMProvider();
  vmProvider.setVM(vm);
  this.modes[type] = vmProvider;
};

module.exports = Web3Providers;

/***/ }),

/***/ "../../../dist/libs/remix-lib/src/web3Provider/web3VmProvider.js":
/*!*******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-lib/src/web3Provider/web3VmProvider.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const util = __webpack_require__(/*! ../util */ "../../../dist/libs/remix-lib/src/util.js");

const uiutil = __webpack_require__(/*! ../helpers/uiHelper */ "../../../dist/libs/remix-lib/src/helpers/uiHelper.js");

const traceHelper = __webpack_require__(/*! ../helpers/traceHelper */ "../../../dist/libs/remix-lib/src/helpers/traceHelper.js");

const ethutil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

function web3VmProvider() {
  this.web3 = new Web3();
  this.vm;
  this.vmTraces = {};
  this.txs = {};
  this.txsReceipt = {};
  this.processingHash;
  this.processingAddress;
  this.processingIndex;
  this.previousDepth = 0;
  this.incr = 0;
  this.eth = {};
  this.debug = {};

  this.eth.getCode = (...args) => this.getCode(...args);

  this.eth.getTransaction = (...args) => this.getTransaction(...args);

  this.eth.getTransactionReceipt = (...args) => this.getTransactionReceipt(...args);

  this.eth.getTransactionFromBlock = (...args) => this.getTransactionFromBlock(...args);

  this.eth.getBlockNumber = (...args) => this.getBlockNumber(...args);

  this.debug.traceTransaction = (...args) => this.traceTransaction(...args);

  this.debug.storageRangeAt = (...args) => this.storageRangeAt(...args);

  this.debug.preimage = (...args) => this.preimage(...args);

  this.providers = {
    'HttpProvider': function (url) {}
  };
  this.currentProvider = {
    'host': 'vm provider'
  };
  this.storageCache = {};
  this.lastProcessedStorageTxHash = {};
  this.sha3Preimages = {}; // util

  this.sha3 = (...args) => this.web3.utils.sha3(...args);

  this.toHex = (...args) => this.web3.utils.toHex(...args);

  this.toAscii = (...args) => this.web3.utils.hexToAscii(...args);

  this.fromAscii = (...args) => this.web3.utils.asciiToHex(...args);

  this.fromDecimal = (...args) => this.web3.utils.numberToHex(...args);

  this.fromWei = (...args) => this.web3.utils.fromWei(...args);

  this.toWei = (...args) => this.web3.utils.toWei(...args);

  this.toBigNumber = (...args) => this.web3.utils.toBN(...args);

  this.isAddress = (...args) => this.web3.utils.isAddress(...args);

  this.utils = Web3.utils || [];
}

web3VmProvider.prototype.setVM = function (vm) {
  if (this.vm === vm) return;
  this.vm = vm;
  this.vm.on('step', data => {
    this.pushTrace(this, data);
  });
  this.vm.on('afterTx', data => {
    this.txProcessed(this, data);
  });
  this.vm.on('beforeTx', data => {
    this.txWillProcess(this, data);
  });
};

web3VmProvider.prototype.releaseCurrentHash = function () {
  const ret = this.processingHash;
  this.processingHash = undefined;
  return ret;
};

web3VmProvider.prototype.txWillProcess = function (self, data) {
  self.incr++;
  self.processingHash = util.hexConvert(data.hash());
  self.vmTraces[self.processingHash] = {
    gas: '0x0',
    return: '0x0',
    structLogs: []
  };
  let tx = {};
  tx.hash = self.processingHash;
  tx.from = util.hexConvert(data.getSenderAddress());

  if (data.to && data.to.length) {
    tx.to = util.hexConvert(data.to);
  }

  this.processingAddress = tx.to;
  tx.data = util.hexConvert(data.data);
  tx.input = util.hexConvert(data.input);
  tx.gas = new ethutil.BN(util.hexConvert(data.gas).replace('0x', ''), 16).toString(10);

  if (data.value) {
    tx.value = util.hexConvert(data.value);
  }

  self.txs[self.processingHash] = tx;
  self.txsReceipt[self.processingHash] = tx;
  self.storageCache[self.processingHash] = {};

  if (tx.to) {
    const account = ethutil.toBuffer(tx.to);
    self.vm.stateManager.dumpStorage(account, storage => {
      self.storageCache[self.processingHash][tx.to] = storage;
      self.lastProcessedStorageTxHash[tx.to] = self.processingHash;
    });
  }

  this.processingIndex = 0;
};

web3VmProvider.prototype.txProcessed = function (self, data) {
  const lastOp = self.vmTraces[self.processingHash].structLogs[self.processingIndex - 1];

  if (lastOp) {
    lastOp.error = lastOp.op !== 'RETURN' && lastOp.op !== 'STOP' && lastOp.op !== 'SELFDESTRUCT';
  }

  self.vmTraces[self.processingHash].gas = '0x' + data.gasUsed.toString(16);
  const logs = [];

  for (let l in data.execResult.logs) {
    const log = data.execResult.logs[l];
    const topics = [];

    if (log[1].length > 0) {
      for (var k in log[1]) {
        topics.push('0x' + log[1][k].toString('hex'));
      }
    } else {
      topics.push('0x');
    }

    logs.push({
      address: '0x' + log[0].toString('hex'),
      data: '0x' + log[2].toString('hex'),
      topics: topics,
      rawVMResponse: log
    });
  }

  self.txsReceipt[self.processingHash].logs = logs;
  self.txsReceipt[self.processingHash].transactionHash = self.processingHash;
  const status = data.execResult.exceptionError ? 0 : 1;
  self.txsReceipt[self.processingHash].status = `0x${status}`;

  if (data.createdAddress) {
    const address = util.hexConvert(data.createdAddress);
    self.vmTraces[self.processingHash].return = address;
    self.txsReceipt[self.processingHash].contractAddress = address;
  } else if (data.execResult.returnValue) {
    self.vmTraces[self.processingHash].return = util.hexConvert(data.execResult.returnValue);
  } else {
    self.vmTraces[self.processingHash].return = '0x';
  }

  this.processingIndex = null;
  this.processingAddress = null;
  this.previousDepth = 0;
};

web3VmProvider.prototype.pushTrace = function (self, data) {
  const depth = data.depth + 1; // geth starts the depth from 1

  if (!self.processingHash) {
    console.log('no tx processing');
    return;
  }

  let previousopcode;

  if (self.vmTraces[self.processingHash] && self.vmTraces[self.processingHash].structLogs[this.processingIndex - 1]) {
    previousopcode = self.vmTraces[self.processingHash].structLogs[this.processingIndex - 1];
  }

  if (this.previousDepth > depth && previousopcode) {
    // returning from context, set error it is not STOP, RETURN
    previousopcode.invalidDepthChange = previousopcode.op !== 'RETURN' && previousopcode.op !== 'STOP';
  }

  const step = {
    stack: util.hexListFromBNs(data.stack),
    memory: util.formatMemory(data.memory),
    storage: data.storage,
    op: data.opcode.name,
    pc: data.pc,
    gasCost: data.opcode.fee.toString(),
    gas: data.gasLeft.toString(),
    depth: depth,
    error: data.error === false ? undefined : data.error
  };
  self.vmTraces[self.processingHash].structLogs.push(step);

  if (traceHelper.newContextStorage(step)) {
    if (step.op === 'CREATE') {
      this.processingAddress = traceHelper.contractCreationToken(this.processingIndex);
      this.storageCache[this.processingHash][this.processingAddress] = {};
      this.lastProcessedStorageTxHash[this.processingAddress] = this.processingHash;
    } else {
      this.processingAddress = uiutil.normalizeHexAddress(step.stack[step.stack.length - 2]);

      if (!self.storageCache[self.processingHash][this.processingAddress]) {
        const account = ethutil.toBuffer(this.processingAddress);
        self.vm.stateManager.dumpStorage(account, function (storage) {
          self.storageCache[self.processingHash][self.processingAddress] = storage;
          self.lastProcessedStorageTxHash[self.processingAddress] = self.processingHash;
        });
      }
    }
  }

  if (previousopcode && traceHelper.isSHA3Instruction(previousopcode)) {
    const preimage = getSha3Input(previousopcode.stack, previousopcode.memory);
    const imageHash = step.stack[step.stack.length - 1].replace('0x', '');
    self.sha3Preimages[imageHash] = {
      'preimage': preimage
    };
  }

  this.processingIndex++;
  this.previousDepth = depth;
};

web3VmProvider.prototype.getCode = function (address, cb) {
  const account = ethutil.toBuffer(address);
  this.vm.stateManager.getContractCode(account, (error, result) => {
    cb(error, util.hexConvert(result));
  });
};

web3VmProvider.prototype.setProvider = function (provider) {};

web3VmProvider.prototype.traceTransaction = function (txHash, options, cb) {
  if (this.vmTraces[txHash]) {
    if (cb) {
      cb(null, this.vmTraces[txHash]);
    }

    return this.vmTraces[txHash];
  } else {
    if (cb) {
      cb('unable to retrieve traces ' + txHash, null);
    }
  }
};

web3VmProvider.prototype.storageRangeAt = function (blockNumber, txIndex, address, start, maxLength, cb) {
  // we don't use the range params here
  if (txIndex === 'latest') {
    txIndex = this.lastProcessedStorageTxHash[address];
  }

  if (this.storageCache[txIndex] && this.storageCache[txIndex][address]) {
    const storage = this.storageCache[txIndex][address];
    return cb(null, {
      storage: JSON.parse(JSON.stringify(storage)),
      nextKey: null
    });
  } else {
    cb('unable to retrieve storage ' + txIndex + ' ' + address);
  }
};

web3VmProvider.prototype.getBlockNumber = function (cb) {
  cb(null, 'vm provider');
};

web3VmProvider.prototype.getTransaction = function (txHash, cb) {
  if (this.txs[txHash]) {
    if (cb) {
      cb(null, this.txs[txHash]);
    }

    return this.txs[txHash];
  } else {
    if (cb) {
      cb('unable to retrieve tx ' + txHash, null);
    }
  }
};

web3VmProvider.prototype.getTransactionReceipt = function (txHash, cb) {
  // same as getTransaction but return the created address also
  if (this.txsReceipt[txHash]) {
    if (cb) {
      cb(null, this.txsReceipt[txHash]);
    }

    return this.txsReceipt[txHash];
  } else {
    if (cb) {
      cb('unable to retrieve txReceipt ' + txHash, null);
    }
  }
};

web3VmProvider.prototype.getTransactionFromBlock = function (blockNumber, txIndex, cb) {
  const mes = 'not supposed to be needed by remix in vmmode';
  console.log(mes);

  if (cb) {
    cb(mes, null);
  }
};

web3VmProvider.prototype.preimage = function (hashedKey, cb) {
  hashedKey = hashedKey.replace('0x', '');
  cb(null, this.sha3Preimages[hashedKey] !== undefined ? this.sha3Preimages[hashedKey].preimage : null);
};

function getSha3Input(stack, memory) {
  let memoryStart = stack[stack.length - 1];
  let memoryLength = stack[stack.length - 2];
  const memStartDec = new ethutil.BN(memoryStart.replace('0x', ''), 16).toString(10);
  memoryStart = parseInt(memStartDec) * 2;
  const memLengthDec = new ethutil.BN(memoryLength.replace('0x', ''), 16).toString(10);
  memoryLength = parseInt(memLengthDec) * 2;
  let i = Math.floor(memoryStart / 32);
  const maxIndex = Math.floor(memoryLength / 32) + i;

  if (!memory[i]) {
    return emptyFill(memoryLength);
  }

  let sha3Input = memory[i].slice(memoryStart - 32 * i);
  i++;

  while (i < maxIndex) {
    sha3Input += memory[i] ? memory[i] : emptyFill(32);
    i++;
  }

  if (sha3Input.length < memoryLength) {
    const leftSize = memoryLength - sha3Input.length;
    sha3Input += memory[i] ? memory[i].slice(0, leftSize) : emptyFill(leftSize);
  }

  return sha3Input;
}

function emptyFill(size) {
  return new Array(size).join('0');
}

module.exports = web3VmProvider;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/index.js":
/*!***********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Provider = __webpack_require__(/*! ./src/provider */ "../../../dist/libs/remix-simulator/src/provider.js");

module.exports = {
  Provider: Provider
};

/***/ }),

/***/ "../../../dist/libs/remix-simulator/package.json":
/*!***************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/package.json ***!
  \***************************************************************************/
/*! exports provided: name, version, description, contributors, main, dependencies, devDependencies, scripts, publishConfig, bin, repository, author, license, bugs, homepage, typings, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@remix-project/remix-simulator\",\"version\":\"0.1.9-beta.7\",\"description\":\"Ethereum IDE and tools for the web\",\"contributors\":[{\"name\":\"Iuri Matias\",\"email\":\"iuri@ethereum.org\"},{\"name\":\"Yann Levreau\",\"email\":\"yann@ethdev.com\"}],\"main\":\"index.js.js\",\"dependencies\":{\"ansi-gray\":\"^0.1.1\",\"async\":\"^3.1.0\",\"body-parser\":\"^1.18.2\",\"color-support\":\"^1.1.3\",\"commander\":\"^2.19.0\",\"cors\":\"^2.8.5\",\"ethereumjs-block\":\"^2.2.2\",\"ethereumjs-util\":\"^6.2.0\",\"express\":\"^4.16.3\",\"express-ws\":\"^4.0.0\",\"merge\":\"^1.2.0\",\"@remix-project/remix-lib\":\"0.4.29\",\"time-stamp\":\"^2.0.0\",\"web3\":\"^1.2.4\",\"ethereumjs-vm\":\"4.1.3\",\"ethereumjs-tx\":\"^2.1.2\"},\"devDependencies\":{\"@babel/core\":\"^7.4.5\",\"@babel/plugin-transform-object-assign\":\"^7.2.0\",\"@babel/preset-env\":\"^7.4.5\",\"@babel/preset-es2015\":\"latest\",\"@babel/preset-es2017\":\"latest\",\"@babel/preset-stage-0\":\"^7.0.0\",\"babel-eslint\":\"^7.1.1\",\"babelify\":\"^10.0.0\",\"mocha\":\"^5.2.0\"},\"scripts\":{\"test\":\"./../../node_modules/.bin/mocha --require tsconfig-paths/register test/\"},\"publishConfig\":{\"access\":\"public\"},\"bin\":{\"ethsim\":\"./bin/ethsim\",\"remix-simulator\":\"./bin/ethsim\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/ethereum/remix-project.git\"},\"author\":\"remix team\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/ethereum/remix-project/issues\"},\"homepage\":\"https://github.com/ethereum/remix-project/tree/master/libs/remix-simulator#readme\",\"typings\":\"index.js.d.ts\"}");

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/genesis.js":
/*!*****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/genesis.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EthJSBlock = __webpack_require__(/*! ethereumjs-block */ "../../../node_modules/ethereumjs-block/index.js");

const ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const BN = ethJSUtil.BN;

function generateBlock(executionContext) {
  const block = new EthJSBlock({
    header: {
      timestamp: new Date().getTime() / 1000 | 0,
      number: 0,
      coinbase: '0x0e9281e9c6a0808672eaba6bd1220e144c9bb07a',
      difficulty: new BN('69762765929000', 10),
      gasLimit: new BN('8000000').imuln(1)
    },
    transactions: [],
    uncleHeaders: []
  });
  executionContext.vm().runBlock({
    block: block,
    generate: true,
    skipBlockValidation: true,
    skipBalance: false
  }).then(() => {
    executionContext.addBlock(block);
  });
}

module.exports = generateBlock;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/accounts.js":
/*!**************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/accounts.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const {
  BN,
  privateToAddress,
  isValidPrivate
} = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

const crypto = __webpack_require__(/*! crypto */ "../../../node_modules/crypto-browserify/index.js");

class Accounts {
  constructor(executionContext) {
    this.web3 = new Web3();
    this.executionContext = executionContext; // TODO: make it random and/or use remix-libs

    this.accountsList = [this.web3.eth.accounts.create(['abcd']), this.web3.eth.accounts.create(['ef12']), this.web3.eth.accounts.create(['ef34']), this.web3.eth.accounts.create(['ab12']), this.web3.eth.accounts.create(['ab34']), this.web3.eth.accounts.create(['cd12']), this.web3.eth.accounts.create(['cd34']), this.web3.eth.accounts.create(['bcde']), this.web3.eth.accounts.create(['cdef']), this.web3.eth.accounts.create(['1234'])];
    this.accounts = {};
    this.accountsKeys = {};
    this.executionContext.init({
      get: () => {
        return true;
      }
    });
  }

  init() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      let setBalance = account => {
        return new Promise((resolve, reject) => {
          this.accountsKeys[ethJSUtil.toChecksumAddress(account.address)] = account.privateKey;
          this.accounts[ethJSUtil.toChecksumAddress(account.address)] = {
            privateKey: Buffer.from(account.privateKey.replace('0x', ''), 'hex'),
            nonce: 0
          };
          this.executionContext.vm().stateManager.getAccount(Buffer.from(account.address.replace('0x', ''), 'hex'), (err, account) => {
            if (err) {
              throw new Error(err);
            }

            const balance = '0x56BC75E2D63100000';
            account.balance = balance || '0xf00000000000000001';
            resolve();
          });
        });
      };

      for (let _account of this.accountsList) {
        yield setBalance(_account);
      }
    });
  }

  resetAccounts() {
    // TODO: setting this to {} breaks the app currently, unclear why still
    // this.accounts = {}
    // this.accountsKeys = {}
    this._addAccount('3cd7232cd6f3fc66a57a6bedc1a8ed6c228fff0a327e169c2bcc5e869ed49511', '0x56BC75E2D63100000');

    this._addAccount('2ac6c190b09897cd8987869cc7b918cfea07ee82038d492abce033c75c1b1d0c', '0x56BC75E2D63100000');

    this._addAccount('dae9801649ba2d95a21e688b56f77905e5667c44ce868ec83f82e838712a2c7a', '0x56BC75E2D63100000');

    this._addAccount('d74aa6d18aa79a05f3473dd030a97d3305737cbc8337d940344345c1f6b72eea', '0x56BC75E2D63100000');

    this._addAccount('71975fbf7fe448e004ac7ae54cad0a383c3906055a65468714156a07385e96ce', '0x56BC75E2D63100000');
  }

  _addAccount(privateKey, balance) {
    privateKey = Buffer.from(privateKey, 'hex');
    const address = ethJSUtil.privateToAddress(privateKey); // FIXME: we don't care about the callback, but we should still make this proper

    let stateManager = this.executionContext.vm().stateManager;
    stateManager.getAccount(address, (error, account) => {
      if (error) return console.log(error);
      account.balance = balance || '0xf00000000000000001';
      stateManager.putAccount(address, account, error => {
        if (error) console.log(error);
      });
    });
    this.accounts[ethJSUtil.toChecksumAddress('0x' + address.toString('hex'))] = {
      privateKey,
      nonce: 0
    };
    this.accountsKeys[ethJSUtil.toChecksumAddress('0x' + address.toString('hex'))] = '0x' + privateKey.toString('hex');
  }

  newAccount(cb) {
    let privateKey;

    do {
      privateKey = crypto.randomBytes(32);
    } while (!isValidPrivate(privateKey));

    this._addAccount(privateKey, '0x56BC75E2D63100000');

    return cb(null, '0x' + privateToAddress(privateKey).toString('hex'));
  }

  methods() {
    return {
      eth_accounts: this.eth_accounts.bind(this),
      eth_getBalance: this.eth_getBalance.bind(this),
      eth_sign: this.eth_sign.bind(this)
    };
  }

  eth_accounts(_payload, cb) {
    return cb(null, Object.keys(this.accounts));
  }

  eth_getBalance(payload, cb) {
    let address = payload.params[0];
    address = ethJSUtil.stripHexPrefix(address);
    this.executionContext.vm().stateManager.getAccount(Buffer.from(address, 'hex'), (err, account) => {
      if (err) {
        return cb(err);
      }

      cb(null, new BN(account.balance).toString(10));
    });
  }

  eth_sign(payload, cb) {
    const address = payload.params[0];
    const message = payload.params[1];
    const privateKey = this.accountsKeys[ethJSUtil.toChecksumAddress(address)];

    if (!privateKey) {
      return cb(new Error('unknown account'));
    }

    const account = this.web3.eth.accounts.privateKeyToAccount(privateKey);
    const data = account.sign(message);
    cb(null, data.signature);
  }

}

module.exports = Accounts;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/blocks.js":
/*!************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/blocks.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class Blocks {
  constructor(executionContext, _options) {
    this.executionContext = executionContext;
    const options = _options || {};
    this.coinbase = options.coinbase || '0x0000000000000000000000000000000000000000';
    this.blockNumber = 0;
  }

  methods() {
    return {
      eth_getBlockByNumber: this.eth_getBlockByNumber.bind(this),
      eth_gasPrice: this.eth_gasPrice.bind(this),
      eth_coinbase: this.eth_coinbase.bind(this),
      eth_blockNumber: this.eth_blockNumber.bind(this),
      eth_getBlockByHash: this.eth_getBlockByHash.bind(this),
      eth_getBlockTransactionCountByHash: this.eth_getBlockTransactionCountByHash.bind(this),
      eth_getBlockTransactionCountByNumber: this.eth_getBlockTransactionCountByNumber.bind(this),
      eth_getUncleCountByBlockHash: this.eth_getUncleCountByBlockHash.bind(this),
      eth_getUncleCountByBlockNumber: this.eth_getUncleCountByBlockNumber.bind(this),
      eth_getStorageAt: this.eth_getStorageAt.bind(this)
    };
  }

  eth_getBlockByNumber(payload, cb) {
    let blockIndex = payload.params[0];

    if (blockIndex === 'latest') {
      blockIndex = this.executionContext.latestBlockNumber;
    }

    const block = this.executionContext.blocks[blockIndex];

    if (!block) {
      return cb(new Error('block not found'));
    }

    let b = {
      'number': this.toHex(block.header.number),
      'hash': this.toHex(block.hash()),
      'parentHash': this.toHex(block.header.parentHash),
      'nonce': this.toHex(block.header.nonce),
      'sha3Uncles': '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
      'logsBloom': '0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331',
      'transactionsRoot': '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
      'stateRoot': this.toHex(block.header.stateRoot),
      'miner': this.coinbase,
      'difficulty': this.toHex(block.header.difficulty),
      'totalDifficulty': this.toHex(block.header.totalDifficulty),
      'extraData': this.toHex(block.header.extraData),
      'size': '0x027f07',
      'gasLimit': this.toHex(block.header.gasLimit),
      'gasUsed': this.toHex(block.header.gasUsed),
      'timestamp': this.toHex(block.header.timestamp),
      'transactions': block.transactions.map(t => '0x' + t.hash().toString('hex')),
      'uncles': []
    };
    cb(null, b);
  }

  toHex(value) {
    if (!value) return '0x0';
    let v = value.toString('hex');
    return v === '0x' || v === '' ? '0x0' : '0x' + v;
  }

  eth_getBlockByHash(payload, cb) {
    var block = this.executionContext.blocks[payload.params[0]];
    let b = {
      'number': this.toHex(block.header.number),
      'hash': this.toHex(block.hash()),
      'parentHash': this.toHex(block.header.parentHash),
      'nonce': this.toHex(block.header.nonce),
      'sha3Uncles': '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
      'logsBloom': '0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331',
      'transactionsRoot': '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
      'stateRoot': this.toHex(block.header.stateRoot),
      'miner': this.coinbase,
      'difficulty': this.toHex(block.header.difficulty),
      'totalDifficulty': this.toHex(block.header.totalDifficulty),
      'extraData': this.toHex(block.header.extraData),
      'size': '0x027f07',
      'gasLimit': this.toHex(block.header.gasLimit),
      'gasUsed': this.toHex(block.header.gasUsed),
      'timestamp': this.toHex(block.header.timestamp),
      'transactions': block.transactions.map(t => '0x' + t.hash().toString('hex')),
      'uncles': []
    };
    cb(null, b);
  }

  eth_gasPrice(payload, cb) {
    cb(null, 1);
  }

  eth_coinbase(payload, cb) {
    cb(null, this.coinbase);
  }

  eth_blockNumber(payload, cb) {
    cb(null, this.blockNumber);
  }

  eth_getBlockTransactionCountByHash(payload, cb) {
    var block = this.executionContext.blocks[payload.params[0]];
    cb(null, block.transactions.length);
  }

  eth_getBlockTransactionCountByNumber(payload, cb) {
    var block = this.executionContext.blocks[payload.params[0]];
    cb(null, block.transactions.length);
  }

  eth_getUncleCountByBlockHash(payload, cb) {
    cb(null, 0);
  }

  eth_getUncleCountByBlockNumber(payload, cb) {
    cb(null, 0);
  }

  eth_getStorageAt(payload, cb) {
    const [address, position, blockNumber] = payload.params;
    this.executionContext.web3().debug.storageRangeAt(blockNumber, 'latest', address.toLowerCase(), position, 1, (err, result) => {
      if (err || result.storage && Object.values(result.storage).length === 0) {
        return cb(err, '');
      }

      let value = Object.values(result.storage)[0].value;
      cb(err, value);
    });
  }

}

module.exports = Blocks;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/filters.js":
/*!*************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/filters.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


class Filters {
  constructor(executionContext) {
    this.executionContext = executionContext;
  }

  methods() {
    return {
      eth_getLogs: this.eth_getLogs.bind(this),
      eth_subscribe: this.eth_subscribe.bind(this),
      eth_unsubscribe: this.eth_unsubscribe.bind(this)
    };
  }

  eth_getLogs(payload, cb) {
    let results = this.executionContext.logsManager.getLogsFor(payload.params[0]);
    cb(null, results);
  }

  eth_subscribe(payload, cb) {
    let subscriptionId = this.executionContext.logsManager.subscribe(payload.params);
    cb(null, subscriptionId);
  }

  eth_unsubscribe(payload, cb) {
    this.executionContext.logsManager.unsubscribe(payload.params[0]);
    cb(null, true);
  }

  eth_newFilter(payload, cb) {
    const filterId = this.executionContext.logsManager.newFilter('filter', payload.params[0]);
    cb(null, filterId);
  }

  eth_newBlockFilter(payload, cb) {
    const filterId = this.executionContext.logsManager.newFilter('block');
    cb(null, filterId);
  }

  eth_newPendingTransactionFilter(payload, cb) {
    const filterId = this.executionContext.logsManager.newFilter('pendingTransactions');
    cb(null, filterId);
  }

  eth_uninstallfilter(payload, cb) {
    const result = this.executionContext.logsManager.uninstallFilter(payload.params[0]);
    cb(null, result);
  }

  eth_getFilterChanges(payload, cb) {
    const filterId = payload.params[0];
    let results = this.executionContext.logsManager.getLogsForFilter(filterId);
    cb(null, results);
  }

  eth_getFilterLogs(payload, cb) {
    const filterId = payload.params[0];
    let results = this.executionContext.logsManager.getLogsForFilter(filterId, true);
    cb(null, results);
  }

}

module.exports = Filters;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/misc.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/misc.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const version = __webpack_require__(/*! ../../package.json */ "../../../dist/libs/remix-simulator/package.json").version;

const web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

const Misc = function () {};

Misc.prototype.methods = function () {
  return {
    web3_clientVersion: this.web3_clientVersion.bind(this),
    eth_protocolVersion: this.eth_protocolVersion.bind(this),
    eth_syncing: this.eth_syncing.bind(this),
    eth_mining: this.eth_mining.bind(this),
    eth_hashrate: this.eth_hashrate.bind(this),
    web3_sha3: this.web3_sha3.bind(this),
    eth_getCompilers: this.eth_getCompilers.bind(this),
    eth_compileSolidity: this.eth_compileSolidity.bind(this),
    eth_compileLLL: this.eth_compileLLL.bind(this),
    eth_compileSerpent: this.eth_compileSerpent.bind(this)
  };
};

Misc.prototype.web3_clientVersion = function (payload, cb) {
  cb(null, 'Remix Simulator/' + version);
};

Misc.prototype.eth_protocolVersion = function (payload, cb) {
  cb(null, '0x3f');
};

Misc.prototype.eth_syncing = function (payload, cb) {
  cb(null, false);
};

Misc.prototype.eth_mining = function (payload, cb) {
  // TODO: should depend on the state
  cb(null, false);
};

Misc.prototype.eth_hashrate = function (payload, cb) {
  cb(null, '0x0');
};

Misc.prototype.web3_sha3 = function (payload, cb) {
  const str = payload.params[0];
  cb(null, web3.utils.sha3(str));
};

Misc.prototype.eth_getCompilers = function (payload, cb) {
  cb(null, []);
};

Misc.prototype.eth_compileSolidity = function (payload, cb) {
  cb(null, 'unsupported');
};

Misc.prototype.eth_compileLLL = function (payload, cb) {
  cb(null, 'unsupported');
};

Misc.prototype.eth_compileSerpent = function (payload, cb) {
  cb(null, 'unsupported');
};

module.exports = Misc;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/net.js":
/*!*********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/net.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Net = function () {};

Net.prototype.methods = function () {
  return {
    net_version: this.net_version,
    net_listening: this.net_listening,
    net_peerCount: this.net_peerCount
  };
};

Net.prototype.net_version = function (payload, cb) {
  // should be configured networkId
  cb(null, 1337);
};

Net.prototype.net_listening = function (payload, cb) {
  cb(null, true);
};

Net.prototype.net_peerCount = function (payload, cb) {
  cb(null, 0);
};

module.exports = Net;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/transactions.js":
/*!******************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/transactions.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

const ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const processTx = __webpack_require__(/*! ./txProcess.js */ "../../../dist/libs/remix-simulator/src/methods/txProcess.js");

const BN = ethJSUtil.BN;

class Transactions {
  constructor(executionContext) {
    this.executionContext = executionContext;
  }

  init(accounts) {
    this.accounts = accounts;
  }

  methods() {
    return {
      eth_sendTransaction: this.eth_sendTransaction.bind(this),
      eth_getTransactionReceipt: this.eth_getTransactionReceipt.bind(this),
      eth_getCode: this.eth_getCode.bind(this),
      eth_call: this.eth_call.bind(this),
      eth_estimateGas: this.eth_estimateGas.bind(this),
      eth_getTransactionCount: this.eth_getTransactionCount.bind(this),
      eth_getTransactionByHash: this.eth_getTransactionByHash.bind(this),
      eth_getTransactionByBlockHashAndIndex: this.eth_getTransactionByBlockHashAndIndex.bind(this),
      eth_getTransactionByBlockNumberAndIndex: this.eth_getTransactionByBlockNumberAndIndex.bind(this)
    };
  }

  eth_sendTransaction(payload, cb) {
    // from might be lowercased address (web3)
    if (payload.params && payload.params.length > 0 && payload.params[0].from) {
      payload.params[0].from = ethJSUtil.toChecksumAddress(payload.params[0].from);
    }

    processTx(this.executionContext, this.accounts, payload, false, cb);
  }

  eth_getTransactionReceipt(payload, cb) {
    this.executionContext.web3().eth.getTransactionReceipt(payload.params[0], (error, receipt) => {
      if (error) {
        return cb(error);
      }

      const txBlock = this.executionContext.txs[receipt.hash];
      const r = {
        'transactionHash': receipt.hash,
        'transactionIndex': '0x00',
        'blockHash': '0x' + txBlock.hash().toString('hex'),
        'blockNumber': '0x' + txBlock.header.number.toString('hex'),
        'gasUsed': Web3.utils.toHex(receipt.gas),
        'cumulativeGasUsed': Web3.utils.toHex(receipt.gas),
        'contractAddress': receipt.contractAddress,
        'logs': receipt.logs,
        'status': receipt.status
      };

      if (r.blockNumber === '0x') {
        r.blockNumber = '0x0';
      }

      cb(null, r);
    });
  }

  eth_estimateGas(payload, cb) {
    cb(null, 3000000);
  }

  eth_getCode(payload, cb) {
    let address = payload.params[0];
    this.executionContext.web3().eth.getCode(address, (error, result) => {
      if (error) {
        console.dir('error getting code');
        console.dir(error);
      }

      cb(error, result);
    });
  }

  eth_call(payload, cb) {
    // from might be lowercased address (web3)
    if (payload.params && payload.params.length > 0 && payload.params[0].from) {
      payload.params[0].from = ethJSUtil.toChecksumAddress(payload.params[0].from);
    }

    if (payload.params && payload.params.length > 0 && payload.params[0].to) {
      payload.params[0].to = ethJSUtil.toChecksumAddress(payload.params[0].to);
    }

    payload.params[0].value = undefined;
    processTx(this.executionContext, this.accounts, payload, true, cb);
  }

  eth_getTransactionCount(payload, cb) {
    let address = payload.params[0];
    this.executionContext.vm().stateManager.getAccount(address, (err, account) => {
      if (err) {
        return cb(err);
      }

      let nonce = new BN(account.nonce).toString(10);
      cb(null, nonce);
    });
  }

  eth_getTransactionByHash(payload, cb) {
    const address = payload.params[0];
    this.executionContext.web3().eth.getTransactionReceipt(address, (error, receipt) => {
      if (error) {
        return cb(error);
      }

      const txBlock = this.executionContext.txs[receipt.transactionHash]; // TODO: params to add later

      const r = {
        'blockHash': '0x' + txBlock.hash().toString('hex'),
        'blockNumber': '0x' + txBlock.header.number.toString('hex'),
        'from': receipt.from,
        'gas': Web3.utils.toHex(receipt.gas),
        // 'gasPrice': '2000000000000', // 0x123
        'gasPrice': '0x4a817c800',
        'hash': receipt.transactionHash,
        'input': receipt.input,
        // "nonce": 2, // 0x15
        // "transactionIndex": 0,
        'value': receipt.value // "value":"0xf3dbb76162000" // 4290000000000000
        // "v": "0x25", // 37
        // "r": "0x1b5e176d927f8e9ab405058b2d2457392da3e20f328b16ddabcebc33eaac5fea",
        // "s": "0x4ba69724e8f69de52f0125ad8b3c5c2cef33019bac3249e2c0a2192766d1721c"

      };

      if (receipt.to) {
        r.to = receipt.to;
      }

      if (r.value === '0x') {
        r.value = '0x0';
      }

      if (r.blockNumber === '0x') {
        r.blockNumber = '0x0';
      }

      cb(null, r);
    });
  }

  eth_getTransactionByBlockHashAndIndex(payload, cb) {
    const txIndex = payload.params[1];
    const txBlock = this.executionContext.blocks[payload.params[0]];
    const txHash = '0x' + txBlock.transactions[Web3.utils.toDecimal(txIndex)].hash().toString('hex');
    this.executionContext.web3().eth.getTransactionReceipt(txHash, (error, receipt) => {
      if (error) {
        return cb(error);
      } // TODO: params to add later


      let r = {
        'blockHash': '0x' + txBlock.hash().toString('hex'),
        'blockNumber': '0x' + txBlock.header.number.toString('hex'),
        'from': receipt.from,
        'gas': Web3.utils.toHex(receipt.gas),
        // 'gasPrice': '2000000000000', // 0x123
        'gasPrice': '0x4a817c800',
        'hash': receipt.transactionHash,
        'input': receipt.input,
        // "nonce": 2, // 0x15
        // "transactionIndex": 0,
        'value': receipt.value // "value":"0xf3dbb76162000" // 4290000000000000
        // "v": "0x25", // 37
        // "r": "0x1b5e176d927f8e9ab405058b2d2457392da3e20f328b16ddabcebc33eaac5fea",
        // "s": "0x4ba69724e8f69de52f0125ad8b3c5c2cef33019bac3249e2c0a2192766d1721c"

      };

      if (receipt.to) {
        r.to = receipt.to;
      }

      if (r.value === '0x') {
        r.value = '0x0';
      }

      cb(null, r);
    });
  }

  eth_getTransactionByBlockNumberAndIndex(payload, cb) {
    const txIndex = payload.params[1];
    const txBlock = this.executionContext.blocks[payload.params[0]];
    const txHash = '0x' + txBlock.transactions[Web3.utils.toDecimal(txIndex)].hash().toString('hex');
    this.executionContext.web3().eth.getTransactionReceipt(txHash, (error, receipt) => {
      if (error) {
        return cb(error);
      } // TODO: params to add later


      const r = {
        'blockHash': '0x' + txBlock.hash().toString('hex'),
        'blockNumber': '0x' + txBlock.header.number.toString('hex'),
        'from': receipt.from,
        'gas': Web3.utils.toHex(receipt.gas),
        // 'gasPrice': '2000000000000', // 0x123
        'gasPrice': '0x4a817c800',
        'hash': receipt.transactionHash,
        'input': receipt.input,
        // "nonce": 2, // 0x15
        // "transactionIndex": 0,
        'value': receipt.value // "value":"0xf3dbb76162000" // 4290000000000000
        // "v": "0x25", // 37
        // "r": "0x1b5e176d927f8e9ab405058b2d2457392da3e20f328b16ddabcebc33eaac5fea",
        // "s": "0x4ba69724e8f69de52f0125ad8b3c5c2cef33019bac3249e2c0a2192766d1721c"

      };

      if (receipt.to) {
        r.to = receipt.to;
      }

      if (r.value === '0x') {
        r.value = '0x0';
      }

      cb(null, r);
    });
  }

}

module.exports = Transactions;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/methods/txProcess.js":
/*!***************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/methods/txProcess.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const RemixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const TxExecution = RemixLib.execution.txExecution;
const TxRunner = RemixLib.execution.txRunner;

function runCall(payload, from, to, data, value, gasLimit, txRunner, callbacks, callback) {
  const finalCallback = function (err, result) {
    if (err) {
      return callback(err);
    }

    const returnValue = result.result.execResult.returnValue.toString('hex');
    const toReturn = `0x${returnValue || '0'}`;
    return callback(null, toReturn);
  };

  TxExecution.callFunction(from, to, data, value, gasLimit, {
    constant: true
  }, txRunner, callbacks, finalCallback, true);
}

function runTx(payload, from, to, data, value, gasLimit, txRunner, callbacks, callback) {
  const finalCallback = function (err, result) {
    if (err) {
      return callback(err);
    }

    callback(null, result.transactionHash);
  };

  TxExecution.callFunction(from, to, data, value, gasLimit, {
    constant: false
  }, txRunner, callbacks, finalCallback, false);
}

function createContract(payload, from, data, value, gasLimit, txRunner, callbacks, callback) {
  const finalCallback = function (err, result) {
    if (err) {
      return callback(err);
    }

    callback(null, result.transactionHash);
  };

  TxExecution.createContract(from, data, value, gasLimit, txRunner, callbacks, finalCallback);
}

let txRunnerInstance;

function processTx(executionContext, accounts, payload, isCall, callback) {
  const api = {
    logMessage: msg => {},
    logHtmlMessage: msg => {},
    config: {
      getUnpersistedProperty: key => {
        return true;
      },
      get: () => {
        return true;
      }
    },
    detectNetwork: cb => {
      cb();
    },
    personalMode: () => {
      return false;
    }
  };
  executionContext.init(api.config); // let txRunner = new TxRunner(accounts, api)

  if (!txRunnerInstance) {
    txRunnerInstance = new TxRunner(accounts, api, executionContext);
  }

  txRunnerInstance.vmaccounts = accounts;
  let {
    from,
    to,
    data,
    value,
    gas
  } = payload.params[0];
  gas = gas || 3000000;
  let callbacks = {
    confirmationCb: (network, tx, gasEstimation, continueTxExecution, cancelCb) => {
      continueTxExecution(null);
    },
    gasEstimationForceSend: (error, continueTxExecution, cancelCb) => {
      if (error) {
        continueTxExecution(error);
      }

      continueTxExecution();
    },
    promptCb: (okCb, cancelCb) => {
      okCb();
    }
  };

  if (isCall) {
    runCall(payload, from, to, data, value, gas, txRunnerInstance, callbacks, callback);
  } else if (to) {
    runTx(payload, from, to, data, value, gas, txRunnerInstance, callbacks, callback);
  } else {
    createContract(payload, from, data, value, gas, txRunnerInstance, callbacks, callback);
  }
}

module.exports = processTx;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/provider.js":
/*!******************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/provider.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const RemixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const executionContext = RemixLib.execution.executionContext;

const log = __webpack_require__(/*! ./utils/logs.js */ "../../../dist/libs/remix-simulator/src/utils/logs.js");

const merge = __webpack_require__(/*! merge */ "../../../node_modules/merge/merge.js");

const Accounts = __webpack_require__(/*! ./methods/accounts.js */ "../../../dist/libs/remix-simulator/src/methods/accounts.js");

const Blocks = __webpack_require__(/*! ./methods/blocks.js */ "../../../dist/libs/remix-simulator/src/methods/blocks.js");

const Filters = __webpack_require__(/*! ./methods/filters.js */ "../../../dist/libs/remix-simulator/src/methods/filters.js");

const Misc = __webpack_require__(/*! ./methods/misc.js */ "../../../dist/libs/remix-simulator/src/methods/misc.js");

const Net = __webpack_require__(/*! ./methods/net.js */ "../../../dist/libs/remix-simulator/src/methods/net.js");

const Transactions = __webpack_require__(/*! ./methods/transactions.js */ "../../../dist/libs/remix-simulator/src/methods/transactions.js");

const generateBlock = __webpack_require__(/*! ./genesis.js */ "../../../dist/libs/remix-simulator/src/genesis.js");

class Provider {
  constructor(options = {}) {
    this.options = options; // TODO: init executionContext here

    this.executionContext = executionContext;
    this.Accounts = new Accounts(this.executionContext);
    this.Transactions = new Transactions(this.executionContext);
    this.methods = {};
    this.methods = merge(this.methods, this.Accounts.methods());
    this.methods = merge(this.methods, new Blocks(this.executionContext, options).methods());
    this.methods = merge(this.methods, new Misc().methods());
    this.methods = merge(this.methods, new Filters(this.executionContext).methods());
    this.methods = merge(this.methods, new Net().methods());
    this.methods = merge(this.methods, this.Transactions.methods());
    generateBlock(this.executionContext);
    this.init();
  }

  init() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      yield this.Accounts.init();
      this.Transactions.init(this.Accounts.accounts);
    });
  }

  sendAsync(payload, callback) {
    log.info('payload method is ', payload.method);
    const method = this.methods[payload.method];

    if (this.options.logDetails) {
      log.info(payload);
    }

    if (method) {
      return method.call(method, payload, (err, result) => {
        if (this.options.logDetails) {
          log.info(err);
          log.info(result);
        }

        if (err) {
          return callback(err);
        }

        const response = {
          'id': payload.id,
          'jsonrpc': '2.0',
          'result': result
        };
        callback(null, response);
      });
    }

    callback(new Error('unknown method ' + payload.method));
  }

  send(payload, callback) {
    this.sendAsync(payload, callback || function () {});
  }

  isConnected() {
    return true;
  }

  on(type, cb) {
    this.executionContext.logsManager.addListener(type, cb);
  }

}

module.exports = Provider;

/***/ }),

/***/ "../../../dist/libs/remix-simulator/src/utils/logs.js":
/*!********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-simulator/src/utils/logs.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

const gray = __webpack_require__(/*! ansi-gray */ "../../../node_modules/ansi-gray/index.js");

const timestamp = __webpack_require__(/*! time-stamp */ "../../../node_modules/time-stamp/index.js");

const supportsColor = __webpack_require__(/*! color-support */ "../../../node_modules/color-support/browser.js");

function hasFlag(flag) {
  return typeof process !== 'undefined' && process.argv.indexOf('--' + flag) !== -1;
}

function addColor(str) {
  if (hasFlag('no-color')) {
    return str;
  }

  if (hasFlag('color')) {
    return gray(str);
  }

  if (supportsColor()) {
    return gray(str);
  }

  return str;
}

const logger = {
  stdout: function (arg) {
    if (typeof process === 'undefined' || !process.stdout) return;
    process.stdout.write(arg);
  },
  stderr: function (arg) {
    if (typeof process === 'undefined' || process.stderr) return;
    process.stderr.write(arg);
  }
};

function getTimestamp() {
  const coloredTimestamp = addColor(timestamp('HH:mm:ss'));
  return '[' + coloredTimestamp + ']';
}

function log() {
  const time = getTimestamp();
  logger.stdout(time + ' ');
  console.log.apply(console, arguments);
  return this;
}

function info() {
  const time = getTimestamp();
  logger.stdout(time + ' ');
  console.info.apply(console, arguments);
  return this;
}

function dir() {
  const time = getTimestamp();
  logger.stdout(time + ' ');
  console.dir.apply(console, arguments);
  return this;
}

function warn() {
  const time = getTimestamp();
  logger.stderr(time + ' ');
  console.warn.apply(console, arguments);
  return this;
}

function error() {
  const time = getTimestamp();
  logger.stderr(time + ' ');
  console.error.apply(console, arguments);
  return this;
}

module.exports = log;
module.exports.info = info;
module.exports.dir = dir;
module.exports.warn = warn;
module.exports.error = error;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/process/browser.js */ "../../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../../dist/libs/remix-solidity/compiler/compiler-input.js":
/*!****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-solidity/compiler/compiler-input.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = (sources, opts) => {
  const o = {
    language: 'Solidity',
    sources: sources,
    settings: {
      optimizer: {
        enabled: opts.optimize === true || opts.optimize === 1,
        runs: 200
      },
      libraries: opts.libraries,
      outputSelection: {
        '*': {
          '': ['legacyAST', 'ast'],
          '*': ['abi', 'metadata', 'devdoc', 'userdoc', 'evm.legacyAssembly', 'evm.bytecode', 'evm.deployedBytecode', 'evm.methodIdentifiers', 'evm.gasEstimates']
        }
      }
    }
  };

  if (opts.evmVersion) {
    o.settings.evmVersion = opts.evmVersion;
  }

  if (opts.language) {
    o.language = opts.language;
  }

  if (opts.language === 'Yul' && o.settings.optimizer.enabled) {
    if (!o.settings.optimizer.details) o.settings.optimizer.details = {};
    o.settings.optimizer.details.yul = true;
  }

  return JSON.stringify(o);
};

/***/ }),

/***/ "../../../dist/libs/remix-solidity/compiler/compiler-worker.js":
/*!*****************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-solidity/compiler/compiler-worker.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const solc = __webpack_require__(/*! solc/wrapper */ "../../../node_modules/solc/wrapper.js");

let compileJSON = input => {
  return '';
};

const missingInputs = []; // 'DedicatedWorkerGlobalScope' object (the Worker global scope) is accessible through the self keyword
// 'dom' and 'webworker' library files can't be included together https://github.com/microsoft/TypeScript/issues/20595

function default_1(self) {
  self.addEventListener('message', e => {
    const data = e.data;

    switch (data.cmd) {
      case 'loadVersion':
        {
          delete self.Module; // NOTE: workaround some browsers?

          self.Module = undefined;
          compileJSON = null; //importScripts() method of synchronously imports one or more scripts into the worker's scope

          self.importScripts(data.data);
          const compiler = solc(self.Module);

          compileJSON = input => {
            try {
              const missingInputsCallback = path => {
                missingInputs.push(path);
                return {
                  'error': 'Deferred import'
                };
              };

              return compiler.compile(input, {
                import: missingInputsCallback
              });
            } catch (exception) {
              return JSON.stringify({
                error: 'Uncaught JavaScript exception:\n' + exception
              });
            }
          };

          self.postMessage({
            cmd: 'versionLoaded',
            data: compiler.version()
          });
          break;
        }

      case 'compile':
        missingInputs.length = 0;

        if (data.input && compileJSON) {
          self.postMessage({
            cmd: 'compiled',
            job: data.job,
            data: compileJSON(data.input),
            missingInputs: missingInputs
          });
        }

        break;
    }
  }, false);
}

exports.default = default_1;

/***/ }),

/***/ "../../../dist/libs/remix-solidity/compiler/compiler.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-solidity/compiler/compiler.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const abi_1 = __webpack_require__(/*! solc/abi */ "../../../node_modules/solc/abi.js");

const webworkify = __webpack_require__(/*! webworkify-webpack */ "../../../node_modules/webworkify-webpack/index.js");

const compiler_input_1 = __webpack_require__(/*! ./compiler-input */ "../../../dist/libs/remix-solidity/compiler/compiler-input.js");

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const txHelper_1 = __webpack_require__(/*! ./txHelper */ "../../../dist/libs/remix-solidity/compiler/txHelper.js");
/*
  trigger compilationFinished, compilerLoaded, compilationStarted, compilationDuration
*/


class Compiler {
  constructor(handleImportCall) {
    this.handleImportCall = handleImportCall;
    this.event = new remix_lib_1.EventManager();
    this.state = {
      compileJSON: null,
      worker: null,
      currentVersion: null,
      optimize: false,
      evmVersion: null,
      language: 'Solidity',
      compilationStartTime: null,
      target: null,
      lastCompilationResult: {
        data: null,
        source: null
      }
    };
    this.event.register('compilationFinished', (success, data, source) => {
      if (success && this.state.compilationStartTime) {
        this.event.trigger('compilationDuration', [new Date().getTime() - this.state.compilationStartTime]);
      }

      this.state.compilationStartTime = null;
    });
    this.event.register('compilationStarted', () => {
      this.state.compilationStartTime = new Date().getTime();
    });
  }
  /**
   * @dev Setter function for CompilerState's properties (used by IDE)
   * @param key key
   * @param value value of key in CompilerState
   */


  set(key, value) {
    this.state[key] = value;
  }
  /**
   * @dev Internal function to compile the contract after gathering imports
   * @param files source file
   * @param missingInputs missing import file path list
   */


  internalCompile(files, missingInputs) {
    this.gatherImports(files, missingInputs, (error, input) => {
      if (error) {
        this.state.lastCompilationResult = null;
        this.event.trigger('compilationFinished', [false, {
          'error': {
            formattedMessage: error,
            severity: 'error'
          }
        }, files]);
      } else if (this.state.compileJSON && input) this.state.compileJSON(input);
    });
  }
  /**
   * @dev Compile source files (used by IDE)
   * @param files source files
   * @param target target file name (This is passed as it is to IDE)
   */


  compile(files, target) {
    this.state.target = target;
    this.event.trigger('compilationStarted', []);
    this.internalCompile(files);
  }
  /**
   * @dev Called when compiler is loaded, set current compiler version
   * @param version compiler version
   */


  onCompilerLoaded(version) {
    this.state.currentVersion = version;
    this.event.trigger('compilerLoaded', [version]);
  }
  /**
   * @dev Called when compiler is loaded internally (without worker)
   */


  onInternalCompilerLoaded() {
    if (this.state.worker === null) {
      const compiler = typeof window !== 'undefined' && window['Module'] ? __webpack_require__(/*! solc/wrapper */ "../../../node_modules/solc/wrapper.js")(window['Module']) : __webpack_require__(/*! solc */ "../../../node_modules/solc/index.js");

      this.state.compileJSON = source => {
        const missingInputs = [];

        const missingInputsCallback = path => {
          missingInputs.push(path);
          return {
            error: 'Deferred import'
          };
        };

        let result = {};

        try {
          if (source && source.sources) {
            const input = compiler_input_1.default(source.sources, {
              optimize: this.state.optimize,
              evmVersion: this.state.evmVersion,
              language: this.state.language
            });
            result = JSON.parse(compiler.compile(input, {
              import: missingInputsCallback
            }));
          }
        } catch (exception) {
          result = {
            error: {
              formattedMessage: 'Uncaught JavaScript exception:\n' + exception,
              severity: 'error',
              mode: 'panic'
            }
          };
        }

        this.onCompilationFinished(result, missingInputs, source);
      };

      this.onCompilerLoaded(compiler.version());
    }
  }
  /**
   * @dev Called when compilation is finished
   * @param data compilation result data
   * @param missingInputs missing imports
   * @param source Source
   */


  onCompilationFinished(data, missingInputs, source) {
    let noFatalErrors = true; // ie warnings are ok

    const checkIfFatalError = error => {
      // Ignore warnings and the 'Deferred import' error as those are generated by us as a workaround
      const isValidError = error.message && error.message.includes('Deferred import') ? false : error.severity !== 'warning';
      if (isValidError) noFatalErrors = false;
    };

    if (data.error) checkIfFatalError(data.error);
    if (data.errors) data.errors.forEach(err => checkIfFatalError(err));

    if (!noFatalErrors) {
      // There are fatal errors, abort here
      this.state.lastCompilationResult = null;
      this.event.trigger('compilationFinished', [false, data, source]);
    } else if (missingInputs !== undefined && missingInputs.length > 0 && source && source.sources) {
      // try compiling again with the new set of inputs
      this.internalCompile(source.sources, missingInputs);
    } else {
      data = this.updateInterface(data);

      if (source) {
        source.target = this.state.target;
        this.state.lastCompilationResult = {
          data: data,
          source: source
        };
      }

      this.event.trigger('compilationFinished', [true, data, source]);
    }
  }
  /**
   * @dev Load compiler using given URL (used by IDE)
   * @param usingWorker if true, load compiler using worker
   * @param url URL to load compiler from
   */


  loadVersion(usingWorker, url) {
    console.log('Loading ' + url + ' ' + (usingWorker ? 'with worker' : 'without worker'));
    this.event.trigger('loadingCompiler', [url, usingWorker]);

    if (this.state.worker) {
      this.state.worker.terminate();
      this.state.worker = null;
    }

    if (usingWorker) {
      this.loadWorker(url);
    } else {
      this.loadInternal(url);
    }
  }
  /**
   * @dev Load compiler using 'script' element (without worker)
   * @param url URL to load compiler from
   */


  loadInternal(url) {
    delete window['Module']; // NOTE: workaround some browsers?

    window['Module'] = undefined; // Set a safe fallback until the new one is loaded

    this.state.compileJSON = source => {
      this.onCompilationFinished({
        error: {
          formattedMessage: 'Compiler not yet loaded.'
        }
      });
    };

    const newScript = document.createElement('script');
    newScript.type = 'text/javascript';
    newScript.src = url;
    document.getElementsByTagName('head')[0].appendChild(newScript);
    const check = window.setInterval(() => {
      if (!window['Module']) {
        return;
      }

      window.clearInterval(check);
      this.onInternalCompilerLoaded();
    }, 200);
  }
  /**
   * @dev Load compiler using web worker
   * @param url URL to load compiler from
   */


  loadWorker(url) {
    this.state.worker = webworkify(/*require.resolve*/(/*! ./compiler-worker */ "../../../dist/libs/remix-solidity/compiler/compiler-worker.js"));
    const jobs = [];
    this.state.worker.addEventListener('message', msg => {
      const data = msg.data;

      switch (data.cmd) {
        case 'versionLoaded':
          if (data.data) this.onCompilerLoaded(data.data);
          break;

        case 'compiled':
          {
            let result;

            if (data.data && data.job !== undefined && data.job >= 0) {
              try {
                result = JSON.parse(data.data);
              } catch (exception) {
                result = {
                  error: {
                    formattedMessage: 'Invalid JSON output from the compiler: ' + exception
                  }
                };
              }

              let sources = {};

              if (data.job in jobs !== undefined) {
                sources = jobs[data.job].sources;
                delete jobs[data.job];
              }

              this.onCompilationFinished(result, data.missingInputs, sources);
            }

            break;
          }
      }
    });
    this.state.worker.addEventListener('error', msg => {
      this.onCompilationFinished({
        error: {
          formattedMessage: 'Worker error: ' + msg.data
        }
      });
    });

    this.state.compileJSON = source => {
      if (source && source.sources) {
        jobs.push({
          sources: source
        });
        this.state.worker.postMessage({
          cmd: 'compile',
          job: jobs.length - 1,
          input: compiler_input_1.default(source.sources, {
            optimize: this.state.optimize,
            evmVersion: this.state.evmVersion,
            language: this.state.language
          })
        });
      }
    };

    this.state.worker.postMessage({
      cmd: 'loadVersion',
      data: url
    });
  }
  /**
   * @dev Gather imports for compilation
   * @param files file sources
   * @param importHints import file list
   * @param cb callback
   */


  gatherImports(files, importHints, cb) {
    importHints = importHints || []; // FIXME: This will only match imports if the file begins with one '.'
    // It should tokenize by lines and check each.

    const importRegex = /^\s*import\s*['"]([^'"]+)['"];/g;

    for (const fileName in files) {
      let match;

      while (match = importRegex.exec(files[fileName].content)) {
        let importFilePath = match[1];

        if (importFilePath.startsWith('./')) {
          const path = /(.*\/).*/.exec(fileName);
          importFilePath = path ? importFilePath.replace('./', path[1]) : importFilePath.slice(2);
        }

        if (!importHints.includes(importFilePath)) importHints.push(importFilePath);
      }
    }

    while (importHints.length > 0) {
      const m = importHints.pop();
      if (m && m in files) continue;

      if (this.handleImportCall) {
        this.handleImportCall(m, (err, content) => {
          if (err && cb) cb(err);else {
            files[m] = {
              content
            };
            this.gatherImports(files, importHints, cb);
          }
        });
      }

      return;
    }

    if (cb) cb(null, {
      'sources': files
    });
  }
  /**
   * @dev Truncate version string
   * @param version version
   */


  truncateVersion(version) {
    const tmp = /^(\d+.\d+.\d+)/.exec(version);
    return tmp ? tmp[1] : version;
  }
  /**
   * @dev Update ABI according to current compiler version
   * @param data Compilation result
   */


  updateInterface(data) {
    txHelper_1.default.visitContracts(data.contracts, contract => {
      if (!contract.object.abi) contract.object.abi = [];

      if (this.state.language === 'Yul' && contract.object.abi.length === 0) {
        // yul compiler does not return any abi,
        // we default to accept the fallback function (which expect raw data as argument).
        contract.object.abi.push({
          'payable': true,
          'stateMutability': 'payable',
          'type': 'fallback'
        });
      }

      if (data && data.contracts && this.state.currentVersion) data.contracts[contract.file][contract.name].abi = abi_1.update(this.truncateVersion(this.state.currentVersion), contract.object.abi);
    });
    return data;
  }
  /**
   * @dev Get contract obj of the given contract name from last compilation result.
   * @param name contract name
   */


  getContract(name) {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.contracts) {
      return txHelper_1.default.getContract(name, this.state.lastCompilationResult.data.contracts);
    }

    return null;
  }
  /**
   * @dev Call the given callback for all the contracts from last compilation result
   * @param cb callback
   */


  visitContracts(cb) {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.contracts) {
      return txHelper_1.default.visitContracts(this.state.lastCompilationResult.data.contracts, cb);
    }

    return null;
  }
  /**
   * @dev Get the compiled contracts data from last compilation result
   */


  getContracts() {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.contracts) {
      return this.state.lastCompilationResult.data.contracts;
    }

    return null;
  }
  /**
   * @dev Get sources from last compilation result
   */


  getSources() {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.source) {
      return this.state.lastCompilationResult.source.sources;
    }

    return null;
  }
  /**
   * @dev Get sources of passed file name from last compilation result
   * @param fileName file name
   */


  getSource(fileName) {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.source && this.state.lastCompilationResult.source.sources) {
      return this.state.lastCompilationResult.source.sources[fileName];
    }

    return null;
  }
  /**
   * @dev Get source name at passed index from last compilation result
   * @param index    - index of the source
   */


  getSourceName(index) {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.sources) {
      return Object.keys(this.state.lastCompilationResult.data.sources)[index];
    }

    return null;
  }

}

exports.Compiler = Compiler;

/***/ }),

/***/ "../../../dist/libs/remix-solidity/compiler/txHelper.js":
/*!**********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-solidity/compiler/txHelper.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  /**
   * @dev Get contract obj of given contract name from last compilation result.
   * @param name contract name
   * @param contracts 'contracts' object from last compilation result
   */
  getContract: (contractName, contracts) => {
    for (const file in contracts) {
      if (contracts[file][contractName]) {
        return {
          object: contracts[file][contractName],
          file: file
        };
      }
    }

    return null;
  },

  /**
   * @dev call the given callback for all contracts from last compilation result, stop visiting when cb return true
   * @param contracts - 'contracts' object from last compilation result
   * @param cb    - callback
   */
  visitContracts: (contracts, cb) => {
    for (const file in contracts) {
      for (const name in contracts[file]) {
        const param = {
          name: name,
          object: contracts[file][name],
          file: file
        };
        if (cb(param)) return;
      }
    }
  }
};

/***/ }),

/***/ "../../../dist/libs/remix-solidity/index.js":
/*!**********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-solidity/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var compiler_1 = __webpack_require__(/*! ./compiler/compiler */ "../../../dist/libs/remix-solidity/compiler/compiler.js");

exports.Compiler = compiler_1.Compiler;

var compiler_input_1 = __webpack_require__(/*! ./compiler/compiler-input */ "../../../dist/libs/remix-solidity/compiler/compiler-input.js");

exports.CompilerInput = compiler_input_1.default;

/***/ }),

/***/ "../../../dist/libs/remix-tests/sol/tests.sol.js":
/*!***************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/sol/tests.sol.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = `
pragma solidity >=0.4.22 <0.7.0;

library Assert {

  event AssertionEvent(
    bool passed,
    string message
  );

  function ok(bool a, string memory message) public returns (bool result) {
    result = a;
    emit AssertionEvent(result, message);
  }

  function equal(uint a, uint b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEvent(result, message);
  }

  function equal(int a, int b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEvent(result, message);
  }

  function equal(bool a, bool b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEvent(result, message);
  }

  // TODO: only for certain versions of solc
  //function equal(fixed a, fixed b, string message) public returns (bool result) {
  //  result = (a == b);
  //  emit AssertionEvent(result, message);
  //}

  // TODO: only for certain versions of solc
  //function equal(ufixed a, ufixed b, string message) public returns (bool result) {
  //  result = (a == b);
  //  emit AssertionEvent(result, message);
  //}

  function equal(address a, address b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEvent(result, message);
  }

  function equal(bytes32 a, bytes32 b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEvent(result, message);
  }

  function equal(string memory a, string memory b, string memory message) public returns (bool result) {
     result = (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b)));
     emit AssertionEvent(result, message);
  }

  function notEqual(uint a, uint b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEvent(result, message);
  }

  function notEqual(int a, int b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEvent(result, message);
  }

  function notEqual(bool a, bool b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEvent(result, message);
  }

  // TODO: only for certain versions of solc
  //function notEqual(fixed a, fixed b, string message) public returns (bool result) {
  //  result = (a != b);
  //  emit AssertionEvent(result, message);
  //}

  // TODO: only for certain versions of solc
  //function notEqual(ufixed a, ufixed b, string message) public returns (bool result) {
  //  result = (a != b);
  //  emit AssertionEvent(result, message);
  //}

  function notEqual(address a, address b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEvent(result, message);
  }

  function notEqual(bytes32 a, bytes32 b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEvent(result, message);
  }

  function notEqual(string memory a, string memory b, string memory message) public returns (bool result) {
    result = (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b)));
    emit AssertionEvent(result, message);
  }

  /*----------------- Greater than --------------------*/
  function greaterThan(uint a, uint b, string memory message) public returns (bool result) {
    result = (a > b);
    emit AssertionEvent(result, message);
  }

  function greaterThan(int a, int b, string memory message) public returns (bool result) {
    result = (a > b);
    emit AssertionEvent(result, message);
  }
  // TODO: safely compare between uint and int
  function greaterThan(uint a, int b, string memory message) public returns (bool result) {
    if(b < int(0)) {
      // int is negative uint "a" always greater
      result = true;
    } else {
      result = (a > uint(b));
    }
    emit AssertionEvent(result, message);
  }
  function greaterThan(int a, uint b, string memory message) public returns (bool result) {
    if(a < int(0)) {
      // int is negative uint "b" always greater
      result = false;
    } else {
      result = (uint(a) > b);
    }
    emit AssertionEvent(result, message);
  }
  /*----------------- Lesser than --------------------*/
  function lesserThan(uint a, uint b, string memory message) public returns (bool result) {
    result = (a < b);
    emit AssertionEvent(result, message);
  }

  function lesserThan(int a, int b, string memory message) public returns (bool result) {
    result = (a < b);
    emit AssertionEvent(result, message);
  }
  // TODO: safely compare between uint and int
  function lesserThan(uint a, int b, string memory message) public returns (bool result) {
    if(b < int(0)) {
      // int is negative int "b" always lesser
      result = false;
    } else {
      result = (a < uint(b));
    }
    emit AssertionEvent(result, message);
  }

  function lesserThan(int a, uint b, string memory message) public returns (bool result) {
    if(a < int(0)) {
      // int is negative int "a" always lesser
      result = true;
    } else {
      result = (uint(a) < b);
    }
    emit AssertionEvent(result, message);
  }
}
`;

/***/ }),

/***/ "../../../dist/libs/remix-tests/sol/tests_accounts.sol.js":
/*!************************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/sol/tests_accounts.sol.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = `
library TestsAccounts {
    function getAccount(uint index) public returns (address) {
        >accounts<
        return accounts[index];
    }
}
`;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/compiler.js":
/*!**************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/compiler.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const fileSystem_1 = tslib_1.__importDefault(__webpack_require__(/*! ./fileSystem */ "../../../dist/libs/remix-tests/src/fileSystem.js"));

const async_1 = tslib_1.__importDefault(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

const path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ "../../../node_modules/path-browserify/index.js"));

const remix_solidity_1 = __webpack_require__(/*! @remix-project/remix-solidity */ "../../../dist/libs/remix-solidity/index.js");

const types_1 = __webpack_require__(/*! ./types */ "../../../dist/libs/remix-tests/src/types.js");

function regexIndexOf(inputString, regex, startpos = 0) {
  const indexOf = inputString.substring(startpos).search(regex);
  return indexOf >= 0 ? indexOf + startpos : indexOf;
}

function writeTestAccountsContract(accounts) {
  const testAccountContract = __webpack_require__(/*! ../sol/tests_accounts.sol */ "../../../dist/libs/remix-tests/sol/tests_accounts.sol.js");

  let body = `address[${accounts.length}] memory accounts;`;
  if (!accounts.length) body += ';';else {
    accounts.map((address, index) => {
      body += `\naccounts[${index}] = ${address};\n`;
    });
  }
  return testAccountContract.replace('>accounts<', body);
}
/**
 * @dev Check if path includes name of a remix test file
 * @param path file path to check
 */


function isRemixTestFile(path) {
  return ['tests.sol', 'remix_tests.sol', 'remix_accounts.sol'].some(name => path.includes(name));
}
/**
 * @dev Process file to prepare sources object to be passed in solc compiler input
 *
 * See: https://solidity.readthedocs.io/en/latest/using-the-compiler.html#input-description
 *
 * @param filePath path of file to process
 * @param sources existing 'sources' object in which keys are the "global" names of the source files and
 *                value is object containing content of corresponding file with under key 'content'
 * @param isRoot True, If file is a root test contract file which is getting processed, not an imported file
 */


function processFile(filePath, sources, isRoot = false) {
  const importRegEx = /import ['"](.+?)['"];/g;
  let group = null;
  const isFileAlreadyInSources = Object.keys(sources).includes(filePath); // Return if file is a remix test file or already processed

  if (isRemixTestFile(filePath) || isFileAlreadyInSources) return;
  let content = fileSystem_1.default.readFileSync(filePath, {
    encoding: 'utf-8'
  });
  const testFileImportRegEx = /^(import)\s['"](remix_tests.sol|tests.sol)['"];/gm; // import 'remix_tests.sol', if file is a root test contract file and doesn't already have it 

  if (isRoot && filePath.endsWith('_test.sol') && regexIndexOf(content, testFileImportRegEx) < 0) {
    const includeTestLibs = '\nimport \'remix_tests.sol\';\n';
    content = includeTestLibs.concat(content);
  }

  sources[filePath] = {
    content
  };
  importRegEx.exec(''); // Resetting state of RegEx
  // Process each 'import' in file content

  while (group = importRegEx.exec(content)) {
    const importedFile = group[1];
    const importedFilePath = path_1.default.join(path_1.default.dirname(filePath), importedFile);
    processFile(importedFilePath, sources);
  }
}

const userAgent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '-';
const isBrowser = !(typeof window === 'undefined' || userAgent.indexOf(' electron/') > -1);
/**
 * @dev Compile file or files before running tests (used for CLI execution)
 * @param filename Name of file
 * @param isDirectory True, if path is a directory
 * @param opts Options
 * @param cb Callback
 *
 * TODO: replace this with remix's own compiler code
 */

function compileFileOrFiles(filename, isDirectory, opts, cb) {
  let compiler;
  const accounts = opts.accounts || [];
  const sources = {
    'tests.sol': {
      content: __webpack_require__(/*! ../sol/tests.sol */ "../../../dist/libs/remix-tests/sol/tests.sol.js")
    },
    'remix_tests.sol': {
      content: __webpack_require__(/*! ../sol/tests.sol */ "../../../dist/libs/remix-tests/sol/tests.sol.js")
    },
    'remix_accounts.sol': {
      content: writeTestAccountsContract(accounts)
    }
  };
  const filepath = isDirectory ? filename : path_1.default.dirname(filename);

  try {
    if (!isDirectory && fileSystem_1.default.existsSync(filename)) {
      if (filename.split('.').pop() === 'sol') {
        processFile(filename, sources, true);
      } else {
        throw new Error('Not a solidity file');
      }
    } else {
      // walkSync only if it is a directory
      fileSystem_1.default.walkSync(filepath, foundpath => {
        // only process .sol files
        if (foundpath.split('.').pop() === 'sol') {
          processFile(foundpath, sources, true);
        }
      });
    }
  } catch (e) {
    // eslint-disable-line no-useless-catch
    throw e;
  } finally {
    async_1.default.waterfall([function loadCompiler(next) {
      compiler = new remix_solidity_1.Compiler();
      compiler.onInternalCompilerLoaded(); // compiler.event.register('compilerLoaded', this, function (version) {

      next(); // });
    }, function doCompilation(next) {
      // @ts-ignore
      compiler.event.register('compilationFinished', this, (success, data, source) => {
        next(null, data);
      });
      compiler.compile(sources, filepath);
    }], function (err, result) {
      const error = [];
      if (result.error) error.push(result.error);
      const errors = (result.errors || error).filter(e => e.type === 'Error' || e.severity === 'error');

      if (errors.length > 0) {
        if (!isBrowser) __webpack_require__(/*! signale */ "../../../node_modules/signale/index.js").fatal(errors);
        return cb(new types_1.CompilationErrors(errors));
      }

      cb(err, result.contracts, result.sources); //return callback with contract details & ASTs
    });
  }
}

exports.compileFileOrFiles = compileFileOrFiles;
/**
 * @dev Compile contract source before running tests (used for IDE tests execution)
 * @param sources sources
 * @param compilerConfig current compiler configuration
 * @param importFileCb Import file callback
 * @param opts Options
 * @param cb Callback
 */

function compileContractSources(sources, compilerConfig, importFileCb, opts, cb) {
  let compiler, filepath;
  const accounts = opts.accounts || []; // Iterate over sources keys. Inject test libraries. Inject test library import statements.

  if (!('remix_tests.sol' in sources) && !('tests.sol' in sources)) {
    sources['tests.sol'] = {
      content: __webpack_require__(/*! ../sol/tests.sol.js */ "../../../dist/libs/remix-tests/sol/tests.sol.js")
    };
    sources['remix_tests.sol'] = {
      content: __webpack_require__(/*! ../sol/tests.sol.js */ "../../../dist/libs/remix-tests/sol/tests.sol.js")
    };
    sources['remix_accounts.sol'] = {
      content: writeTestAccountsContract(accounts)
    };
  }

  const testFileImportRegEx = /^(import)\s['"](remix_tests.sol|tests.sol)['"];/gm;
  const includeTestLibs = '\nimport \'remix_tests.sol\';\n';

  for (const file in sources) {
    const c = sources[file].content;

    if (file.endsWith('_test.sol') && c && regexIndexOf(c, testFileImportRegEx) < 0) {
      sources[file].content = includeTestLibs.concat(c);
    }
  }

  async_1.default.waterfall([function loadCompiler(next) {
    const {
      currentCompilerUrl,
      evmVersion,
      optimize,
      usingWorker
    } = compilerConfig;
    compiler = new remix_solidity_1.Compiler(importFileCb);
    compiler.set('evmVersion', evmVersion);
    compiler.set('optimize', optimize);
    compiler.loadVersion(usingWorker, currentCompilerUrl); // @ts-ignore

    compiler.event.register('compilerLoaded', this, version => {
      next();
    });
  }, function doCompilation(next) {
    // @ts-ignore
    compiler.event.register('compilationFinished', this, (success, data, source) => {
      next(null, data);
    });
    compiler.compile(sources, filepath);
  }], function (err, result) {
    const error = [];
    if (result.error) error.push(result.error);
    const errors = (result.errors || error).filter(e => e.type === 'Error' || e.severity === 'error');

    if (errors.length > 0) {
      if (!isBrowser) __webpack_require__(/*! signale */ "../../../node_modules/signale/index.js").fatal(errors);
      return cb(new types_1.CompilationErrors(errors));
    }

    cb(err, result.contracts, result.sources); // return callback with contract details & ASTs
  });
}

exports.compileContractSources = compileContractSources;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/deployer.js":
/*!**************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/deployer.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const async_1 = tslib_1.__importDefault(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

const remix_lib_1 = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");
/**
 * @dev Deploy all contracts from compilation result
 * @param compileResult compilation result
 * @param web3 web3 object
 * @param withDoubleGas If true, try deployment with gas double of estimation (used for Out-of-gas error only)
 * @param callback Callback
 */


function deployAll(compileResult, web3, withDoubleGas, callback) {
  const compiledObject = {};
  const contracts = {};
  let accounts = [];
  async_1.default.waterfall([function getAccountList(next) {
    web3.eth.getAccounts((_err, _accounts) => {
      accounts = _accounts;
      next();
    });
  }, function getContractData(next) {
    for (const contractFile in compileResult) {
      for (const contractName in compileResult[contractFile]) {
        const contract = compileResult[contractFile][contractName];
        const className = contractName;
        const filename = contractFile;
        const abi = contract.abi;
        const code = contract.evm.bytecode.object;
        compiledObject[className] = {};
        compiledObject[className].abi = abi;
        compiledObject[className].code = code;
        compiledObject[className].filename = filename;
        compiledObject[className].className = className;
        compiledObject[className].raw = contract;

        if (contractFile.endsWith('_test.sol')) {
          compiledObject[className].isTest = true;
        }
      }
    }

    next();
  }, function determineContractsToDeploy(next) {
    const contractsToDeploy = ['Assert'];
    const allContracts = Object.keys(compiledObject);

    for (const contractName of allContracts) {
      if (contractName === 'Assert') {
        continue;
      }

      if (compiledObject[contractName].isTest) {
        contractsToDeploy.push(contractName);
      }
    }

    next(null, contractsToDeploy);
  }, function deployContracts(contractsToDeploy, next) {
    const deployRunner = (deployObject, contractObject, contractName, filename, callback) => {
      deployObject.estimateGas().then(gasValue => {
        const gasBase = Math.ceil(gasValue * 1.2);
        const gas = withDoubleGas ? gasBase * 2 : gasBase;
        deployObject.send({
          from: accounts[0],
          gas: gas
        }).on('receipt', function (receipt) {
          contractObject.options.address = receipt.contractAddress;
          contractObject.options.from = accounts[0];
          contractObject.options.gas = 5000 * 1000;
          compiledObject[contractName].deployedAddress = receipt.contractAddress;
          contracts[contractName] = contractObject;
          contracts[contractName].filename = filename;
          callback(null, {
            result: {
              createdAddress: receipt.contractAddress
            }
          }); // TODO this will only work with JavaScriptV VM
        }).on('error', function (err) {
          console.error(err);
          callback(err);
        });
      });
    };

    async_1.default.eachOfLimit(contractsToDeploy, 1, function (contractName, index, nextEach) {
      const contract = compiledObject[contractName];

      const encodeDataFinalCallback = (error, contractDeployData) => {
        if (error) return nextEach(error);
        const contractObject = new web3.eth.Contract(contract.abi);
        const deployObject = contractObject.deploy({
          arguments: [],
          data: '0x' + contractDeployData.dataHex
        });
        deployRunner(deployObject, contractObject, contractName, contract.filename, error => {
          nextEach(error);
        });
      };

      const encodeDataStepCallback = msg => {
        console.dir(msg);
      };

      const encodeDataDeployLibraryCallback = (libData, callback) => {
        const abi = compiledObject[libData.data.contractName].abi;
        const code = compiledObject[libData.data.contractName].code;
        const libraryObject = new web3.eth.Contract(abi);
        const deployObject = libraryObject.deploy({
          arguments: [],
          data: '0x' + code
        });
        deployRunner(deployObject, libraryObject, libData.data.contractName, contract.filename, callback);
      };

      const funAbi = null; // no need to set the abi for encoding the constructor

      const params = ''; // we suppose that the test contract does not have any param in the constructor

      remix_lib_1.execution.txFormat.encodeConstructorCallAndDeployLibraries(contractName, contract.raw, compileResult, params, funAbi, encodeDataFinalCallback, encodeDataStepCallback, encodeDataDeployLibraryCallback);
    }, function (err) {
      if (err) next(err);
      next(null, contracts);
    });
  }], callback);
}

exports.deployAll = deployAll;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/fileSystem.js":
/*!****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/fileSystem.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js"); // Extend fs


const fs = __webpack_require__(/*! fs */ "../../../node_modules/node-libs-browser/mock/empty.js");

const path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ "../../../node_modules/path-browserify/index.js")); // https://github.com/mikeal/node-utils/blob/master/file/lib/main.js


fs.walkSync = function (start, callback) {
  fs.readdirSync(start).forEach(name => {
    if (name === 'node_modules') {
      return; // hack
    }

    const abspath = path_1.default.join(start, name);

    if (fs.statSync(abspath).isDirectory()) {
      fs.walkSync(abspath, callback);
    } else {
      callback(abspath);
    }
  });
};

module.exports = fs;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/index.js":
/*!***********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

var runTestFiles_1 = __webpack_require__(/*! ./runTestFiles */ "../../../dist/libs/remix-tests/src/runTestFiles.js");

exports.runTestFiles = runTestFiles_1.runTestFiles;

var runTestSources_1 = __webpack_require__(/*! ./runTestSources */ "../../../dist/libs/remix-tests/src/runTestSources.js");

exports.runTestSources = runTestSources_1.runTestSources;

var testRunner_1 = __webpack_require__(/*! ./testRunner */ "../../../dist/libs/remix-tests/src/testRunner.js");

exports.runTest = testRunner_1.runTest;

tslib_1.__exportStar(__webpack_require__(/*! ./types */ "../../../dist/libs/remix-tests/src/types.js"), exports);

exports.assertLibCode = __webpack_require__(/*! ../sol/tests.sol */ "../../../dist/libs/remix-tests/sol/tests.sol.js");

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/runTestFiles.js":
/*!******************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/runTestFiles.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const async_1 = tslib_1.__importDefault(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

const fileSystem_1 = tslib_1.__importDefault(__webpack_require__(/*! ./fileSystem */ "../../../dist/libs/remix-tests/src/fileSystem.js"));

const testRunner_1 = __webpack_require__(/*! ./testRunner */ "../../../dist/libs/remix-tests/src/testRunner.js");

const colors_1 = tslib_1.__importDefault(__webpack_require__(/*! colors */ "../../../node_modules/colors/lib/index.js"));

const compiler_1 = __webpack_require__(/*! ./compiler */ "../../../dist/libs/remix-tests/src/compiler.js");

const deployer_1 = __webpack_require__(/*! ./deployer */ "../../../dist/libs/remix-tests/src/deployer.js");
/**
 * @dev run test contract files (used for CLI)
 * @param filepath Path of file
 * @param isDirectory True, if path is a directory
 * @param web3 Web3
 * @param finalCallback optional callback to run finally
 * @param opts Options
 */
// eslint-disable-next-line @typescript-eslint/no-empty-function


function runTestFiles(filepath, isDirectory, web3, finalCallback = () => {}, opts) {
  opts = opts || {};
  const sourceASTs = {};

  const {
    Signale
  } = __webpack_require__(/*! signale */ "../../../node_modules/signale/index.js"); // signale configuration


  const options = {
    types: {
      result: {
        badge: '\t',
        label: '',
        color: 'greenBright'
      },
      name: {
        badge: '\n\t',
        label: '',
        color: 'white'
      },
      error: {
        badge: '\t',
        label: '',
        color: 'redBright'
      }
    }
  };
  const signale = new Signale(options);
  let accounts = opts['accounts'] || null;
  async_1.default.waterfall([function getAccountList(next) {
    if (accounts) return next(null);
    web3.eth.getAccounts((_err, _accounts) => {
      accounts = _accounts;
      next(null);
    });
  }, function compile(next) {
    compiler_1.compileFileOrFiles(filepath, isDirectory, {
      accounts
    }, next);
  }, function deployAllContracts(compilationResult, asts, next) {
    // Extract AST of test contract file source
    for (const filename in asts) {
      if (filename.endsWith('_test.sol')) sourceASTs[filename] = asts[filename].ast;
    }

    deployer_1.deployAll(compilationResult, web3, false, (err, contracts) => {
      if (err) {
        next(err);
      }

      next(null, compilationResult, contracts);
    });
  }, function determineTestContractsToRun(compilationResult, contracts, next) {
    const contractsToTest = [];
    const contractsToTestDetails = [];

    const gatherContractsFrom = function (filename) {
      if (!filename.endsWith('_test.sol')) {
        return;
      }

      try {
        Object.keys(compilationResult[filename]).forEach(contractName => {
          contractsToTest.push(contractName);
          contractsToTestDetails.push(compilationResult[filename][contractName]);
        });
      } catch (e) {
        console.error(e);
      }
    };

    if (isDirectory) {
      fileSystem_1.default.walkSync(filepath, foundpath => {
        gatherContractsFrom(foundpath);
      });
    } else {
      gatherContractsFrom(filepath);
    }

    next(null, contractsToTest, contractsToTestDetails, contracts);
  }, function runTests(contractsToTest, contractsToTestDetails, contracts, next) {
    let totalPassing = 0;
    let totalFailing = 0;
    let totalTime = 0;
    const errors = [];

    const _testCallback = function (err, result) {
      if (err) throw err;

      if (result.type === 'contract') {
        signale.name(result.value.white);
      } else if (result.type === 'testPass') {
        signale.result(result.value);
      } else if (result.type === 'testFailure') {
        signale.result(result.value.red);
        errors.push(result);
      }
    };

    const _resultsCallback = (_err, result, cb) => {
      totalPassing += result.passingNum;
      totalFailing += result.failureNum;
      totalTime += result.timePassed;
      cb();
    };

    async_1.default.eachOfLimit(contractsToTest, 1, (contractName, index, cb) => {
      try {
        const fileAST = sourceASTs[contracts[contractName]['filename']];
        testRunner_1.runTest(contractName, contracts[contractName], contractsToTestDetails[index], fileAST, {
          accounts
        }, _testCallback, (err, result) => {
          if (err) {
            console.log(err);
            return cb(err);
          }

          _resultsCallback(null, result, cb);
        });
      } catch (e) {
        console.error(e);
      }
    }, function (err) {
      if (err) {
        return next(err);
      }

      console.log('\n');

      if (totalPassing > 0) {
        console.log(colors_1.default.green(totalPassing + ' passing ') + colors_1.default.grey('(' + totalTime + 's)'));
      }

      if (totalFailing > 0) {
        console.log(colors_1.default.red(totalFailing + ' failing'));
      }

      console.log('');
      errors.forEach((error, index) => {
        console.log('  ' + (index + 1) + ') ' + error.context + ' ' + error.value);
        console.log('');
        console.log(colors_1.default.red('\t error: ' + error.errMsg));
      });
      console.log('');
      next();
    });
  }], finalCallback);
}

exports.runTestFiles = runTestFiles;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/runTestSources.js":
/*!********************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/runTestSources.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const async_1 = tslib_1.__importDefault(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

__webpack_require__(/*! colors */ "../../../node_modules/colors/lib/index.js");

const compiler_1 = __webpack_require__(/*! ./compiler */ "../../../dist/libs/remix-tests/src/compiler.js");

const deployer_1 = __webpack_require__(/*! ./deployer */ "../../../dist/libs/remix-tests/src/deployer.js");

const testRunner_1 = __webpack_require__(/*! ./testRunner */ "../../../dist/libs/remix-tests/src/testRunner.js");

const web3_1 = tslib_1.__importDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));

const remix_simulator_1 = __webpack_require__(/*! @remix-project/remix-simulator */ "../../../dist/libs/remix-simulator/index.js");

const createWeb3Provider = function () {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const web3 = new web3_1.default();
    const provider = new remix_simulator_1.Provider();
    yield provider.init();
    web3.setProvider(provider);
    return web3;
  });
};
/**
 * @dev Run tests from source of a test contract file (used for IDE)
 * @param contractSources Sources of contract
 * @param compilerConfig current compiler configuration
 * @param testCallback Test callback
 * @param resultCallback Result Callback
 * @param finalCallback Final Callback
 * @param importFileCb Import file callback
 * @param opts Options
 */


function runTestSources(contractSources, compilerConfig, testCallback, resultCallback, finalCallback, importFileCb, opts) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    opts = opts || {};
    const sourceASTs = {};
    const web3 = opts.web3 || (yield createWeb3Provider());
    let accounts = opts.accounts || null;
    async_1.default.waterfall([function getAccountList(next) {
      if (accounts) return next();
      web3.eth.getAccounts((_err, _accounts) => {
        accounts = _accounts;
        next();
      });
    }, function compile(next) {
      compiler_1.compileContractSources(contractSources, compilerConfig, importFileCb, {
        accounts
      }, next);
    }, function deployAllContracts(compilationResult, asts, next) {
      for (const filename in asts) {
        if (filename.endsWith('_test.sol')) sourceASTs[filename] = asts[filename].ast;
      }

      deployer_1.deployAll(compilationResult, web3, false, (err, contracts) => {
        if (err) {
          // If contract deployment fails because of 'Out of Gas' error, try again with double gas
          // This is temporary, should be removed when remix-tests will have a dedicated UI to 
          // accept deployment params from UI
          if (err.message.includes('The contract code couldn\'t be stored, please check your gas limit')) {
            deployer_1.deployAll(compilationResult, web3, true, (error, contracts) => {
              if (error) next([{
                message: 'contract deployment failed after trying twice: ' + error.message,
                severity: 'error'
              }]); // IDE expects errors in array
              else next(null, compilationResult, contracts);
            });
          } else next([{
            message: 'contract deployment failed: ' + err.message,
            severity: 'error'
          }]); // IDE expects errors in array

        } else next(null, compilationResult, contracts);
      });
    }, function determineTestContractsToRun(compilationResult, contracts, next) {
      const contractsToTest = [];
      const contractsToTestDetails = [];

      for (const filename in compilationResult) {
        if (!filename.endsWith('_test.sol')) {
          continue;
        }

        Object.keys(compilationResult[filename]).forEach(contractName => {
          contractsToTestDetails.push(compilationResult[filename][contractName]);
          contractsToTest.push(contractName);
        });
      }

      next(null, contractsToTest, contractsToTestDetails, contracts);
    }, function runTests(contractsToTest, contractsToTestDetails, contracts, next) {
      let totalPassing = 0;
      let totalFailing = 0;
      let totalTime = 0;
      const errors = [];

      const _testCallback = function (err, result) {
        if (result.type === 'testFailure') {
          errors.push(result);
        }

        testCallback(result);
      };

      const _resultsCallback = function (_err, result, cb) {
        resultCallback(_err, result, () => {}); //eslint-disable-line @typescript-eslint/no-empty-function

        totalPassing += result.passingNum;
        totalFailing += result.failureNum;
        totalTime += result.timePassed;
        cb();
      };

      async_1.default.eachOfLimit(contractsToTest, 1, (contractName, index, cb) => {
        const fileAST = sourceASTs[contracts[contractName]['filename']];
        testRunner_1.runTest(contractName, contracts[contractName], contractsToTestDetails[index], fileAST, {
          accounts
        }, _testCallback, (err, result) => {
          if (err) {
            return cb(err);
          }

          _resultsCallback(null, result, cb);
        });
      }, function (err) {
        if (err) {
          return next(err);
        }

        const finalResults = {
          totalPassing: 0,
          totalFailing: 0,
          totalTime: 0,
          errors: []
        };
        finalResults.totalPassing = totalPassing || 0;
        finalResults.totalFailing = totalFailing || 0;
        finalResults.totalTime = totalTime || 0;
        finalResults.errors = [];
        errors.forEach((error, _index) => {
          finalResults.errors.push({
            context: error.context,
            value: error.value,
            message: error.errMsg
          });
        });
        next(null, finalResults);
      });
    }], finalCallback);
  });
}

exports.runTestSources = runTestSources;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/testRunner.js":
/*!****************************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/testRunner.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(/*! tslib */ "../../../node_modules/tslib/tslib.es6.js");

const async_1 = tslib_1.__importDefault(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

const changeCase = tslib_1.__importStar(__webpack_require__(/*! change-case */ "../../../node_modules/change-case/dist.es2015/index.js"));

const web3_1 = tslib_1.__importDefault(__webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js"));
/**
 * @dev Get function name using method signature
 * @param signature siganture
 * @param methodIdentifiers Object containing all methods identifier
 */


function getFunctionFullName(signature, methodIdentifiers) {
  for (const method in methodIdentifiers) {
    if (signature.replace('0x', '') === methodIdentifiers[method].replace('0x', '')) {
      return method;
    }
  }

  return null;
}
/**
 * @dev Check if function is constant using function ABI
 * @param funcABI function ABI
 */


function isConstant(funcABI) {
  return funcABI.constant || funcABI.stateMutability === 'view' || funcABI.stateMutability === 'pure';
}
/**
 * @dev Check if function is payable using function ABI
 * @param funcABI function ABI
 */


function isPayable(funcABI) {
  return funcABI.payable || funcABI.stateMutability === 'payable';
}
/**
 * @dev Get overrided sender provided using natspec
 * @param userdoc method user documentaion
 * @param signature signature
 * @param methodIdentifiers Object containing all methods identifier
 */


function getOverridedSender(userdoc, signature, methodIdentifiers) {
  const fullName = getFunctionFullName(signature, methodIdentifiers);
  const senderRegex = /#sender: account-+(\d)/g;
  const accountIndex = fullName && userdoc.methods[fullName] ? senderRegex.exec(userdoc.methods[fullName].notice) : null;
  return fullName && accountIndex ? accountIndex[1] : null;
}
/**
 * @dev Get value provided using natspec
 * @param userdoc method user documentaion
 * @param signature signature
 * @param methodIdentifiers Object containing all methods identifier
 */


function getProvidedValue(userdoc, signature, methodIdentifiers) {
  const fullName = getFunctionFullName(signature, methodIdentifiers);
  const valueRegex = /#value: (\d+)/g;
  const value = fullName && userdoc.methods[fullName] ? valueRegex.exec(userdoc.methods[fullName].notice) : null;
  return fullName && value ? value[1] : null;
}
/**
 * @dev returns functions of a test contract file in same sequence they appear in file (using passed AST)
 * @param fileAST AST of test contract file source
 * @param testContractName Name of test contract
 */


function getAvailableFunctions(fileAST, testContractName) {
  let funcList = [];

  if (fileAST.nodes && fileAST.nodes.length > 0) {
    const contractAST = fileAST.nodes.filter(node => node.name === testContractName && node.nodeType === 'ContractDefinition');

    if (contractAST.length > 0 && contractAST[0].nodes) {
      const funcNodes = contractAST[0].nodes.filter(node => node.kind === "function" && node.nodeType === "FunctionDefinition" || node.nodeType === "FunctionDefinition");
      funcList = funcNodes.map(node => node.name);
    }
  }

  return funcList;
}
/**
 * @dev returns ABI of passed method list from passed interface
 * @param jsonInterface Json Interface
 * @param funcList Methods to extract the interface of
 */


function getTestFunctionsInterface(jsonInterface, funcList) {
  const functionsInterface = [];
  const specialFunctions = ['beforeAll', 'beforeEach', 'afterAll', 'afterEach'];

  for (const func of funcList) {
    if (!specialFunctions.includes(func)) {
      const funcInterface = jsonInterface.find(node => node.type === 'function' && node.name === func);
      if (funcInterface) functionsInterface.push(funcInterface);
    }
  }

  return functionsInterface;
}
/**
 * @dev returns ABI of special functions from passed interface
 * @param jsonInterface Json Interface
 */


function getSpecialFunctionsInterface(jsonInterface) {
  const specialFunctionsInterface = {};
  const funcList = ['beforeAll', 'beforeEach', 'afterAll', 'afterEach'];

  for (const func of funcList) {
    const funcInterface = jsonInterface.find(node => node.type === 'function' && node.name === func);

    if (funcInterface) {
      specialFunctionsInterface[func] = funcInterface;
    }
  }

  return specialFunctionsInterface;
}
/**
 * @dev Prepare a list of tests to run using test contract file ABI, AST & contract name
 * @param jsonInterface File JSON interface
 * @param fileAST File AST
 * @param testContractName Test contract name
 */


function createRunList(jsonInterface, fileAST, testContractName) {
  const availableFunctions = getAvailableFunctions(fileAST, testContractName);
  const testFunctionsInterface = getTestFunctionsInterface(jsonInterface, availableFunctions);
  const specialFunctionsInterface = getSpecialFunctionsInterface(jsonInterface);
  const runList = [];

  if (availableFunctions.includes('beforeAll')) {
    const func = specialFunctionsInterface['beforeAll'];
    runList.push({
      name: 'beforeAll',
      inputs: func.inputs,
      signature: func.signature,
      type: 'internal',
      constant: isConstant(func),
      payable: isPayable(func)
    });
  }

  for (const func of testFunctionsInterface) {
    if (availableFunctions.includes('beforeEach')) {
      const func = specialFunctionsInterface['beforeEach'];
      runList.push({
        name: 'beforeEach',
        inputs: func.inputs,
        signature: func.signature,
        type: 'internal',
        constant: isConstant(func),
        payable: isPayable(func)
      });
    }

    if (func.name && func.inputs) runList.push({
      name: func.name,
      inputs: func.inputs,
      signature: func.signature,
      type: 'test',
      constant: isConstant(func),
      payable: isPayable(func)
    });

    if (availableFunctions.indexOf('afterEach') >= 0) {
      const func = specialFunctionsInterface['afterEach'];
      runList.push({
        name: 'afterEach',
        inputs: func.inputs,
        signature: func.signature,
        type: 'internal',
        constant: isConstant(func),
        payable: isPayable(func)
      });
    }
  }

  if (availableFunctions.indexOf('afterAll') >= 0) {
    const func = specialFunctionsInterface['afterAll'];
    runList.push({
      name: 'afterAll',
      inputs: func.inputs,
      signature: func.signature,
      type: 'internal',
      constant: isConstant(func),
      payable: isPayable(func)
    });
  }

  return runList;
}

function runTest(testName, testObject, contractDetails, fileAST, opts, testCallback, resultsCallback) {
  let passingNum = 0;
  let failureNum = 0;
  let timePassed = 0;
  const isJSONInterfaceAvailable = testObject && testObject.options && testObject.options.jsonInterface;
  if (!isJSONInterfaceAvailable) return resultsCallback(new Error('Contract interface not available'), {
    passingNum,
    failureNum,
    timePassed
  });
  const runList = createRunList(testObject.options.jsonInterface, fileAST, testName);
  const web3 = new web3_1.default();
  const accts = {
    type: 'accountList',
    value: opts.accounts
  };
  testCallback(undefined, accts);
  const resp = {
    type: 'contract',
    value: testName,
    filename: testObject.filename
  };
  testCallback(undefined, resp);
  async_1.default.eachOfLimit(runList, 1, function (func, index, next) {
    let sender = null;

    if (func.signature) {
      sender = getOverridedSender(contractDetails.userdoc, func.signature, contractDetails.evm.methodIdentifiers);

      if (opts.accounts && sender) {
        sender = opts.accounts[sender];
      }
    }

    let sendParams = null;
    if (sender) sendParams = {
      from: sender
    };
    if (func.inputs && func.inputs.length > 0) return resultsCallback(new Error(`Method '${func.name}' can not have parameters inside a test contract`), {
      passingNum,
      failureNum,
      timePassed
    });
    const method = testObject.methods[func.name].apply(testObject.methods[func.name], []);
    const startTime = Date.now();

    if (func.constant) {
      method.call(sendParams).then(result => {
        const time = (Date.now() - startTime) / 1000.0;

        if (result) {
          const resp = {
            type: 'testPass',
            value: changeCase.sentenceCase(func.name),
            time: time,
            context: testName
          };
          testCallback(undefined, resp);
          passingNum += 1;
          timePassed += time;
        } else {
          const resp = {
            type: 'testFailure',
            value: changeCase.sentenceCase(func.name),
            time: time,
            errMsg: 'function returned false',
            context: testName
          };
          testCallback(undefined, resp);
          failureNum += 1;
        }

        next();
      });
    } else {
      if (func.payable) {
        const value = getProvidedValue(contractDetails.userdoc, func.signature, contractDetails.evm.methodIdentifiers);

        if (value) {
          if (sendParams) sendParams.value = value;else sendParams = {
            value
          };
        }
      }

      method.send(sendParams).on('receipt', receipt => {
        try {
          const time = (Date.now() - startTime) / 1000.0;
          const topic = web3_1.default.utils.sha3('AssertionEvent(bool,string)');
          let testPassed = false;

          for (const i in receipt.events) {
            const event = receipt.events[i];

            if (event.raw.topics.indexOf(topic) >= 0) {
              const testEvent = web3.eth.abi.decodeParameters(['bool', 'string'], event.raw.data);

              if (!testEvent[0]) {
                const resp = {
                  type: 'testFailure',
                  value: changeCase.sentenceCase(func.name),
                  time: time,
                  errMsg: testEvent[1],
                  context: testName
                };
                testCallback(undefined, resp);
                failureNum += 1;
                return next();
              }

              testPassed = true;
            }
          }

          if (testPassed) {
            const resp = {
              type: 'testPass',
              value: changeCase.sentenceCase(func.name),
              time: time,
              context: testName
            };
            testCallback(undefined, resp);
            passingNum += 1;
          }

          return next();
        } catch (err) {
          console.error(err);
          return next(err);
        }
      }).on('error', function (err) {
        const time = (Date.now() - startTime) / 1000.0;
        const resp = {
          type: 'testFailure',
          value: changeCase.sentenceCase(func.name),
          time: time,
          errMsg: err.message,
          context: testName
        };
        testCallback(undefined, resp);
        failureNum += 1;
        return next();
      });
    }
  }, function (error) {
    resultsCallback(error, {
      passingNum,
      failureNum,
      timePassed
    });
  });
}

exports.runTest = runTest;

/***/ }),

/***/ "../../../dist/libs/remix-tests/src/types.js":
/*!***********************************************************************!*\
  !*** /home/circleci/remix-project/dist/libs/remix-tests/src/types.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class CompilationErrors extends Error {
  constructor(errors) {
    const mapError = errors.map(e => {
      return e.formattedMessage || e.message;
    });
    super(mapError.join('\n'));
    this.errors = errors;
    this.name = 'CompilationErrors';
  }

}

exports.CompilationErrors = CompilationErrors;

/***/ }),

/***/ "../../../node_modules/colors/lib sync recursive":
/*!*****************************************************************!*\
  !*** /home/circleci/remix-project/node_modules/colors/lib sync ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "../../../node_modules/colors/lib sync recursive";

/***/ }),

/***/ "../../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../../package.json":
/*!*************************************************!*\
  !*** /home/circleci/remix-project/package.json ***!
  \*************************************************/
/*! exports provided: name, version, license, description, keywords, repository, author, bugs, homepage, bin, scripts, browserify, dependencies, devDependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"remix-project\",\"version\":\"0.10.4\",\"license\":\"MIT\",\"description\":\"Ethereum Remix Monorepo\",\"keywords\":[\"ethereum\",\"solidity\",\"compiler\"],\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/ethereum/remix-project.git\"},\"author\":\"@yann300\",\"bugs\":{\"url\":\"https://github.com/ethereum/remix-project/issues\"},\"homepage\":\"https://github.com/ethereum/remix-project#readme\",\"bin\":{\"remix-ide\":\"./apps/remix-ide/bin/remix-ide\"},\"scripts\":{\"nx\":\"nx\",\"start\":\"nx start\",\"serve\":\"nx serve\",\"build\":\"nx build\",\"test\":\"nx test\",\"lint\":\"nx lint\",\"e2e\":\"nx e2e\",\"affected:apps\":\"nx affected:apps\",\"affected:libs\":\"nx affected:libs\",\"affected:build\":\"nx affected:build\",\"affected:e2e\":\"nx affected:e2e\",\"affected:test\":\"nx affected:test\",\"affected:lint\":\"nx affected:lint\",\"affected:dep-graph\":\"nx affected:dep-graph\",\"affected\":\"nx affected\",\"format\":\"nx format:write\",\"format:write\":\"nx format:write\",\"format:check\":\"nx format:check\",\"update\":\"nx migrate latest\",\"workspace-schematic\":\"nx workspace-schematic\",\"dep-graph\":\"nx dep-graph\",\"help\":\"nx help\",\"lint:libs\":\"nx run-many --target=lint --projects=remix-analyzer,remix-astwalker,remix-debug,remix-lib,remix-simulator,remix-solidity,remix-tests,remix-url-resolver\",\"build:libs\":\"nx run-many --target=build --parallel=false --with-deps=true --projects=remix-analyzer,remix-astwalker,remix-debug,remix-lib,remix-simulator,remix-solidity,remix-tests,remix-url-resolver\",\"test:libs\":\"nx run-many --target=test --projects=remix-analyzer,remix-astwalker,remix-debug,remix-lib,remix-simulator,remix-solidity,remix-tests,remix-url-resolver\",\"publish:libs\":\"npm run build:libs; lerna publish --skip-git\",\"browsertest\":\"sleep 5 && npm run nightwatch_local\",\"csslint\":\"csslint --ignore=order-alphabetical --errors='errors,duplicate-properties,empty-rules' --exclude-list='apps/remix-ide/assets/css/font-awesome.min.css' apps/remix-ide/assets/css/\",\"downloadsolc_root\":\"wget --no-check-certificate https://solc-bin.ethereum.org/bin/soljson-v0.6.6+commit.6c089d02.js -O ./apps/remix-ide/soljson.js\",\"make-mock-compiler\":\"node apps/remix-ide/ci/makeMockCompiler.js\",\"minify\":\"uglifyjs --in-source-map inline --source-map-inline -c warnings=false\",\"nightwatch_parallel\":\"nightwatch -e chrome,firefox --config apps/remix-ide/nightwatch.js\",\"nightwatch_local_firefox\":\"nightwatch --config apps/remix-ide/nightwatch.js --env firefox\",\"nightwatch_local_chrome\":\"nightwatch --config apps/remix-ide/nightwatch.js --env chrome\",\"nightwatch_local_ballot\":\"nightwatch ./apps/remix-ide/test-browser/tests/ballot.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_usingWorker\":\"nightwatch ./apps/remix-ide/test-browser/tests/usingWebWorker.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_libraryDeployment\":\"nightwatch ./apps/remix-ide/test-browser/tests/libraryDeployment.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_solidityImport\":\"nightwatch ./apps/remix-ide/test-browser/tests/solidityImport.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_recorder\":\"nightwatch ./apps/remix-ide/test-browser/tests/recorder.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_transactionExecution\":\"nightwatch ./apps/remix-ide/test-browser/tests/transactionExecution.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_staticAnalysis\":\"nightwatch ./apps/remix-ide/test-browser/tests/staticAnalysis.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_signingMessage\":\"nightwatch ./apps/remix-ide/test-browser/tests/signingMessage.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_specialFunctions\":\"nightwatch ./apps/remix-ide/test-browser/tests/specialFunctions.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_solidityUnitTests\":\"nightwatch ./apps/remix-ide/test-browser/tests/solidityUnittests.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_remixd\":\"nightwatch ./apps/remix-ide/test-browser/tests/remixd.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_terminal\":\"nightwatch ./apps/remix-ide/test-browser/tests/terminal.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_gist\":\"nightwatch ./apps/remix-ide/test-browser/tests/gist.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_workspace\":\"nightwatch ./apps/remix-ide/test-browser/tests/workspace.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_defaultLayout\":\"nightwatch ./apps/remix-ide/test-browser/tests/defaultLayout.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_pluginManager\":\"nightwatch ./apps/remix-ide/test-browser/tests/pluginManager.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_publishContract\":\"nightwatch ./apps/remix-ide/test-browser/tests/publishContract.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_generalSettings\":\"nightwatch ./apps/remix-ide/test-browser/tests/generalSettings.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_fileExplorer\":\"nightwatch ./apps/remix-ide/test-browser/tests/fileExplorer.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_debugger\":\"nightwatch ./apps/remix-ide/test-browser/tests/debugger.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_editor\":\"nightwatch ./apps/remix-ide/test-browser/tests/editor.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_compiler\":\"nightwatch ./apps/remix-ide/test-browser/tests/compiler_api.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_txListener\":\"nightwatch ./apps/remix-ide/test-browser/tests/txListener.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_fileManager\":\"nightwatch ./apps/remix-ide/test-browser/tests/fileManager_api.test.js --config apps/remix-ide/nightwatch.js --env chrome \",\"nightwatch_local_runAndDeploy\":\"nightwatch ./apps/remix-ide/test-browser/tests/runAndDeploy.js --config apps/remix-ide/nightwatch.js --env chrome-runAndDeploy \",\"onchange\":\"onchange apps/remix-ide/build/app.js -- npm-run-all lint\",\"remixd\":\"remixd -s ./apps/remix-ide/contracts --remix-ide http://127.0.0.1:8080\",\"selenium\":\"selenium-standalone start\",\"selenium-install\":\"selenium-standalone install\",\"sourcemap\":\"exorcist --root ../ apps/remix-ide/build/app.js.map > apps/remix-ide/build/app.js\",\"test-browser\":\"npm-run-all -lpr selenium downloadsolc_root make-mock-compiler serve browsertest\",\"watch\":\"watchify apps/remix-ide/src/index.js -dv -p browserify-reload -o apps/remix-ide/build/app.js --exclude solc\",\"reinstall\":\"rm ./node-modules/ -rf; rm package-lock.json; rm ./build/ -rf; npm install; npm run build\",\"ganache-cli\":\"npx ganache-cli\"},\"browserify\":{\"transform\":[[\"babelify\",{\"sourceMapsAbsolute\":false,\"sourceMaps\":true,\"plugins\":[[\"module:fast-async\",{\"runtimePattern\":null,\"compiler\":{\"es7\":true,\"noRuntime\":true,\"promises\":true,\"wrapAwait\":true}}],[\"module:babel-plugin-yo-yoify\"],[\"module:@babel/plugin-transform-object-assign\"]],\"presets\":[\"@babel/preset-env\"]}]]},\"dependencies\":{\"@remixproject/engine\":\"^0.2.3\",\"@types/jest\":\"^26.0.5\",\"@types/tape\":\"^4.2.33\",\"ansi-gray\":\"^0.1.1\",\"change-case\":\"^4.1.1\",\"color-support\":\"^1.1.3\",\"ethereumjs-block\":\"^2.2.2\",\"ethereumjs-tx\":\"^2.1.2\",\"ethereumjs-vm\":\"4.1.3\",\"http-server\":\"^0.11.1\",\"merge\":\"^1.2.0\",\"npm-install-version\":\"^6.0.2\",\"signale\":\"^1.4.0\",\"time-stamp\":\"^2.2.0\",\"winston\":\"^3.3.3\"},\"devDependencies\":{\"@babel/core\":\"^7.4.5\",\"@babel/plugin-transform-modules-amd\":\"^7.10.4\",\"@babel/plugin-transform-modules-commonjs\":\"^7.10.4\",\"@babel/plugin-transform-object-assign\":\"^7.2.0\",\"@babel/plugin-transform-runtime\":\"^7.10.4\",\"@babel/polyfill\":\"^7.4.4\",\"@babel/preset-env\":\"^7.10.4\",\"@babel/preset-es2015\":\"^7.0.0-beta.53\",\"@babel/preset-es2017\":\"latest\",\"@babel/preset-stage-0\":\"^7.0.0\",\"@babel/register\":\"^7.4.4\",\"@fortawesome/fontawesome-free\":\"^5.8.1\",\"@nrwl/eslint-plugin-nx\":\"^10.0.6\",\"@nrwl/jest\":\"10.0.6\",\"@nrwl/linter\":\"^10.0.6\",\"@nrwl/node\":\"^10.0.6\",\"@nrwl/react\":\"10.0.6\",\"@nrwl/web\":\"10.0.6\",\"@nrwl/workspace\":\"10.0.6\",\"@resolver-engine/imports\":\"^0.3.0\",\"@types/chai\":\"^4.2.11\",\"@types/mocha\":\"^7.0.2\",\"@types/node\":\"~8.9.4\",\"@types/react\":\"16.9.17\",\"@types/react-dom\":\"16.9.4\",\"@types/react-router-dom\":\"5.1.3\",\"@typescript-eslint/eslint-plugin\":\"^3.3.0\",\"@typescript-eslint/parser\":\"^3.3.0\",\"ace-mode-move\":\"0.0.1\",\"ace-mode-solidity\":\"^0.1.0\",\"ace-mode-zokrates\":\"^1.0.0\",\"async\":\"^2.1.2\",\"babel-eslint\":\"^10.0.0\",\"babel-plugin-add-module-exports\":\"^1.0.2\",\"babel-plugin-fast-async\":\"^6.1.2\",\"babel-plugin-module-resolver\":\"^4.0.0\",\"babel-plugin-transform-object-rest-spread\":\"^6.26.0\",\"babel-plugin-yo-yoify\":\"^2.0.0\",\"babel-preset-env\":\"^1.7.0\",\"babel-preset-typescript\":\"^7.0.0-alpha.19\",\"babelify\":\"^10.0.0\",\"brace\":\"^0.8.0\",\"browserify\":\"^16.2.3\",\"browserify-reload\":\"^1.0.3\",\"component-type\":\"^1.2.1\",\"copy-text-to-clipboard\":\"^1.0.4\",\"csjs-inject\":\"^1.0.1\",\"csslint\":\"^1.0.2\",\"cypress\":\"^4.1.0\",\"deep-equal\":\"^1.0.1\",\"dotenv\":\"^8.2.0\",\"eslint\":\"6.8.0\",\"eslint-config-prettier\":\"^6.11.0\",\"ethereumjs-util\":\"^6.2.0\",\"ethers\":\"^4.0.27\",\"events\":\"^3.0.0\",\"execr\":\"^1.0.1\",\"exorcist\":\"^0.4.0\",\"exports-loader\":\"^1.1.0\",\"fast-async\":\"^7.0.6\",\"fast-levenshtein\":\"^2.0.6\",\"ganache-cli\":\"^6.8.1\",\"gists\":\"^1.0.1\",\"ipfs-http-client\":\"35.1.1\",\"ipfs-mini\":\"^1.1.5\",\"is-electron\":\"^2.2.0\",\"javascript-serialize\":\"^1.6.1\",\"jest\":\"25.2.3\",\"jquery\":\"^3.3.1\",\"js-base64\":\"^2.1.9\",\"js-beautify\":\"1.6.14\",\"lerna\":\"^3.22.1\",\"minixhr\":\"^3.2.2\",\"mkdirp\":\"^0.5.1\",\"mocha\":\"^8.0.1\",\"nanohtml\":\"^1.6.3\",\"nightwatch\":\"^1.3.6\",\"notify-error\":\"^1.2.0\",\"npm-link-local\":\"^1.1.0\",\"npm-merge-driver\":\"^2.3.5\",\"npm-run-all\":\"^4.0.2\",\"nyc\":\"^13.3.0\",\"onchange\":\"^3.2.1\",\"prettier\":\"1.19.1\",\"remix-tabs\":\"1.0.48\",\"remixd\":\"0.2.3-alpha.4\",\"request\":\"^2.83.0\",\"rimraf\":\"^2.6.1\",\"selenium-standalone\":\"^6.17.0\",\"semver\":\"^6.1.2\",\"solc\":\"^0.6.0\",\"swarmgw\":\"^0.3.1\",\"tap-spec\":\"^5.0.0\",\"tape\":\"^4.13.3\",\"ts-jest\":\"25.2.1\",\"ts-node\":\"~7.0.0\",\"tslint\":\"~6.0.0\",\"typescript\":\"~3.8.3\",\"uglify-js\":\"^2.8.16\",\"vm-browserify\":\"0.0.4\",\"watchify\":\"^3.9.0\",\"web3\":\"1.2.4\",\"webworkify-webpack\":\"^2.1.5\",\"worker-loader\":\"^2.0.0\",\"yo-yo\":\"github:ioedeveloper/yo-yo\",\"yo-yoify\":\"^3.7.3\"}}");

/***/ }),

/***/ "./app.js":
/*!****************!*\
  !*** ./app.js ***!
  \****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _svgLogo = __webpack_require__(/*! ./app/ui/svgLogo */ "./app/ui/svgLogo.js");

var _udapp = __webpack_require__(/*! ./app/udapp */ "./app/udapp/index.js");

var _panelsResize = _interopRequireDefault(__webpack_require__(/*! ./lib/panels-resize */ "./lib/panels-resize.js"));

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var _remixAppManager = __webpack_require__(/*! ./remixAppManager */ "./remixAppManager.js");

var _framingService = __webpack_require__(/*! ./framingService */ "./framingService.js");

var _mainView = __webpack_require__(/*! ./app/panels/main-view */ "./app/panels/main-view.js");

var _themeModule = __webpack_require__(/*! ./app/tabs/theme-module */ "./app/tabs/theme-module.js");

var _networkModule = __webpack_require__(/*! ./app/tabs/network-module */ "./app/tabs/network-module.js");

var _web3Provider = __webpack_require__(/*! ./app/tabs/web3-provider */ "./app/tabs/web3-provider.js");

var _sidePanel = __webpack_require__(/*! ./app/components/side-panel */ "./app/components/side-panel.js");

var _hiddenPanel = __webpack_require__(/*! ./app/components/hidden-panel */ "./app/components/hidden-panel.js");

var _verticalIcons = __webpack_require__(/*! ./app/components/vertical-icons */ "./app/components/vertical-icons.js");

var _landingPage = __webpack_require__(/*! ./app/ui/landing-page/landing-page */ "./app/ui/landing-page/landing-page.js");

var _mainPanel = __webpack_require__(/*! ./app/components/main-panel */ "./app/components/main-panel.js");

var _compilerSourceVerifierFetchAndCompile = _interopRequireDefault(__webpack_require__(/*! ./app/compiler/compiler-sourceVerifier-fetchAndCompile */ "./app/compiler/compiler-sourceVerifier-fetchAndCompile.js"));

var _migrateFileSystem = _interopRequireDefault(__webpack_require__(/*! ./migrateFileSystem */ "./migrateFileSystem.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isElectron = __webpack_require__(/*! is-electron */ "../../../node_modules/is-electron/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var registry = __webpack_require__(/*! ./global/registry */ "./global/registry.js");

var loadFileFromParent = __webpack_require__(/*! ./loadFilesFromParent */ "./loadFilesFromParent.js");

var {
  OffsetToLineColumnConverter
} = __webpack_require__(/*! ./lib/offsetToLineColumnConverter */ "./lib/offsetToLineColumnConverter.js");

var QueryParams = __webpack_require__(/*! ./lib/query-params */ "./lib/query-params.js");

var GistHandler = __webpack_require__(/*! ./lib/gist-handler */ "./lib/gist-handler.js");

var Storage = remixLib.Storage;

var RemixDProvider = __webpack_require__(/*! ./app/files/remixDProvider */ "./app/files/remixDProvider.js");

var Config = __webpack_require__(/*! ./config */ "./config.js");

var Renderer = __webpack_require__(/*! ./app/ui/renderer */ "./app/ui/renderer.js");

var examples = __webpack_require__(/*! ./app/editor/example-contracts */ "./app/editor/example-contracts.js");

var modalDialogCustom = __webpack_require__(/*! ./app/ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var FileManager = __webpack_require__(/*! ./app/files/fileManager */ "./app/files/fileManager.js");

var FileProvider = __webpack_require__(/*! ./app/files/fileProvider */ "./app/files/fileProvider.js");

var toolTip = __webpack_require__(/*! ./app/ui/tooltip */ "./app/ui/tooltip.js");

var CompilerMetadata = __webpack_require__(/*! ./app/files/compiler-metadata */ "./app/files/compiler-metadata.js");

var CompilerImport = __webpack_require__(/*! ./app/compiler/compiler-imports */ "./app/compiler/compiler-imports.js");

const Blockchain = __webpack_require__(/*! ./blockchain/blockchain.js */ "./blockchain/blockchain.js");

const PluginUDapp = __webpack_require__(/*! ./blockchain/pluginUDapp.js */ "./blockchain/pluginUDapp.js");

const PluginManagerComponent = __webpack_require__(/*! ./app/components/plugin-manager-component */ "./app/components/plugin-manager-component.js");

const CompilersArtefacts = __webpack_require__(/*! ./app/compiler/compiler-artefacts */ "./app/compiler/compiler-artefacts.js");

const CompileTab = __webpack_require__(/*! ./app/tabs/compile-tab */ "./app/tabs/compile-tab.js");

const SettingsTab = __webpack_require__(/*! ./app/tabs/settings-tab */ "./app/tabs/settings-tab.js");

const AnalysisTab = __webpack_require__(/*! ./app/tabs/analysis-tab */ "./app/tabs/analysis-tab.js");

const DebuggerTab = __webpack_require__(/*! ./app/tabs/debugger-tab */ "./app/tabs/debugger-tab.js");

const TestTab = __webpack_require__(/*! ./app/tabs/test-tab */ "./app/tabs/test-tab.js");

const FilePanel = __webpack_require__(/*! ./app/panels/file-panel */ "./app/panels/file-panel.js");

const Editor = __webpack_require__(/*! ./app/editor/editor */ "./app/editor/editor.js");

const Terminal = __webpack_require__(/*! ./app/panels/terminal */ "./app/panels/terminal.js");

const ContextualListener = __webpack_require__(/*! ./app/editor/contextualListener */ "./app/editor/contextualListener.js");

var css = csjs`
  html { box-sizing: border-box; }
  *, *:before, *:after { box-sizing: inherit; }
  body                 {
    /* font: 14px/1.5 Lato, "Helvetica Neue", Helvetica, Arial, sans-serif; */
    font-size          : .8rem;
  }
  pre {
    overflow-x: auto;
  }
  .remixIDE            {
    width              : 100vw;
    height             : 100vh;
    overflow           : hidden;
    flex-direction     : row;
    display            : flex;
  }
  .mainpanel           {
    display            : flex;
    flex-direction     : column;
    overflow           : hidden;
    flex               : 1;
  }
  .iconpanel           {
    display            : flex;
    flex-direction     : column;
    overflow           : hidden;
    width              : 50px;
    user-select        : none;
  }
  .sidepanel           {
    display            : flex;
    flex-direction     : row-reverse;
    width              : 320px;
  }
  .highlightcode       {
    position           : absolute;
    z-index            : 20;
    background-color   : var(--info);
  }
  .highlightcode_fullLine {
    position           : absolute;
    z-index            : 20;
    background-color   : var(--info);
    opacity            : 0.5;
  }
  .centered {
    position           : fixed;
    top                : 20%;
    left               : 45%;
    width              : 200px;
    height             : 200px;
  }
  .centered svg path {
    fill: var(--secondary);
  }
  .centered svg polygon {
    fill: var(--secondary);
  }
`;

class App {
  constructor(api = {}, events = {}, opts = {}) {
    var self = this;
    self.appManager = new _remixAppManager.RemixAppManager({});
    self._components = {};
    self._view = {};
    self._view.splashScreen = yo`
    <div class=${css.centered}>
      ${(0, _svgLogo.basicLogo)()}
      <div class="info-secondary" style="text-align:center">
        REMIX IDE
      </div>
      </div>
    `;
    document.body.appendChild(self._view.splashScreen); // setup storage

    const configStorage = new Storage('config-v0.8:'); // load app config

    const config = new Config(configStorage);
    registry.put({
      api: config,
      name: 'config'
    }); // load file system

    self._components.filesProviders = {};
    self._components.filesProviders['browser'] = new FileProvider('browser');
    registry.put({
      api: self._components.filesProviders['browser'],
      name: 'fileproviders/browser'
    });
    self._components.filesProviders['localhost'] = new RemixDProvider(self.appManager);
    registry.put({
      api: self._components.filesProviders['localhost'],
      name: 'fileproviders/localhost'
    });
    registry.put({
      api: self._components.filesProviders,
      name: 'fileproviders'
    });
    (0, _migrateFileSystem.default)(self._components.filesProviders['browser']);
  }

  init() {
    var self = this;
    run.apply(self);
  }

  render() {
    var self = this;
    if (self._view.el) return self._view.el; // not resizable

    self._view.iconpanel = yo`
      <div id="icon-panel" data-id="remixIdeIconPanel" class="${css.iconpanel} bg-light">
      ${''}
      </div>
    `; // center panel, resizable

    self._view.sidepanel = yo`
      <div id="side-panel" data-id="remixIdeSidePanel" style="min-width: 320px;" class="${css.sidepanel} border-right border-left">
        ${''}
      </div>
    `; // handle the editor + terminal

    self._view.mainpanel = yo`
      <div id="main-panel" data-id="remixIdeMainPanel" class=${css.mainpanel}>
        ${''}
      </div>
    `;
    self._components.resizeFeature = new _panelsResize.default(self._view.sidepanel);
    self._view.el = yo`
      <div style="visibility:hidden" class=${css.remixIDE} data-id="remixIDE">
        ${self._view.iconpanel}
        ${self._view.sidepanel}
        ${self._components.resizeFeature.render()}
        ${self._view.mainpanel}
      </div>
    `;
    return self._view.el;
  }

}

module.exports = App;

async function run() {
  var self = this; // check the origin and warn message

  if (window.location.hostname === 'yann300.github.io') {
    modalDialogCustom.alert('This UNSTABLE ALPHA branch of Remix has been moved to http://ethereum.github.io/remix-live-alpha.');
  } else if (window.location.hostname === 'remix-alpha.ethereum.org' || window.location.hostname === 'ethereum.github.io' && window.location.pathname.indexOf('/remix-live-alpha') === 0) {
    modalDialogCustom.alert(`Welcome to the Remix alpha instance. Please use it to try out latest features. But use preferably https://remix.ethereum.org for any production work.`);
  } else if (window.location.protocol.indexOf('http') === 0 && window.location.hostname !== 'remix.ethereum.org' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
    modalDialogCustom.alert(`The Remix IDE has moved to http://remix.ethereum.org.\n
This instance of Remix you are visiting WILL NOT BE UPDATED.\n
Please make a backup of your contracts and start using http://remix.ethereum.org`);
  }

  if (window.location.protocol.indexOf('https') === 0) {
    toolTip('You are using an `https` connection. Please switch to `http` if you are using Remix against an `http Web3 provider` or allow Mixed Content in your browser.');
  }

  const hosts = ['127.0.0.1:8080', '192.168.0.101:8080', 'localhost:8080']; // workaround for Electron support

  if (!isElectron() && !hosts.includes(window.location.host)) {
    // Oops! Accidentally trigger refresh or bookmark.
    window.onbeforeunload = function () {
      return 'Are you sure you want to leave?';
    };
  } // APP_MANAGER


  const appManager = self.appManager;
  const pluginLoader = appManager.pluginLoader;
  const workspace = pluginLoader.get();
  const engine = new _engine.Engine(appManager);

  engine.setPluginOption = ({
    name,
    kind
  }) => {
    if (kind === 'provider') return {
      queueTimeout: 60000 * 4
    };
    if (name === 'LearnEth') return {
      queueTimeout: 60000
    };
    return {
      queueTimeout: 10000
    };
  };

  await engine.onload(); // SERVICES
  // ----------------- import content servive ------------------------

  const contentImport = new CompilerImport(); // ----------------- theme servive ---------------------------------

  const themeModule = new _themeModule.ThemeModule(registry);
  registry.put({
    api: themeModule,
    name: 'themeModule'
  });
  themeModule.initTheme(() => {
    setTimeout(() => {
      document.body.removeChild(self._view.splashScreen);
      self._view.el.style.visibility = 'visible';
    }, 1500);
  }); // ----------------- editor servive ----------------------------

  const editor = new Editor({}, themeModule); // wrapper around ace editor

  registry.put({
    api: editor,
    name: 'editor'
  });
  editor.event.register('requiringToSaveCurrentfile', () => fileManager.saveCurrentFile()); // ----------------- fileManager servive ----------------------------

  const fileManager = new FileManager(editor, appManager);
  registry.put({
    api: fileManager,
    name: 'filemanager'
  });
  const blockchain = new Blockchain(registry.get('config').api);
  const pluginUdapp = new PluginUDapp(blockchain); // ----------------- compilation metadata generation servive ---------

  const compilerMetadataGenerator = new CompilerMetadata(blockchain, fileManager, registry.get('config').api); // ----------------- compilation result service (can keep track of compilation results) ----------------------------

  const compilersArtefacts = new CompilersArtefacts(); // store all the compilation results (key represent a compiler name)

  registry.put({
    api: compilersArtefacts,
    name: 'compilersartefacts'
  }); // service which fetch contract artifacts from sourve-verify, put artifacts in remix and compile it

  const fetchAndCompile = new _compilerSourceVerifierFetchAndCompile.default(); // ----------------- network service (resolve network id / name) -----

  const networkModule = new _networkModule.NetworkModule(blockchain); // ----------------- represent the current selected web3 provider ----

  const web3Provider = new _web3Provider.Web3ProviderModule(blockchain); // ----------------- convert offset to line/column service -----------

  const offsetToLineColumnConverter = new OffsetToLineColumnConverter();
  registry.put({
    api: offsetToLineColumnConverter,
    name: 'offsettolinecolumnconverter'
  }); // -------------------Terminal----------------------------------------

  const terminal = new Terminal({
    appManager,
    blockchain
  }, {
    getPosition: event => {
      var limitUp = 36;
      var limitDown = 20;
      var height = window.innerHeight;
      var newpos = event.pageY < limitUp ? limitUp : event.pageY;
      newpos = newpos < height - limitDown ? newpos : height - limitDown;
      return height - newpos;
    }
  });
  (0, _udapp.makeUdapp)(blockchain, compilersArtefacts, domEl => terminal.logHtml(domEl));
  const contextualListener = new ContextualListener({
    editor
  });
  engine.register([contentImport, themeModule, editor, fileManager, compilerMetadataGenerator, compilersArtefacts, networkModule, offsetToLineColumnConverter, contextualListener, terminal, web3Provider, fetchAndCompile]); // LAYOUT & SYSTEM VIEWS

  const appPanel = new _mainPanel.MainPanel();
  const mainview = new _mainView.MainView(contextualListener, editor, appPanel, fileManager, appManager, terminal);
  registry.put({
    api: mainview,
    name: 'mainview'
  });
  engine.register(appPanel); // those views depend on app_manager

  const menuicons = new _verticalIcons.VerticalIcons(appManager);
  const landingPage = new _landingPage.LandingPage(appManager, menuicons);
  const sidePanel = new _sidePanel.SidePanel(appManager, menuicons);
  const hiddenPanel = new _hiddenPanel.HiddenPanel();
  const pluginManagerComponent = new PluginManagerComponent(appManager, engine);
  const filePanel = new FilePanel(appManager);
  let settings = new SettingsTab(registry.get('config').api, editor, appManager); // adding Views to the DOM

  self._view.mainpanel.appendChild(mainview.render());

  self._view.iconpanel.appendChild(menuicons.render());

  self._view.sidepanel.appendChild(sidePanel.render());

  document.body.appendChild(hiddenPanel.render()); // Hidden Panel is display none, it can be directly on body

  engine.register([menuicons, landingPage, hiddenPanel, sidePanel, pluginManagerComponent, filePanel, settings]); // CONTENT VIEWS & DEFAULT PLUGINS

  const compileTab = new CompileTab(editor, registry.get('config').api, new Renderer(), registry.get('fileproviders/browser').api, registry.get('filemanager').api);
  const run = new _udapp.RunTab(blockchain, pluginUdapp, registry.get('config').api, registry.get('filemanager').api, registry.get('editor').api, filePanel, registry.get('compilersartefacts').api, networkModule, mainview, registry.get('fileproviders/browser').api);
  const analysis = new AnalysisTab(registry);
  const debug = new DebuggerTab(blockchain);
  const test = new TestTab(registry.get('filemanager').api, filePanel, compileTab, appManager, new Renderer());
  engine.register([compileTab, run, debug, analysis, test, filePanel.remixdHandle]);

  try {
    engine.register(await appManager.registeredPlugins());
  } catch (e) {
    console.log('couldn\'t register iframe plugins', e.message);
  }

  await appManager.activatePlugin(['contentImport', 'theme', 'editor', 'fileManager', 'compilerMetadata', 'compilerArtefacts', 'network', 'web3Provider', 'offsetToLineColumnConverter']);
  await appManager.activatePlugin(['mainPanel', 'menuicons']);
  await appManager.activatePlugin(['sidePanel']); // activating  host plugin separately

  await appManager.activatePlugin(['home', 'hiddenPanel', 'pluginManager', 'fileExplorers', 'settings', 'contextualListener', 'scriptRunner', 'terminal', 'fetchAndCompile']);
  const queryParams = new QueryParams();
  const params = queryParams.get(); // Set workspace after initial activation

  if (Array.isArray(workspace)) {
    try {
      await appManager.activatePlugin(workspace);
    } catch (e) {
      console.error(e);
    }
  } else {
    // activate solidity plugin
    appManager.ensureActivated('solidity');
    appManager.ensureActivated('udapp');
  } // Load and start the service who manager layout and frame


  const framingService = new _framingService.FramingService(sidePanel, menuicons, mainview, this._components.resizeFeature);
  framingService.start(params); // If plugins are loaded from the URL params, we focus on the last one.

  if (pluginLoader.current === 'queryParams' && Array.isArray(workspace) && workspace.length > 0) menuicons.select(workspace[workspace.length - 1]); // get the file list from the parent iframe

  loadFileFromParent(fileManager); // get the file from gist

  const gistHandler = new GistHandler();
  const loadedFromGist = gistHandler.loadFromGist(params, fileManager);

  if (!loadedFromGist) {
    // insert example contracts if there are no files to show
    self._components.filesProviders['browser'].resolveDirectory('/', (error, filesList) => {
      if (error) console.error(error);

      if (Object.keys(filesList).length === 0) {
        for (let file in examples) {
          fileManager.writeFile(examples[file].name, examples[file].content);
        }
      }
    });
  }

  if (isElectron()) {
    appManager.activatePlugin('remixd');
  }

  if (params.embed) framingService.embed();
}

/***/ }),

/***/ "./app/compiler/compiler-abstract.js":
/*!*******************************************!*\
  !*** ./app/compiler/compiler-abstract.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var txHelper = remixLib.execution.txHelper;
module.exports = class CompilerAbstract {
  constructor(languageversion, data, source) {
    this.languageversion = languageversion;
    this.data = data;
    this.source = source; // source code
  }

  getContracts() {
    return this.data.contracts;
  }

  getContract(name) {
    return txHelper.getContract(name, this.data.contracts);
  }

  visitContracts(calllback) {
    return txHelper.visitContracts(this.data.contracts, calllback);
  }

  getData() {
    return this.data;
  }

  getAsts() {
    return this.data.sources; // ast
  }

  getSourceName(fileIndex) {
    if (this.data && this.data.sources) {
      return Object.keys(this.data.sources)[fileIndex];
    } else if (Object.keys(this.source.sources).length === 1) {
      // if we don't have ast, we return the only one filename present.
      const sourcesArray = Object.keys(this.source.sources);
      return sourcesArray[0];
    }

    return null;
  }

  getSourceCode() {
    return this.source;
  }

};

/***/ }),

/***/ "./app/compiler/compiler-artefacts.js":
/*!********************************************!*\
  !*** ./app/compiler/compiler-artefacts.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _compilerAbstract = _interopRequireDefault(__webpack_require__(/*! ./compiler-abstract */ "./app/compiler/compiler-abstract.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const profile = {
  name: 'compilerArtefacts',
  methods: [],
  events: [],
  version: packageJson.version
};
module.exports = class CompilerArtefacts extends _engine.Plugin {
  constructor() {
    super(profile);
    this.compilersArtefacts = {};
    this.compilersArtefactsPerFile = {};
  }

  clear() {
    this.compilersArtefacts = {};
    this.compilersArtefactsPerFile = {};
  }

  onActivation() {
    const saveCompilationPerFileResult = (file, source, languageVersion, data) => {
      this.compilersArtefactsPerFile[file] = new _compilerAbstract.default(languageVersion, data, source);
    };

    this.on('solidity', 'compilationFinished', (file, source, languageVersion, data) => {
      this.compilersArtefacts['__last'] = new _compilerAbstract.default(languageVersion, data, source);
      saveCompilationPerFileResult(file, source, languageVersion, data);
    });
    this.on('vyper', 'compilationFinished', (file, source, languageVersion, data) => {
      this.compilersArtefacts['__last'] = new _compilerAbstract.default(languageVersion, data, source);
      saveCompilationPerFileResult(file, source, languageVersion, data);
    });
    this.on('lexon', 'compilationFinished', (file, source, languageVersion, data) => {
      this.compilersArtefacts['__last'] = new _compilerAbstract.default(languageVersion, data, source);
      saveCompilationPerFileResult(file, source, languageVersion, data);
    });
    this.on('yulp', 'compilationFinished', (file, source, languageVersion, data) => {
      this.compilersArtefacts['__last'] = new _compilerAbstract.default(languageVersion, data, source);
      saveCompilationPerFileResult(file, source, languageVersion, data);
    });
  }

  getAllContractDatas() {
    const contractsData = {};
    Object.keys(this.compilersArtefactsPerFile).map(targetFile => {
      const contracts = this.compilersArtefactsPerFile[targetFile].getContracts();
      Object.keys(contracts).map(file => {
        contractsData[file] = contracts[file];
      });
    }); // making sure we save last compilation result in there

    if (this.compilersArtefacts['__last']) {
      const contracts = this.compilersArtefacts['__last'].getContracts();
      Object.keys(contracts).map(file => {
        contractsData[file] = contracts[file];
      });
    }

    return contractsData;
  }

  addResolvedContract(address, compilerData) {
    this.compilersArtefacts[address] = compilerData;
  }

  isResolved(address) {
    return this.compilersArtefacts[address] !== undefined;
  }

  get(key) {
    return this.compilersArtefacts[key];
  }

};

/***/ }),

/***/ "./app/compiler/compiler-helpers.js":
/*!******************************************!*\
  !*** ./app/compiler/compiler-helpers.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compile = void 0;

var _compilerUtils = __webpack_require__(/*! ./compiler-utils */ "./app/compiler/compiler-utils.js");

var _remixSolidity = __webpack_require__(/*! @remix-project/remix-solidity */ "../../../dist/libs/remix-solidity/index.js");

var _compilerAbstract = _interopRequireDefault(__webpack_require__(/*! ./compiler-abstract */ "./app/compiler/compiler-abstract.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const compile = async (compilationTargets, settings) => {
  return await (() => {
    return new Promise((resolve, reject) => {
      const compiler = new _remixSolidity.Compiler(() => {});
      compiler.set('evmVersion', settings.evmVersion);
      compiler.set('optimize', settings.optimize);
      compiler.set('language', settings.language);
      compiler.loadVersion((0, _compilerUtils.canUseWorker)(settings.version), (0, _compilerUtils.urlFromVersion)(settings.version));
      compiler.event.register('compilationFinished', (success, compilationData, source) => {
        resolve(new _compilerAbstract.default(settings.version, compilationData, source));
      });
      compiler.event.register('compilerLoaded', _ => compiler.compile(compilationTargets, ''));
    });
  })();
};

exports.compile = compile;

/***/ }),

/***/ "./app/compiler/compiler-imports.js":
/*!******************************************!*\
  !*** ./app/compiler/compiler-imports.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var base64 = __webpack_require__(/*! js-base64 */ "../../../node_modules/js-base64/base64.js").Base64;

var swarmgw = __webpack_require__(/*! swarmgw */ "../../../node_modules/swarmgw/index.js")();

var resolver = __webpack_require__(/*! @resolver-engine/imports */ "../../../node_modules/@resolver-engine/imports/build/index.js").ImportsEngine();

var request = __webpack_require__(/*! request */ "../../../node_modules/request/index.js");

const profile = {
  name: 'contentImport',
  displayName: 'content import',
  version: packageJson.version,
  methods: ['resolve']
};
module.exports = class CompilerImports extends _engine.Plugin {
  constructor() {
    super(profile);
    this.previouslyHandled = {}; // cache import so we don't make the request at each compilation.
  }

  handleGithubCall(root, path, cb) {
    let param = '?'; // const token = await this.call('settings', 'getGithubAccessToken')

    const token = globalRegistry.get('config').api.get('settings/gist-access-token'); // TODO replace with the plugin call above https://github.com/ethereum/remix-ide/issues/2288

    param += token ? 'access_token=' + token : '';
    const regex = path.match(/blob\/([^/]+)\/(.*)/);

    if (regex) {
      // if we have /blob/master/+path we extract the branch name "master" and add it as a parameter to the github api
      // the ref can be branch name, tag, commit id
      const reference = regex[1];
      param += '&ref=' + reference;
      path = path.replace(`blob/${reference}/`, '');
    }

    return request.get({
      url: 'https://api.github.com/repos/' + root + '/contents/' + path + param,
      json: true
    }, (err, r, data) => {
      if (err) {
        return cb(err || 'Unknown transport error');
      }

      if ('content' in data) {
        cb(null, base64.decode(data.content), root + '/' + path);
      } else if ('message' in data) {
        cb(data.message);
      } else {
        cb('Content not received');
      }
    });
  }

  handleSwarmImport(url, cleanUrl, cb) {
    swarmgw.get(url, function (err, content) {
      cb(err, content, cleanUrl);
    });
  }

  handleIPFS(url, cb) {
    // replace ipfs:// with /ipfs/
    url = url.replace(/^ipfs:\/\/?/, 'ipfs/');
    return request.get({
      url: 'https://ipfsgw.komputing.org/' + url
    }, (err, r, data) => {
      if (err) {
        return cb(err || 'Unknown transport error');
      }

      cb(null, data, url);
    });
  }

  handleHttpCall(url, cleanUrl, cb) {
    return request.get({
      url
    }, (err, r, data) => {
      if (err) {
        return cb(err || 'Unknown transport error');
      }

      cb(null, data, cleanUrl);
    });
  }

  handlers() {
    return [{
      type: 'github',
      match: /^(https?:\/\/)?(www.)?github.com\/([^/]*\/[^/]*)\/(.*)/,
      handler: (match, cb) => {
        this.handleGithubCall(match[3], match[4], cb);
      }
    }, {
      type: 'http',
      match: /^(http?:\/\/?(.*))$/,
      handler: (match, cb) => {
        this.handleHttpCall(match[1], match[2], cb);
      }
    }, {
      type: 'https',
      match: /^(https?:\/\/?(.*))$/,
      handler: (match, cb) => {
        this.handleHttpCall(match[1], match[2], cb);
      }
    }, {
      type: 'swarm',
      match: /^(bzz-raw?:\/\/?(.*))$/,
      handler: (match, cb) => {
        this.handleSwarmImport(match[1], match[2], cb);
      }
    }, {
      type: 'ipfs',
      match: /^(ipfs:\/\/?.+)/,
      handler: (match, cb) => {
        this.handleIPFS(match[1], cb);
      }
    }];
  }

  isRelativeImport(url) {
    return /^([^/]+)/.exec(url);
  }

  resolve(url) {
    return new Promise((resolve, reject) => {
      this.import(url, null, (error, content, cleanUrl, type, url) => {
        if (error) return reject(error);
        resolve({
          content,
          cleanUrl,
          type,
          url
        });
      });
    });
  }

  import(url, force, loadingCb, cb) {
    if (typeof force !== 'boolean') {
      let temp = loadingCb;
      loadingCb = force;
      cb = temp;
      force = false;
    }

    if (!loadingCb) loadingCb = () => {};
    if (!cb) cb = () => {};
    var self = this;
    if (force) delete this.previouslyHandled[url];
    var imported = this.previouslyHandled[url];

    if (imported) {
      return cb(null, imported.content, imported.cleanUrl, imported.type, url);
    }

    var handlers = this.handlers();
    var found = false;
    handlers.forEach(function (handler) {
      if (found) {
        return;
      }

      var match = handler.match.exec(url);

      if (match) {
        found = true;
        loadingCb('Loading ' + url + ' ...');
        handler.handler(match, function (err, content, cleanUrl) {
          if (err) {
            cb('Unable to import "' + cleanUrl + '": ' + err);
            return;
          }

          self.previouslyHandled[url] = {
            content: content,
            cleanUrl: cleanUrl,
            type: handler.type
          };
          cb(null, content, cleanUrl, handler.type, url);
        });
      }
    });
    if (found) return;
    resolver.resolve(url).then(result => {
      return resolver.require(url);
    }).then(result => {
      if (url.indexOf(result.provider + ':') === 0) {
        url = url.substring(result.provider.length + 1); // remove the github prefix
      }

      cb(null, result.source, url, result.provider, result.url);
    }).catch(err => {
      err;
      cb('Unable to import "' + url + '": File not found');
    });
  }

};

/***/ }),

/***/ "./app/compiler/compiler-sourceVerifier-fetchAndCompile.js":
/*!*****************************************************************!*\
  !*** ./app/compiler/compiler-sourceVerifier-fetchAndCompile.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var _compilerHelpers = __webpack_require__(/*! ./compiler-helpers */ "./app/compiler/compiler-helpers.js");

var _registry = _interopRequireDefault(__webpack_require__(/*! ../../global/registry */ "./global/registry.js"));

var _remixLib = _interopRequireDefault(__webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const ethutil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const profile = {
  name: 'fetchAndCompile',
  methods: ['resolve'],
  version: packageJson.version
};

class FetchAndCompile extends _engine.Plugin {
  constructor() {
    super(profile);
    this.unresolvedAddresses = [];
    this.sourceVerifierNetWork = ['Main', 'Rinkeby', 'Ropsten', 'Goerli'];
  }
  /**
   * Fetch compiliation metadata from source-Verify from a given @arg contractAddress - https://github.com/ethereum/source-verify
   * Put the artifacts in the file explorer
   * Compile the code using Solidity compiler
   * Returns compilation data
   *
   * @param {string} contractAddress - Address of the contrac to resolve
   * @param {string} compilersartefacts - Object containing a mapping of compilation results (byContractAddress and __last)
   * @return {CompilerAbstract} - compilation data targeting the given @arg contractAddress
   */


  async resolve(contractAddress, targetPath, web3) {
    contractAddress = ethutil.toChecksumAddress(contractAddress);

    const compilersartefacts = _registry.default.get('compilersartefacts').api;

    const localCompilation = () => compilersartefacts.get('__last') ? compilersartefacts.get('__last') : null;

    const resolved = compilersartefacts.get(contractAddress);
    if (resolved) return resolved;
    if (this.unresolvedAddresses.includes(contractAddress)) return localCompilation(); // sometimes when doing an internal call, the only available artifact is the Solidity interface.
    // resolving addresses of internal call would allow to step over the source code, even if the declaration was made using an Interface.

    let network;

    try {
      network = await this.call('network', 'detectNetwork');
    } catch (e) {
      return localCompilation();
    }

    if (!network) return localCompilation();
    if (!this.sourceVerifierNetWork.includes(network.name)) return localCompilation(); // check if the contract if part of the local compilation result

    const codeAtAddress = await web3.eth.getCode(contractAddress);
    const compilation = localCompilation();

    if (compilation) {
      let found = false;
      compilation.visitContracts(contract => {
        found = _remixLib.default.util.compareByteCode('0x' + contract.object.evm.deployedBytecode.object, codeAtAddress);
        return found;
      });

      if (found) {
        compilersartefacts.addResolvedContract(contractAddress, compilation);
        setTimeout(_ => this.emit('usingLocalCompilation', contractAddress), 0);
        return compilation;
      }
    }

    let name = network.name.toLowerCase();
    name === 'main' ? 'mainnet' : name; // source-verifier api expect "mainnet" and not "main"

    let data;

    try {
      data = await this.call('source-verification', 'fetchByNetwork', contractAddress, name.toLowerCase());
    } catch (e) {
      setTimeout(_ => this.emit('notFound', contractAddress), 0); // plugin framework returns a time out error although it actually didn't find the source...

      this.unresolvedAddresses.push(contractAddress);
      return localCompilation();
    }

    if (!data || !data.metadata) {
      setTimeout(_ => this.emit('notFound', contractAddress), 0);
      this.unresolvedAddresses.push(contractAddress);
      return localCompilation();
    } // set the solidity contract code using metadata


    await this.call('fileManager', 'setFile', `${targetPath}/${name}/${contractAddress}/metadata.json`, JSON.stringify(data.metadata, null, '\t'));
    let compilationTargets = {};

    for (let file in data.metadata.sources) {
      const urls = data.metadata.sources[file].urls;

      for (let url of urls) {
        if (url.includes('ipfs')) {
          let stdUrl = `ipfs://${url.split('/')[2]}`;
          const source = await this.call('contentImport', 'resolve', stdUrl);
          file = file.replace('browser/', ''); // should be fixed in the remix IDE end.

          const path = `${targetPath}/${name}/${contractAddress}/${file}`;
          await this.call('fileManager', 'setFile', path, source.content);
          compilationTargets[path] = {
            content: source.content
          };
          break;
        }
      }
    } // compile


    const settings = {
      version: data.metadata.compiler.version,
      language: data.metadata.language,
      evmVersion: data.metadata.settings.evmVersion,
      optimize: data.metadata.settings.optimizer.enabled
    };

    try {
      setTimeout(_ => this.emit('compiling', settings), 0);
      const compData = await (0, _compilerHelpers.compile)(compilationTargets, settings);
      compilersartefacts.addResolvedContract(contractAddress, compData);
      return compData;
    } catch (e) {
      this.unresolvedAddresses.push(contractAddress);
      setTimeout(_ => this.emit('compilationFailed'), 0);
      return localCompilation();
    }
  }

}

exports.default = FetchAndCompile;

/***/ }),

/***/ "./app/compiler/compiler-utils.js":
/*!****************************************!*\
  !*** ./app/compiler/compiler-utils.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.urlFromVersion = urlFromVersion;
exports.canUseWorker = canUseWorker;
exports.promisedMiniXhr = promisedMiniXhr;
exports.pathToURL = exports.baseURLWasm = exports.baseURLBin = void 0;

const semver = __webpack_require__(/*! semver */ "../../../node_modules/semver/semver.js");

const minixhr = __webpack_require__(/*! minixhr */ "../../../node_modules/minixhr/minixhr.js");
/* global Worker */


const baseURLBin = 'https://solc-bin.ethereum.org/bin';
exports.baseURLBin = baseURLBin;
const baseURLWasm = 'https://solc-bin.ethereum.org/wasm';
exports.baseURLWasm = baseURLWasm;
const pathToURL = {};
/**
 * Retrieves the URL of the given compiler version
 * @param version is the version of compiler with or without 'soljson-v' prefix and .js postfix
 */

exports.pathToURL = pathToURL;

function urlFromVersion(version) {
  if (!version.startsWith('soljson-v')) version = 'soljson-v' + version;
  if (!version.endsWith('.js')) version = version + '.js';
  return `${pathToURL[version]}/${version}`;
}
/**
 * Checks if the worker can be used to load a compiler.
 * checks a compiler whitelist, browser support and OS.
 */


function canUseWorker(selectedVersion) {
  const version = semver.coerce(selectedVersion);
  const isNightly = selectedVersion.includes('nightly');
  return browserSupportWorker() && (semver.gt(version, '0.6.3') || semver.gt(version, '0.3.6') && !isNightly);
}

function browserSupportWorker() {
  return document.location.protocol !== 'file:' && Worker !== undefined;
} // returns a promise for minixhr


function promisedMiniXhr(url) {
  return new Promise((resolve, reject) => {
    minixhr(url, (json, event) => {
      resolve({
        json,
        event
      });
    });
  });
}

/***/ }),

/***/ "./app/components/hidden-panel.js":
/*!****************************************!*\
  !*** ./app/components/hidden-panel.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HiddenPanel = void 0;

var _panel = __webpack_require__(/*! ./panel */ "./app/components/panel.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const css = csjs`
  .pluginsContainer {
    display: none;
  }
`;
const profile = {
  name: 'hiddenPanel',
  displayName: 'Hidden Panel',
  description: '',
  version: packageJson.version,
  methods: ['addView', 'removeView']
};

class HiddenPanel extends _panel.AbstractPanel {
  constructor() {
    super(profile);
  }

  render() {
    return yo`
      <div class=${css.pluginsContainer}>
        ${this.view}
      </div>`;
  }

}

exports.HiddenPanel = HiddenPanel;

/***/ }),

/***/ "./app/components/local-plugin.js":
/*!****************************************!*\
  !*** ./app/components/local-plugin.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global localStorage */
const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const modalDialog = __webpack_require__(/*! ../ui/modaldialog */ "./app/ui/modaldialog.js");

const defaultProfile = {
  methods: [],
  location: 'sidePanel',
  type: 'iframe'
};
module.exports = class LocalPlugin {
  /**
   * Open a modal to create a local plugin
   * @param {Profile[]} plugins The list of the plugins in the store
   * @returns {Promise<{api: any, profile: any}>} A promise with the new plugin profile
   */
  open(plugins) {
    this.profile = JSON.parse(localStorage.getItem('plugins/local')) || defaultProfile;
    return new Promise((resolve, reject) => {
      const onValidation = () => {
        try {
          const profile = this.create();
          resolve(profile);
        } catch (err) {
          reject(err);
        }
      };

      modalDialog('Local Plugin', this.form(), {
        fn: () => onValidation()
      }, {
        fn: () => resolve()
      });
    });
  }
  /**
   * Create the object to add to the plugin-list
   */


  create() {
    const profile = {
      icon: 'assets/img/localPlugin.webp',
      methods: [],
      location: 'sidePanel',
      type: 'iframe',
      ...this.profile,
      hash: `local-${this.profile.name}`
    };
    if (!profile.location) throw new Error('Plugin should have a location');
    if (!profile.name) throw new Error('Plugin should have a name');
    if (!profile.url) throw new Error('Plugin should have an URL');
    localStorage.setItem('plugins/local', JSON.stringify(profile));
    return profile;
  }

  updateName({
    target
  }) {
    this.profile.name = target.value;
  }

  updateUrl({
    target
  }) {
    this.profile.url = target.value;
  }

  updateDisplayName({
    target
  }) {
    this.profile.displayName = target.value;
  }

  updateProfile(key, e) {
    this.profile[key] = e.target.value;
  }
  /** The form to create a local plugin */


  form() {
    const name = this.profile.name || '';
    const url = this.profile.url || '';
    const displayName = this.profile.displayName || '';

    const radioSelection = (key, label, message) => {
      return this.profile[key] === label ? yo`<div class="radio">
          <input class="form-check-input" type="radio" name="${key}" onclick="${e => this.updateProfile(key, e)}" value="${label}" id="${label}" data-id="localPluginRadioButton${label}" checked="checked" />
          <label class="form-check-label" for="${label}">${message}</label>
        </div>` : yo`<div class="radio">
          <input class="form-check-input" type="radio" name="${key}" onclick="${e => this.updateProfile(key, e)}" value="${label}" id="${label}" data-id="localPluginRadioButton${label}" />
          <label class="form-check-label" for="${label}">${message}</label>
        </div>`;
    };

    return yo`
    <form id="local-plugin-form">
      <div class="form-group">
        <label for="plugin-name">Plugin Name <small>(required)</small></label>
        <input class="form-control" onchange="${e => this.updateName(e)}" value="${name}" id="plugin-name" data-id="localPluginName" placeholder="Should be camelCase">
      </div>
      <div class="form-group">
        <label for="plugin-displayname">Display Name</label>
        <input class="form-control" onchange="${e => this.updateDisplayName(e)}" value="${displayName}" id="plugin-displayname" data-id="localPluginDisplayName" placeholder="Name in the header">
      </div>
      <div class="form-group">
        <label for="plugin-url">Url <small>(required)</small></label>
        <input class="form-control" onchange="${e => this.updateUrl(e)}" value="${url}" id="plugin-url" data-id="localPluginUrl" placeholder="ex: https://localhost:8000">
      </div>
      <h6>Type of connection <small>(required)</small></h6>
      <div class="form-check form-group">
        ${radioSelection('type', 'iframe', 'Iframe')}
        ${radioSelection('type', 'ws', 'Websocket')}
      </div>
      <h6>Location in remix <small>(required)</small></h6>
      <div class="form-check form-group">
        ${radioSelection('location', 'sidePanel', 'Side Panel')}
        ${radioSelection('location', 'mainPanel', 'Main Panel')}
        ${radioSelection('location', 'none', 'None')}
      </div>
    </form>`;
  }

};

/***/ }),

/***/ "./app/components/main-panel.js":
/*!**************************************!*\
  !*** ./app/components/main-panel.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MainPanel = void 0;

var _panel = __webpack_require__(/*! ./panel */ "./app/components/panel.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const css = csjs`
  .pluginsContainer {
    height: 100%;
    display: flex;
    overflow-y: hidden;
  }
`;
const profile = {
  name: 'mainPanel',
  displayName: 'Main Panel',
  description: '',
  version: packageJson.version,
  methods: ['addView', 'removeView']
};

class MainPanel extends _panel.AbstractPanel {
  constructor() {
    super(profile);
  }

  render() {
    return yo`
      <div class=${css.pluginsContainer} data-id="mainPanelPluginsContainer">
        ${this.view}
      </div>`;
  }

}

exports.MainPanel = MainPanel;

/***/ }),

/***/ "./app/components/panel.js":
/*!*********************************!*\
  !*** ./app/components/panel.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbstractPanel = void 0;

var _events = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const css = csjs`
  .plugins        {
    height: 100%;
  }
  .plugItIn       {
    display        : none;
    height         : 100%;
  }
  .plugItIn > div {
    overflow-y     : auto;
    height         : 100%;
    width          : 100%;
  }
  .plugItIn.active     {
    display        : block;
  }
  .pluginsContainer {
    height         : 100%;
    overflow-y     : hidden;
  }
`;
/** Abstract class used for hosting the view of a plugin */

class AbstractPanel extends _engine.HostPlugin {
  constructor(profile) {
    super(profile);
    this.events = new _events.EventEmitter();
    this.contents = {};
    this.active = undefined; // View where the plugin HTMLElement leaves

    this.view = yo`<div id="plugins" class="${css.plugins}"></div>`;
  }
  /**
   * Add the plugin to the panel
   * @param {String} name the name of the plugin
   * @param {HTMLElement} content the HTMLContent of the plugin
   */


  add(view, name) {
    if (this.contents[name]) throw new Error(`Plugin ${name} already rendered`);
    view.style.height = '100%';
    view.style.width = '100%';
    view.style.border = '0';
    const isIframe = view.tagName === 'IFRAME';
    view.style.display = isIframe ? 'none' : 'block';
    const loading = isIframe ? yo`
      <div class="d-flex justify-content-center align-items-center">
        <div class="spinner-border" role="status">
          <span class="sr-only">Loading...</span>
        </div>
      </div>  
    ` : '';
    this.contents[name] = yo`<div class="${css.plugItIn}" >${view}${loading}</div>`;

    if (view.tagName === 'IFRAME') {
      view.addEventListener('load', () => {
        if (this.contents[name].contains(loading)) {
          this.contents[name].removeChild(loading);
        }

        view.style.display = 'block';
      });
    }

    this.contents[name].style.display = 'none';
    this.view.appendChild(this.contents[name]);
  }

  addView(profile, view) {
    this.add(view, profile.name);
  }

  removeView(profile) {
    this.remove(profile.name);
  }
  /**
   * Remove a plugin from the panel
   * @param {String} name The name of the plugin to remove
   */


  remove(name) {
    const el = this.contents[name];
    delete this.contents[name];
    if (el) el.parentElement.removeChild(el);
    if (name === this.active) this.active = undefined;
  }
  /**
   * Display the content of this specific plugin
   * @param {String} name The name of the plugin to display the content
   */


  showContent(name) {
    if (!this.contents[name]) throw new Error(`Plugin ${name} is not yet activated`); // hiding the current view and display the `moduleName`

    if (this.active) {
      this.contents[this.active].style.display = 'none';
    }

    this.contents[name].style.display = 'flex';
    this.active = name;
  }

  focus(name) {
    this.showContent(name);
  }

}

exports.AbstractPanel = AbstractPanel;

/***/ }),

/***/ "./app/components/plugin-manager-component.js":
/*!****************************************************!*\
  !*** ./app/components/plugin-manager-component.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var _pluginManagerSettings = __webpack_require__(/*! ./plugin-manager-settings */ "./app/components/plugin-manager-settings.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

const LocalPlugin = __webpack_require__(/*! ./local-plugin */ "./app/components/local-plugin.js");

const addToolTip = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

const css = csjs`
  .pluginSearch {
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: var(--light);
    padding: 10px;
    position: sticky;
    top: 0;
    z-index: 2;
    margin-bottom: 0px;
  }
  .pluginSearchInput {
    height: 38px;
  }
  .pluginSearchButton {
    font-size: 13px;
  }
  .displayName {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .description {
    font-size: 13px;
    line-height: 18px;
    text-transform: capitalize;
  }
  .row {
    display: flex;
    flex-direction: row;
  }
  .isStuck {
    background-color: var(--primary);
    color: 
  }
  .versionWarning {
    padding: 4px;
    margin: 0 8px;
    font-weight: 700;
    font-size: 9px;
    line-height: 12px;
    text-transform: uppercase;
    cursor: default;
    border: 1px solid;
    border-radius: 2px;
  }
`;
const profile = {
  name: 'pluginManager',
  displayName: 'Plugin manager',
  methods: [],
  events: [],
  icon: 'assets/img/pluginManager.webp',
  description: 'Start/stop services, modules and plugins',
  kind: 'settings',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/plugin_manager.html',
  version: packageJson.version
};

class PluginManagerComponent extends _engine.ViewPlugin {
  constructor(appManager, engine) {
    super(profile);
    this.event = new EventEmitter();
    this.appManager = appManager;
    this.views = {
      root: null,
      items: {}
    };
    this.localPlugin = new LocalPlugin();
    this.filter = '';
    this.appManager.event.on('activate', () => {
      this.reRender();
    });
    this.appManager.event.on('deactivate', () => {
      this.reRender();
    });
    this.appManager.event.on('added', () => {
      this.reRender();
    });
    this.engine = engine;
  }

  isActive(name) {
    return this.appManager.actives.includes(name);
  }

  renderItem(profile) {
    const displayName = profile.displayName ? profile.displayName : profile.name; // Check version of the plugin

    let versionWarning; // Alpha

    if (profile.version && profile.version.match(/\b(\w*alpha\w*)\b/g)) {
      versionWarning = yo`<small title="Version Alpha" class="${css.versionWarning} plugin-version">alpha</small>`;
    } // Beta


    if (profile.version && profile.version.match(/\b(\w*beta\w*)\b/g)) {
      versionWarning = yo`<small title="Version Beta" class="${css.versionWarning} plugin-version">beta</small>`;
    }

    const activationButton = this.isActive(profile.name) ? yo`
      <button
        onclick="${_ => this.appManager.deactivatePlugin(profile.name)}"
        class="btn btn-secondary btn-sm" data-id="pluginManagerComponentDeactivateButton${profile.name}"
      >
        Deactivate
      </button>
      ` : yo`
      <button
        onclick="${_ => this.appManager.activatePlugin(profile.name)}"
        class="btn btn-success btn-sm" data-id="pluginManagerComponentActivateButton${profile.name}"
      >
        Activate
      </button>`;
    return yo`
      <article id="remixPluginManagerListItem_${profile.name}" class="list-group-item py-1 plugins-list-group-item" title="${displayName}" >
        <div class="${css.row} justify-content-between align-items-center mb-2">
          <h6 class="${css.displayName} plugin-name">
            ${displayName}
            ${versionWarning}
          </h6>
          ${activationButton}
        </div>
        <p class="${css.description} text-body plugin-text">${profile.description}</p>
      </article>
    `;
  }
  /***************
   * SUB-COMPONENT
   */

  /**
   * Add a local plugin to the list of plugins
   */


  async openLocalPlugin() {
    try {
      const profile = await this.localPlugin.open(this.appManager.getAll());
      if (!profile) return;

      if (this.appManager.getIds().includes(profile.name)) {
        throw new Error('This name has already been used');
      }

      const plugin = profile.type === 'iframe' ? new _engine.IframePlugin(profile) : new _engine.WebsocketPlugin(profile);
      this.engine.register(plugin);
      this.appManager.activatePlugin(plugin.name);
    } catch (err) {
      // TODO : Use an alert to handle this error instead of a console.log
      console.log(`Cannot create Plugin : ${err.message}`);
      addToolTip(`Cannot create Plugin : ${err.message}`);
    }
  }

  render() {
    // Filtering helpers
    const isFiltered = profile => (profile.displayName ? profile.displayName : profile.name).toLowerCase().includes(this.filter);

    const isNotRequired = profile => !this.appManager.isRequired(profile.name);

    const isNotHome = profile => profile.name !== 'home';

    const sortByName = (profileA, profileB) => {
      const nameA = (profileA.displayName ? profileA.displayName : profileA.name).toUpperCase();
      const nameB = (profileB.displayName ? profileB.displayName : profileB.name).toUpperCase();
      return nameA < nameB ? -1 : nameA > nameB ? 1 : 0;
    }; // Filter all active and inactive modules that are not required


    const {
      actives,
      inactives
    } = this.appManager.getAll().filter(isFiltered).filter(isNotRequired).filter(isNotHome).sort(sortByName).reduce(({
      actives,
      inactives
    }, profile) => {
      return this.isActive(profile.name) ? {
        actives: [...actives, profile],
        inactives
      } : {
        inactives: [...inactives, profile],
        actives
      };
    }, {
      actives: [],
      inactives: []
    });
    const activeTile = actives.length !== 0 ? yo`
      <nav class="plugins-list-header justify-content-between navbar navbar-expand-lg bg-light navbar-light align-items-center">
        <span class="navbar-brand plugins-list-title">Active Modules</span>
        <span class="badge badge-primary" data-id="pluginManagerComponentActiveTilesCount">${actives.length}</span>
      </nav>` : '';
    const inactiveTile = inactives.length !== 0 ? yo`
      <nav class="plugins-list-header justify-content-between navbar navbar-expand-lg bg-light navbar-light align-items-center">
        <span class="navbar-brand plugins-list-title h6 mb-0 mr-2">Inactive Modules</span>
        <span class="badge badge-primary" style = "cursor: default;" data-id="pluginManagerComponentInactiveTilesCount">${inactives.length}</span>
      </nav>` : '';
    const settings = new _pluginManagerSettings.PluginManagerSettings().render();
    const rootView = yo`
      <div id='pluginManager' data-id="pluginManagerComponentPluginManager">
        <header class="form-group ${css.pluginSearch} plugins-header py-3 px-4 border-bottom" data-id="pluginManagerComponentPluginManagerHeader">
          <input onkeyup="${e => this.filterPlugins(e)}" class="${css.pluginSearchInput} form-control" placeholder="Search" data-id="pluginManagerComponentSearchInput">
          <button onclick="${_ => this.openLocalPlugin()}" class="${css.pluginSearchButton} btn bg-transparent text-dark border-0 mt-2 text-underline" data-id="pluginManagerComponentPluginSearchButton">
            Connect to a Local Plugin
          </button>
        </header>
        <section data-id="pluginManagerComponentPluginManagerSection">
          ${activeTile}
          <div class="list-group list-group-flush plugins-list-group" data-id="pluginManagerComponentActiveTile">
            ${actives.map(profile => this.renderItem(profile))}
          </div>
          ${inactiveTile}
          <div class="list-group list-group-flush plugins-list-group" data-id="pluginManagerComponentInactiveTile">
            ${inactives.map(profile => this.renderItem(profile))}
          </div>
        </section>
        ${settings}
      </div>
    `;
    if (!this.views.root) this.views.root = rootView;
    return rootView;
  }

  reRender() {
    if (this.views.root) {
      yo.update(this.views.root, this.render());
    }
  }

  filterPlugins({
    target
  }) {
    this.filter = target.value.toLowerCase();
    this.reRender();
  }

}

module.exports = PluginManagerComponent;

/***/ }),

/***/ "./app/components/plugin-manager-settings.js":
/*!***************************************************!*\
  !*** ./app/components/plugin-manager-settings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PluginManagerSettings = void 0;

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const modalDialog = __webpack_require__(/*! ../ui/modaldialog */ "./app/ui/modaldialog.js");

const css = csjs` 
.permissions {
  position: sticky;
  bottom: 0;
  display: flex;
  justify-content: flex-end;
  align-items: center;
  padding: 5px 20px;
}
.permissions button {
  padding: 2px 5px;
  cursor: pointer;
}
.permissionForm h4 {
  font-size: 1.3rem;
  text-align: center;
}
.permissionForm h6 {
  font-size: 1.1rem;
}
.permissionForm hr {
  width: 80%;
}
.permissionKey {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.permissionKey i {
  cursor: pointer;
}
.checkbox {
  display: flex;
  align-items: center;
}
.checkbox label {
  margin: 0;
  font-size: 1rem;
}
`;

class PluginManagerSettings {
  openDialog() {
    const fromLocal = window.localStorage.getItem('plugins/permissions');
    this.permissions = JSON.parse(fromLocal || '{}');
    this.currentSetting = this.settings();
    modalDialog('Plugin Manager Permissions', this.currentSetting, {
      fn: () => this.onValidation()
    });
  }

  onValidation() {
    const permissions = JSON.stringify(this.permissions);
    window.localStorage.setItem('plugins/permissions', permissions);
  }
  /** Clear one permission from a plugin */


  clearPersmission(from, to, method) {
    if (this.permissions[to] && this.permissions[to][method]) {
      delete this.permissions[to][method][from];

      if (Object.keys(this.permissions[to][method]).length === 0) {
        delete this.permissions[to][method];
      }

      if (Object.keys(this.permissions[to]).length === 0) {
        delete this.permissions[to];
      }

      yo.update(this.currentSetting, this.settings());
    }
  }
  /** Clear all persmissions from a plugin */


  clearAllPersmission(to) {
    if (!this.permissions[to]) return;
    delete this.permissions[to];
    yo.update(this.currentSetting, this.settings());
  }

  settings() {
    const permissionByToPlugin = (toPlugin, funcObj) => {
      const permissionByMethod = (methodName, fromPlugins) => {
        const togglePermission = fromPlugin => {
          this.permissions[toPlugin][methodName][fromPlugin].allow = !this.permissions[toPlugin][methodName][fromPlugin].allow;
        };

        return Object.keys(fromPlugins).map(fromName => {
          const fromPluginPermission = fromPlugins[fromName];
          const checkbox = fromPluginPermission.allow ? yo`<input onchange=${() => togglePermission(fromName)} class="mr-2" type="checkbox" checked id="permission-checkbox-${toPlugin}-${methodName}-${toPlugin}" aria-describedby="module ${fromPluginPermission} asks permission for ${methodName}" />` : yo`<input onchange=${() => togglePermission(fromName)} class="mr-2" type="checkbox" id="permission-checkbox-${toPlugin}-${methodName}-${toPlugin}" aria-describedby="module ${fromPluginPermission} asks permission for ${methodName}" />`;
          return yo`
            <div class="form-group ${css.permissionKey}">
              <div class="${css.checkbox}">
                ${checkbox}
                <label for="permission-checkbox-${toPlugin}-${methodName}-${toPlugin}" data-id="permission-label-${toPlugin}-${methodName}-${toPlugin}">Allow <u>${fromName}</u> to call <u>${methodName}</u></label>
              </div>
              <i onclick="${() => this.clearPersmission(fromName, toPlugin, methodName)}" class="fa fa-trash-alt" data-id="pluginManagerSettingsRemovePermission-${toPlugin}-${methodName}-${toPlugin}"></i>
            </div>
          `;
        });
      };

      const permissionsByFunctions = Object.keys(funcObj).map(methodName => permissionByMethod(methodName, funcObj[methodName]));
      return yo`
      <div border p-2>
        <div class="pb-2 ${css.permissionKey}">
          <h3>${toPlugin} permissions:</h3>
          <i onclick="${() => this.clearAllPersmission(toPlugin)}" class="far fa-trash-alt" data-id="pluginManagerSettingsClearAllPermission-${toPlugin}"></i>
        </div>
        ${permissionsByFunctions}
      </div>`;
    };

    const byToPlugin = Object.keys(this.permissions).map(toPlugin => permissionByToPlugin(toPlugin, this.permissions[toPlugin]));
    const title = byToPlugin.length === 0 ? yo`<h4>No Permission requested yet.</h4>` : yo`<h4>Current Permission settings</h4>`;
    return yo`<form class="${css.permissionForm}" data-id="pluginManagerSettingsPermissionForm">
      ${title}
      <hr/>
      ${byToPlugin}
    </form>`;
  }

  render() {
    return yo`
    <footer class="bg-light ${css.permissions} remix-bg-opacity">
      <button onclick="${() => this.openDialog()}" class="btn btn-primary settings-button" data-id="pluginManagerPermissionsButton">Permissions</button>
    </footer>`;
  }

}

exports.PluginManagerSettings = PluginManagerSettings;

/***/ }),

/***/ "./app/components/side-panel.js":
/*!**************************************!*\
  !*** ./app/components/side-panel.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SidePanel = void 0;

var _panel = __webpack_require__(/*! ./panel */ "./app/components/panel.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const css = csjs`
  .panel {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    flex: auto;
  }
  .swapitTitle {
    margin: 0;
    text-transform: uppercase;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .swapitTitle i{
    padding-left: 6px;
    font-size: 14px;
  }
  .swapitHeader {
    display: flex;
    align-items: center;
    padding: 16px 24px 15px;
  }
  .icons i {
    height: 80%;
    cursor: pointer;
  }
  .pluginsContainer {
    height: 100%;
    overflow-y: auto;
  }
  .titleInfo {
    padding-left: 10px;
  }
  .versionBadge {
    background-color: var(--light);
    padding: 0 7px;
    font-weight: bolder;
    margin-left: 5px;
    text-transform: lowercase;
    cursor: default;
  }
`;
const sidePanel = {
  name: 'sidePanel',
  displayName: 'Side Panel',
  description: '',
  version: packageJson.version,
  methods: ['addView', 'removeView']
}; // TODO merge with vertical-icons.js

class SidePanel extends _panel.AbstractPanel {
  constructor(appManager, verticalIcons) {
    super(sidePanel);
    this.appManager = appManager;
    this.header = yo`<header></header>`;
    this.renderHeader();
    this.verticalIcons = verticalIcons; // Toggle content

    verticalIcons.events.on('toggleContent', name => {
      if (!this.contents[name]) return;

      if (this.active === name) {
        // TODO: Only keep `this.emit` (issue#2210)
        this.emit('toggle', name);
        this.events.emit('toggle', name);
        return;
      }

      this.showContent(name); // TODO: Only keep `this.emit` (issue#2210)

      this.emit('showing', name);
      this.events.emit('showing', name);
    }); // Force opening

    verticalIcons.events.on('showContent', name => {
      if (!this.contents[name]) return;
      this.showContent(name); // TODO: Only keep `this.emit` (issue#2210)

      this.emit('showing', name);
      this.events.emit('showing', name);
    });
  }

  removeView(profile) {
    super.removeView(profile);
    this.verticalIcons.unlinkContent(profile);
  }

  addView(profile, view) {
    super.addView(profile, view);
    this.verticalIcons.linkContent(profile);
  }
  /**
   * Display content and update the header
   * @param {String} name The name of the plugin to display
   */


  async showContent(name) {
    super.showContent(name);
    this.renderHeader();
  }
  /** The header of the side panel */


  async renderHeader() {
    let name = ' - ';
    let docLink = '';
    let versionWarning;

    if (this.active) {
      const profile = await this.appManager.getProfile(this.active);
      name = profile.displayName ? profile.displayName : profile.name;
      docLink = profile.documentation ? yo`<a href="${profile.documentation}" class="${css.titleInfo}" title="link to documentation" target="_blank"><i aria-hidden="true" class="fas fa-book"></i></a>` : '';

      if (profile.version && profile.version.match(/\b(\w*alpha\w*)\b/g)) {
        versionWarning = yo`<small title="Version Alpha" class="badge-light ${css.versionBadge}">alpha</small>`;
      } // Beta


      if (profile.version && profile.version.match(/\b(\w*beta\w*)\b/g)) {
        versionWarning = yo`<small title="Version Beta" class="badge-light ${css.versionBadge}">beta</small>`;
      }
    }

    const header = yo`
      <header class="${css.swapitHeader}">
        <h6 class="${css.swapitTitle}" data-id="sidePanelSwapitTitle">${name}</h6>
        ${docLink}
        ${versionWarning}
      </header>
    `;
    yo.update(this.header, header);
  }

  render() {
    return yo`
      <section class="${css.panel} plugin-manager">
        ${this.header}
        <div class="${css.pluginsContainer}">
          ${this.view}
        </div>
      </section>`;
  }

}

exports.SidePanel = SidePanel;

/***/ }),

/***/ "./app/components/vertical-icons.js":
/*!******************************************!*\
  !*** ./app/components/vertical-icons.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerticalIcons = void 0;

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _svgLogo = __webpack_require__(/*! ../ui/svgLogo */ "./app/ui/svgLogo.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var helper = __webpack_require__(/*! ../../lib/helper */ "./lib/helper.js");

let globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

const {
  Plugin
} = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

const EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

const profile = {
  name: 'menuicons',
  displayName: 'Vertical Icons',
  description: '',
  version: packageJson.version,
  methods: ['select']
}; // TODO merge with side-panel.js. VerticalIcons should not be a plugin

class VerticalIcons extends Plugin {
  constructor(appManager) {
    super(profile);
    this.events = new EventEmitter();
    this.appManager = appManager;
    this.icons = {};
    this.iconKind = {};
    this.iconStatus = {};
    let themeModule = globalRegistry.get('themeModule').api;
    themeModule.events.on('themeChanged', theme => {
      this.onThemeChanged(theme.quality);
    });
  }

  linkContent(profile) {
    if (!profile.icon) return;
    this.addIcon(profile);
    this.listenOnStatus(profile);
  }

  unlinkContent(profile) {
    this.removeIcon(profile);
  }

  listenOnStatus(profile) {
    // the list of supported keys. 'none' will remove the status
    const keys = ['edited', 'succeed', 'none', 'loading', 'failed'];
    const types = ['error', 'warning', 'success', 'info', ''];

    const fn = status => {
      if (!types.includes(status.type) && status.type) throw new Error(`type should be ${keys.join()}`);
      if (status.key === undefined) throw new Error(`status key should be defined`);

      if (typeof status.key === 'string' && !keys.includes(status.key)) {
        throw new Error('key should contain either number or ' + keys.join());
      }

      this.setIconStatus(profile.name, status);
    };

    this.iconStatus[profile.name] = fn;
    this.on(profile.name, 'statusChanged', this.iconStatus[profile.name]);
  }
  /**
   * Add an icon to the map
   * @param {ModuleProfile} profile The profile of the module
   */


  addIcon({
    kind,
    name,
    icon,
    displayName,
    tooltip
  }) {
    let title = tooltip || displayName || name;
    title = title.replace(/^\w/, c => c.toUpperCase());
    this.icons[name] = yo`
      <div
        class="${css.icon}"
        onclick="${() => {
      this.toggle(name);
    }}"
        plugin="${name}"
        title="${title}"
        data-id="verticalIconsKind${name}">
        <img class="image" src="${icon}" alt="${name}" />
      </div>`;
    this.iconKind[kind || 'none'].appendChild(this.icons[name]);
  }
  /**
   * resolve a classes list for @arg key
   * @param {Object} key
   * @param {Object} type
   */


  resolveClasses(key, type) {
    let classes = css.status;

    switch (key) {
      case 'succeed':
        classes += ' fas fa-check-circle text-' + type + ' ' + css.statusCheck;
        break;

      case 'edited':
        classes += ' fas fa-sync text-' + type + ' ' + css.statusCheck;
        break;

      case 'loading':
        classes += ' fas fa-spinner text-' + type + ' ' + css.statusCheck;
        break;

      case 'failed':
        classes += ' fas fa-exclamation-triangle text-' + type + ' ' + css.statusCheck;
        break;

      default:
        {
          classes += ' badge badge-pill badge-' + type;
        }
    }

    return classes;
  }
  /**
   * Set a new status for the @arg name
   * @param {String} name
   * @param {Object} status
   */


  setIconStatus(name, status) {
    const el = this.icons[name];
    if (!el) return;
    let statusEl = el.querySelector('span');

    if (statusEl) {
      el.removeChild(statusEl);
    }

    if (status.key === 'none') return; // remove status

    let text = '';
    let key = '';

    if (typeof status.key === 'number') {
      key = status.key.toString();
      text = key;
    } else key = helper.checkSpecialChars(status.key) ? '' : status.key;

    let type = '';

    if (status.type === 'error') {
      type = 'danger'; // to use with bootstrap
    } else type = helper.checkSpecialChars(status.type) ? '' : status.type;

    let title = helper.checkSpecialChars(status.title) ? '' : status.title;
    el.appendChild(yo`<span
      title="${title}"
      class="${this.resolveClasses(key, type)}"
      aria-hidden="true"
    >
    ${text}
    </span>`);
    el.classList.add(`${css.icon}`);
  }
  /**
   * Remove an icon from the map
   * @param {ModuleProfile} profile The profile of the module
   */


  removeIcon({
    kind,
    name
  }) {
    if (this.icons[name]) this.iconKind[kind || 'none'].removeChild(this.icons[name]);
  }
  /**
   *  Remove active for the current activated icons
   */


  removeActive() {
    // reset filters
    const images = this.view.querySelectorAll(`.image`);
    images.forEach(function (im) {
      im.style.setProperty('filter', 'invert(0.5)');
    }); // remove active

    const currentActive = this.view.querySelector(`.active`);

    if (currentActive) {
      currentActive.classList.remove(`active`);
    }
  }
  /**
   *  Add active for the new activated icon
   * @param {string} name Name of profile of the module to activate
   */


  addActive(name) {
    if (name === 'home') return;
    const themeType = globalRegistry.get('themeModule').api.currentTheme().quality;
    const invert = themeType === 'dark' ? 1 : 0;
    const brightness = themeType === 'dark' ? '150' : '0'; // should be >100 for icons with color

    const nextActive = this.view.querySelector(`[plugin="${name}"]`);

    if (nextActive) {
      let image = nextActive.querySelector('.image');
      nextActive.classList.add(`active`);
      image.style.setProperty('filter', `invert(${invert}) grayscale(1) brightness(${brightness}%)`);
    }
  }
  /**
   * Set an icon as active
   * @param {string} name Name of profile of the module to activate
   */


  select(name) {
    this.updateActivations(name); // TODO: Only keep `this.emit` (issue#2210)

    this.emit('showContent', name);
    this.events.emit('showContent', name);
  }
  /**
   * Toggles the side panel for plugin
   * @param {string} name Name of profile of the module to activate
   */


  toggle(name) {
    this.updateActivations(name); // TODO: Only keep `this.emit` (issue#2210)

    this.emit('toggleContent', name);
    this.events.emit('toggleContent', name);
  }

  updateActivations(name) {
    this.removeActive();
    this.addActive(name);
  }

  onThemeChanged(themeType) {
    const invert = themeType === 'dark' ? 1 : 0;
    const active = this.view.querySelector(`.active`);

    if (active) {
      let image = active.querySelector('.image');
      image.style.setProperty('filter', `invert(${invert})`);
    }
  }

  render() {
    let home = yo`
      <div
        class="${css.homeIcon}"
        onclick="${e => {
      this.appManager.ensureActivated('home');
    }}"
        plugin="home" title="Home"
        data-id="verticalIconsHomeIcon"
      >
        ${(0, _svgLogo.basicLogo)()}
      </div>
    `;
    this.iconKind['fileexplorer'] = yo`<div id='fileExplorerIcons' data-id="verticalIconsFileExplorerIcons"></div>`;
    this.iconKind['compiler'] = yo`<div id='compileIcons'></div>`;
    this.iconKind['udapp'] = yo`<div id='runIcons'></div>`;
    this.iconKind['testing'] = yo`<div id='testingIcons'></div>`;
    this.iconKind['analysis'] = yo`<div id='analysisIcons'></div>`;
    this.iconKind['debugging'] = yo`<div id='debuggingIcons' data-id="verticalIconsDebuggingIcons"></div>`;
    this.iconKind['none'] = yo`<div id='otherIcons'></div>`;
    this.iconKind['settings'] = yo`<div id='settingsIcons' data-id="verticalIconsSettingsIcons"></div>`;
    this.view = yo`
      <div class=${css.icons}>
        ${home}
        ${this.iconKind['fileexplorer']}
        ${this.iconKind['compiler']}
        ${this.iconKind['udapp']}
        ${this.iconKind['testing']}
        ${this.iconKind['analysis']}
        ${this.iconKind['debugging']}
        ${this.iconKind['none']}
        ${this.iconKind['settings']}
      </div>
    `;
    return this.view;
  }

}

exports.VerticalIcons = VerticalIcons;
const css = csjs`
  .homeIcon {
      display: block;
      width: 42px;
      height: 42px;
      margin-bottom: 20px;
      margin-left: -5px;
      cursor: pointer;
  }
  .homeIcon svg path {
    fill: var(--primary);
  }
  .homeIcon svg polygon {
    fill: var(--primary);
  }
  .icons {
    margin-left: 10px;
    margin-top: 15px;
  }
  .icon {
    cursor: pointer;
    margin-bottom: 12px;
    width: 36px;
    height: 36px;
    padding: 3px;
    position: relative;
    border-radius: 8px;
  }
  .icon img {
    width: 28px;
    height: 28px;
    padding: 4px;
    filter: invert(0.5);
  }
  .image {
  }
  .icon svg {
    width: 28px;
    height: 28px;
    padding: 4px;
  }
  .icon[title='Settings'] {
    position: absolute;
    bottom: 0;
  }
  .status {
    position: absolute;
    bottom: 0;
    right: 0;
  }
  .statusCheck {
    font-size: 1.2em;
  }
  .statusWithBG
    border-radius: 8px;
    background-color: var(--danger);
    color: var(--light);
    font-size: 12px;
    height: 15px;
    text-align: center;
    font-weight: bold;
    padding-left: 5px;
    padding-right: 5px;
  }
`;

/***/ }),

/***/ "./app/editor/SourceHighlighters.js":
/*!******************************************!*\
  !*** ./app/editor/SourceHighlighters.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const SourceHighlighter = __webpack_require__(/*! ./sourceHighlighter */ "./app/editor/sourceHighlighter.js"); // EditorApi:
// - methods: ['highlight', 'discardHighlight'],


class SourceHighlighters {
  constructor() {
    this.highlighters = {};
  }

  highlight(position, filePath, hexColor, from) {
    try {
      if (!this.highlighters[from]) this.highlighters[from] = [];
      const sourceHighlight = new SourceHighlighter();

      if (!this.highlighters[from].length || this.highlighters[from].length && !this.highlighters[from].find(el => {
        return el.source === filePath && el.position === position;
      })) {
        sourceHighlight.currentSourceLocationFromfileName(position, filePath, hexColor);
        this.highlighters[from].push(sourceHighlight);
      }
    } catch (e) {
      throw e;
    }
  }

  discardHighlight(from) {
    if (this.highlighters[from]) {
      for (const index in this.highlighters[from]) this.highlighters[from][index].currentSourceLocation(null);
    }

    this.highlighters[from] = [];
  }

  discardHighlightAt(line, filePath, from) {
    if (this.highlighters[from]) {
      for (const index in this.highlighters[from]) {
        const highlight = this.highlighters[from][index];

        if (highlight.source === filePath && (highlight.position.start.line === line || highlight.position.end.line === line)) {
          highlight.currentSourceLocation(null);
          this.highlighters[from].splice(index, 1);
        }
      }
    }
  }

}

module.exports = SourceHighlighters;

/***/ }),

/***/ "./app/editor/contextView.js":
/*!***********************************!*\
  !*** ./app/editor/contextView.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const SourceMappingDecoder = remixLib.SourceMappingDecoder;

const globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

const css = __webpack_require__(/*! ./styles/contextView-styles */ "./app/editor/styles/contextView-styles.js");
/*
  Display information about the current focused code:
   - if it's a reference, display information about the declaration
   - jump to the declaration
   - number of references
   - rename declaration/references
*/


class ContextView {
  constructor(opts, localRegistry) {
    this._components = {};
    this._components.registry = localRegistry || globalRegistry;
    this.contextualListener = opts.contextualListener;
    this.editor = opts.editor;
    this._deps = {
      compilersArtefacts: this._components.registry.get('compilersartefacts').api,
      offsetToLineColumnConverter: this._components.registry.get('offsettolinecolumnconverter').api,
      config: this._components.registry.get('config').api,
      fileManager: this._components.registry.get('filemanager').api
    };
    this._view;
    this._nodes;
    this._current;
    this.sourceMappingDecoder = new SourceMappingDecoder();
    this.previousElement = null;
    this.contextualListener.event.register('contextChanged', nodes => {
      this.show();
      this._nodes = nodes;
      this.update();
    });
    this.contextualListener.event.register('stopHighlighting', () => {});
  }

  render() {
    const view = yo`
      <div class="${css.contextview} ${css.contextviewcontainer} bg-light text-dark border-0">
        <div class=${css.container}>
          ${this._renderTarget()}
        </div>
      </div>`;

    if (!this._view) {
      this._view = view;
    }

    return view;
  }

  hide() {
    if (this._view) {
      this._view.style.display = 'none';
    }
  }

  show() {
    if (this._view) {
      this._view.style.display = 'block';
    }
  }

  update() {
    if (this._view) {
      yo.update(this._view, this.render());
    }
  }

  _renderTarget() {
    let last;
    const previous = this._current;

    if (this._nodes && this._nodes.length) {
      last = this._nodes[this._nodes.length - 1];

      if (isDefinition(last)) {
        this._current = last;
      } else {
        const target = this.contextualListener.declarationOf(last);

        if (target) {
          this._current = target;
        } else {
          this._current = null;
        }
      }
    }

    if (!this._current || !previous || previous.id !== this._current.id) {
      this.previousElement = this._render(this._current, last);
    }

    return this.previousElement;
  }

  _jumpToInternal(position) {
    const jumpToLine = lineColumn => {
      if (lineColumn.start && lineColumn.start.line && lineColumn.start.column) {
        this.editor.gotoLine(lineColumn.start.line, lineColumn.end.column + 1);
      }
    };

    let lastCompilationResult = this._deps.compilersArtefacts['__last'];

    if (lastCompilationResult && lastCompilationResult.languageversion.indexOf('soljson') === 0 && lastCompilationResult.data) {
      const lineColumn = this._deps.offsetToLineColumnConverter.offsetToLineColumn(position, position.file, lastCompilationResult.getSourceCode().sources, lastCompilationResult.getAsts());

      const filename = lastCompilationResult.getSourceName(position.file); // TODO: refactor with rendererAPI.errorClick

      if (filename !== this._deps.config.get('currentFile')) {
        const provider = this._deps.fileManager.fileProviderOf(filename);

        if (provider) {
          provider.exists(filename, (error, exist) => {
            if (error) return console.log(error);

            this._deps.fileManager.open(filename);

            jumpToLine(lineColumn);
          });
        }
      } else {
        jumpToLine(lineColumn);
      }
    }
  }

  _render(node, nodeAtCursorPosition) {
    if (!node) return yo`<div></div>`;
    let references = this.contextualListener.referencesOf(node);
    const type = node.attributes && node.attributes.type ? node.attributes.type : node.name;
    references = `${references ? references.length : '0'} reference(s)`;
    let ref = 0;
    const nodes = this.contextualListener.getActiveHighlights();

    for (const k in nodes) {
      if (nodeAtCursorPosition.id === nodes[k].nodeId) {
        ref = k;
        break;
      }
    } // JUMP BETWEEN REFERENCES


    const jump = e => {
      e.target.dataset.action === 'next' ? ref++ : ref--;
      if (ref < 0) ref = nodes.length - 1;
      if (ref >= nodes.length) ref = 0;

      this._jumpToInternal(nodes[ref].position);
    };

    const jumpTo = () => {
      if (node && node.src) {
        const position = this.sourceMappingDecoder.decode(node.src);

        if (position) {
          this._jumpToInternal(position);
        }
      }
    };

    const showGasEstimation = () => {
      if (node.name === 'FunctionDefinition') {
        const result = this.contextualListener.gasEstimation(node);
        const executionCost = ' Execution cost: ' + result.executionCost + ' gas';
        const codeDepositCost = 'Code deposit cost: ' + result.codeDepositCost + ' gas';
        const estimatedGas = result.codeDepositCost ? `${codeDepositCost}, ${executionCost}` : `${executionCost}`;
        return yo`
          <div class=${css.gasEstimation}>
            <i class="fas fa-gas-pump ${css.gasStationIcon}" title='Gas estimation'></i>
            <span>${estimatedGas}</span>
          </div>
        `;
      }
    };

    return yo`
      <div class=${css.line}>${showGasEstimation()}
        <div title=${type} class=${css.type}>${type}</div>
        <div title=${node.attributes.name} class=${css.name}>${node.attributes.name}</div>
        <i class="fas fa-share ${css.jump}" aria-hidden="true" onclick=${jumpTo}></i>
        <span class=${css.referencesnb}>${references}</span>
        <i data-action='previous' class="fas fa-chevron-up ${css.jump}" aria-hidden="true" onclick=${jump}></i>
        <i data-action='next' class="fas fa-chevron-down ${css.jump}" aria-hidden="true" onclick=${jump}></i>
      </div>
    `;
  }

}

function isDefinition(node) {
  return node.name === 'ContractDefinition' || node.name === 'FunctionDefinition' || node.name === 'ModifierDefinition' || node.name === 'VariableDeclaration' || node.name === 'StructDefinition' || node.name === 'EventDefinition';
}

module.exports = ContextView;

/***/ }),

/***/ "./app/editor/contextualListener.js":
/*!******************************************!*\
  !*** ./app/editor/contextualListener.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const SourceMappingDecoder = remixLib.SourceMappingDecoder;
const AstWalker = remixLib.AstWalker;

const EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

const globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

const profile = {
  name: 'contextualListener',
  methods: [],
  events: [],
  version: packageJson.version
};
/*
  trigger contextChanged(nodes)
*/

class ContextualListener extends _engine.Plugin {
  constructor(opts) {
    super(profile);
    this.event = new EventManager();
    this._components = {};
    this._components.registry = globalRegistry;
    this.editor = opts.editor;
    this.pluginManager = opts.pluginManager;
    this._deps = {
      compilersArtefacts: this._components.registry.get('compilersartefacts').api,
      config: this._components.registry.get('config').api,
      offsetToLineColumnConverter: this._components.registry.get('offsettolinecolumnconverter').api
    };
    this._index = {
      Declarations: {},
      FlatReferences: {}
    };
    this._activeHighlights = [];
    this.editor.event.register('contentChanged', () => {
      this._stopHighlighting();
    });
    this.sourceMappingDecoder = new SourceMappingDecoder();
    this.astWalker = new AstWalker();
  }

  onActivation() {
    this.on('solidity', 'compilationFinished', (file, source, languageVersion, data) => {
      if (languageVersion.indexOf('soljson') !== 0) return;

      this._stopHighlighting();

      this._index = {
        Declarations: {},
        FlatReferences: {}
      };

      this._buildIndex(data, source);
    });
    setInterval(() => {
      if (this._deps.compilersArtefacts['__last'] && this._deps.compilersArtefacts['__last'].languageversion.indexOf('soljson') === 0) {
        this._highlightItems(this.editor.getCursorPosition(), this._deps.compilersArtefacts['__last'], this._deps.config.get('currentFile'));
      }
    }, 1000);
  }

  getActiveHighlights() {
    return [...this._activeHighlights];
  }

  declarationOf(node) {
    if (node.attributes && node.attributes.referencedDeclaration) {
      return this._index['FlatReferences'][node.attributes.referencedDeclaration];
    }

    return null;
  }

  referencesOf(node) {
    return this._index['Declarations'][node.id];
  }

  _highlightItems(cursorPosition, compilationResult, file) {
    if (this.currentPosition === cursorPosition) return;

    if (this.currentFile !== file) {
      this.currentFile = file;
      this.currentPosition = cursorPosition;
      return;
    }

    this._stopHighlighting();

    this.currentPosition = cursorPosition;
    this.currentFile = file;

    if (compilationResult && compilationResult.data && compilationResult.data.sources[file]) {
      const nodes = this.sourceMappingDecoder.nodesAtPosition(null, cursorPosition, compilationResult.data.sources[file]);
      this.nodes = nodes;

      if (nodes && nodes.length && nodes[nodes.length - 1]) {
        this._highlightExpressions(nodes[nodes.length - 1], compilationResult);
      }

      this.event.trigger('contextChanged', [nodes]);
    }
  }

  _buildIndex(compilationResult, source) {
    if (compilationResult && compilationResult.sources) {
      const callback = {};

      callback['*'] = node => {
        if (node && node.attributes && node.attributes.referencedDeclaration) {
          if (!this._index['Declarations'][node.attributes.referencedDeclaration]) {
            this._index['Declarations'][node.attributes.referencedDeclaration] = [];
          }

          this._index['Declarations'][node.attributes.referencedDeclaration].push(node);
        }

        this._index['FlatReferences'][node.id] = node;
        return true;
      };

      for (const s in compilationResult.sources) {
        this.astWalker.walk(compilationResult.sources[s].legacyAST, callback);
      }
    }
  }

  _highlight(node, compilationResult) {
    if (!node) return;
    const position = this.sourceMappingDecoder.decode(node.src);

    const eventId = this._highlightInternal(position, node);

    let lastCompilationResult = this._deps.compilersArtefacts['__last'];

    if (eventId && lastCompilationResult && lastCompilationResult.languageversion.indexOf('soljson') === 0) {
      this._activeHighlights.push({
        eventId,
        position,
        fileTarget: lastCompilationResult.getSourceName(position.file),
        nodeId: node.id
      });
    }
  }

  _highlightInternal(position, node) {
    let lastCompilationResult = this._deps.compilersArtefacts['__last'];

    if (lastCompilationResult && lastCompilationResult.languageversion.indexOf('soljson') === 0) {
      let lineColumn = this._deps.offsetToLineColumnConverter.offsetToLineColumn(position, position.file, lastCompilationResult.getSourceCode().sources, lastCompilationResult.getAsts());

      const css = csjs`
        .highlightref_fullLine {
          position:absolute;
          z-index:2;
          opacity: 0.4;
          background-color: var(--info);
        }
        `;

      if (node.children && node.children.length) {
        // If node has children, highlight the entire line. if not, just highlight the current source position of the node.
        lineColumn = {
          start: {
            line: lineColumn.start.line,
            column: 0
          },
          end: {
            line: lineColumn.start.line + 1,
            column: 0
          }
        };
      }

      const fileName = lastCompilationResult.getSourceName(position.file);

      if (fileName) {
        return this.editor.addMarker(lineColumn, fileName, css.highlightref_fullLine);
      }
    }

    return null;
  }

  _highlightExpressions(node, compilationResult) {
    const highlights = id => {
      if (this._index['Declarations'] && this._index['Declarations'][id]) {
        const refs = this._index['Declarations'][id];

        for (const ref in refs) {
          const node = refs[ref];

          this._highlight(node, compilationResult);
        }
      }
    };

    if (node.attributes && node.attributes.referencedDeclaration) {
      highlights(node.attributes.referencedDeclaration);
      const current = this._index['FlatReferences'][node.attributes.referencedDeclaration];

      this._highlight(current, compilationResult);
    } else {
      highlights(node.id);

      this._highlight(node, compilationResult);
    }

    this.results = compilationResult;
  }

  _stopHighlighting() {
    for (const eventKey in this._activeHighlights) {
      const event = this._activeHighlights[eventKey];
      this.editor.removeMarker(event.eventId, event.fileTarget);
    }

    this.event.trigger('stopHighlighting', []);
    this._activeHighlights = [];
  }

  gasEstimation(node) {
    this._loadContractInfos(node);

    let executionCost, codeDepositCost;

    if (node.name === 'FunctionDefinition') {
      const visibility = node.attributes.visibility;

      if (!node.attributes.isConstructor) {
        const fnName = node.attributes.name;

        const fn = fnName + this._getInputParams(node);

        if (visibility === 'public' || visibility === 'external') {
          executionCost = this.estimationObj.external[fn];
        } else if (visibility === 'private' || visibility === 'internal') {
          executionCost = this.estimationObj.internal[fn];
        }
      } else {
        executionCost = this.creationCost;
        codeDepositCost = this.codeDepositCost;
      }
    } else {
      executionCost = '-';
    }

    return {
      executionCost,
      codeDepositCost
    };
  }

  _loadContractInfos(node) {
    for (const i in this.nodes) {
      if (this.nodes[i].id === node.attributes.scope) {
        const contract = this.nodes[i];
        this.contract = this.results.data.contracts[this.results.source.target][contract.attributes.name];
        this.estimationObj = this.contract.evm.gasEstimates;
        this.creationCost = this.estimationObj.creation.totalCost;
        this.codeDepositCost = this.estimationObj.creation.codeDepositCost;
      }
    }
  }

  _getInputParams(node) {
    const params = [];
    let target;

    for (const i in node.children) {
      if (node.children[i].name === 'ParameterList') {
        target = node.children[i];
        break;
      }
    }

    if (target) {
      const children = target.children;

      for (const j in children) {
        if (children[j].name === 'VariableDeclaration') {
          params.push(children[j].attributes.type);
        }
      }
    }

    return '(' + params.toString() + ')';
  }

}

module.exports = ContextualListener;

/***/ }),

/***/ "./app/editor/editor.js":
/*!******************************!*\
  !*** ./app/editor/editor.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const ace = __webpack_require__(/*! brace */ "../../../node_modules/brace/index.js");

const globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

const SourceHighlighters = __webpack_require__(/*! ./SourceHighlighters */ "./app/editor/SourceHighlighters.js");

const Range = ace.acequire('ace/range').Range;

__webpack_require__(/*! brace/ext/language_tools */ "../../../node_modules/brace/ext/language_tools.js");

__webpack_require__(/*! brace/ext/searchbox */ "../../../node_modules/brace/ext/searchbox.js");

const langTools = ace.acequire('ace/ext/language_tools');

__webpack_require__(/*! ace-mode-solidity/build/remix-ide/mode-solidity */ "../../../node_modules/ace-mode-solidity/build/remix-ide/mode-solidity.js");

__webpack_require__(/*! ace-mode-move/build/remix-ide/mode-move */ "../../../node_modules/ace-mode-move/build/remix-ide/mode-move.js");

__webpack_require__(/*! ace-mode-zokrates */ "../../../node_modules/ace-mode-zokrates/index.js");

__webpack_require__(/*! brace/mode/javascript */ "../../../node_modules/brace/mode/javascript.js");

__webpack_require__(/*! brace/mode/python */ "../../../node_modules/brace/mode/python.js");

__webpack_require__(/*! brace/mode/json */ "../../../node_modules/brace/mode/json.js");

__webpack_require__(/*! brace/mode/rust */ "../../../node_modules/brace/mode/rust.js");

__webpack_require__(/*! brace/theme/chrome */ "../../../node_modules/brace/theme/chrome.js"); // for all light themes


__webpack_require__(/*! brace/theme/chaos */ "../../../node_modules/brace/theme/chaos.js"); // for all dark themes


__webpack_require__(/*! ../../assets/js/editor/darkTheme */ "./assets/js/editor/darkTheme.js"); // a custom one for remix 'Dark' theme


const css = csjs`
  .ace-editor {
    width     : 100%;
  }
`;
document.head.appendChild(yo`
  <style>
    .ace-tm .ace_gutter,
    .ace-tm .ace_gutter-active-line,
    .ace-tm .ace_marker-layer .ace_active-line {
        background-color: var(--secondary);
    }
    .ace_gutter-cell.ace_breakpoint{
      background-color: var(--secondary);
    }
  </style>
`);
const profile = {
  displayName: 'Editor',
  name: 'editor',
  description: 'service - editor',
  version: packageJson.version,
  methods: ['highlight', 'discardHighlight', 'discardHighlightAt', 'clearAnnotations', 'addAnnotation']
};

class Editor extends _engine.Plugin {
  constructor(opts = {}, themeModule) {
    super(profile); // Dependancies

    this._components = {};
    this._components.registry = globalRegistry;
    this._deps = {
      config: this._components.registry.get('config').api
    };
    this._themes = {
      'light': 'chrome',
      'dark': 'chaos',
      'remixDark': 'remixDark'
    };
    themeModule.events.on('themeChanged', theme => {
      this.setTheme(theme.name === 'Dark' ? 'remixDark' : theme.quality);
    }); // Init

    this.event = new EventManager();
    this.sessions = {};
    this.sourceAnnotations = [];
    this.readOnlySessions = {};
    this.previousInput = '';
    this.saveTimeout = null;
    this.sourceHighlighters = new SourceHighlighters();
    this.emptySession = this._createSession('');
    this.modes = {
      sol: 'ace/mode/solidity',
      yul: 'ace/mode/solidity',
      mvir: 'ace/mode/move',
      js: 'ace/mode/javascript',
      py: 'ace/mode/python',
      vy: 'ace/mode/python',
      zok: 'ace/mode/zokrates',
      txt: 'ace/mode/text',
      json: 'ace/mode/json',
      abi: 'ace/mode/json',
      rs: 'ace/mode/rust'
    }; // Editor Setup

    const el = yo`<div id="input" data-id="editorInput"></div>`;
    this.editor = ace.edit(el);
    ace.acequire('ace/ext/language_tools'); // Unmap ctrl-l & cmd-l

    this.editor.commands.bindKeys({
      'ctrl-L': null,
      'Command-L': null
    }); // shortcuts for "Ctrl-"" and "Ctrl+"" to increase/decrease font size of the editor

    this.editor.commands.addCommand({
      name: 'increasefontsizeEqual',
      bindKey: {
        win: 'Ctrl-=',
        mac: 'Command-='
      },
      exec: editor => {
        this.editorFontSize(1);
      },
      readOnly: true
    });
    this.editor.commands.addCommand({
      name: 'increasefontsizePlus',
      bindKey: {
        win: 'Ctrl-+',
        mac: 'Command-+'
      },
      exec: editor => {
        this.editorFontSize(1);
      },
      readOnly: true
    });
    this.editor.commands.addCommand({
      name: 'decreasefontsize',
      bindKey: {
        win: 'Ctrl--',
        mac: 'Command--'
      },
      exec: editor => {
        this.editorFontSize(-1);
      },
      readOnly: true
    });
    this.editor.setShowPrintMargin(false);
    this.editor.resize(true);
    this.editor.setOptions({
      enableBasicAutocompletion: true,
      enableLiveAutocompletion: true
    });
    el.className += ' ' + css['ace-editor'];
    el.editor = this.editor; // required to access the editor during tests

    this.render = () => el; // Completer for editor


    const flowCompleter = {
      getCompletions: (editor, session, pos, prefix, callback) => {// @TODO add here other propositions
      }
    };
    langTools.addCompleter(flowCompleter); // zoom with Ctrl+wheel

    window.addEventListener('wheel', e => {
      if (e.ctrlKey && Math.abs(e.wheelY) > 5) {
        this.editorFontSize(e.wheelY > 0 ? 1 : -1);
      }
    }); // EVENTS LISTENERS
    // Gutter Mouse down

    this.editor.on('guttermousedown', e => {
      const target = e.domEvent.target;

      if (target.className.indexOf('ace_gutter-cell') === -1) {
        return;
      }

      const row = e.getDocumentPosition().row;
      const breakpoints = e.editor.session.getBreakpoints();

      for (const k in breakpoints) {
        if (k === row.toString()) {
          this.event.trigger('breakpointCleared', [this.currentSession, row]);
          e.editor.session.clearBreakpoint(row);
          e.stop();
          return;
        }
      }

      this.setBreakpoint(row);
      this.event.trigger('breakpointAdded', [this.currentSession, row]);
      e.stop();
    }); // Do setup on initialisation here

    this.editor.on('changeSession', () => {
      this._onChange();

      this.event.trigger('sessionSwitched', []);
      this.editor.getSession().on('change', () => {
        this._onChange();

        this.event.trigger('contentChanged', []);
      });
    });
  }

  highlight(position, filePath, hexColor) {
    const {
      from
    } = this.currentRequest;
    this.sourceHighlighters.highlight(position, filePath, hexColor, from);
  }

  discardHighlight() {
    const {
      from
    } = this.currentRequest;
    this.sourceHighlighters.discardHighlight(from);
  }

  discardHighlightAt(line, filePath) {
    const {
      from
    } = this.currentRequest;
    this.sourceHighlighters.discardHighlightAt(line, filePath, from);
  }

  setTheme(type) {
    this.editor.setTheme('ace/theme/' + this._themes[type]);
  }

  _onChange() {
    const currentFile = this._deps.config.get('currentFile');

    if (!currentFile) {
      return;
    }

    const input = this.get(currentFile);

    if (!input) {
      return;
    } // if there's no change, don't do anything


    if (input === this.previousInput) {
      return;
    }

    this.previousInput = input; // fire storage update
    // NOTE: save at most once per 5 seconds

    if (this.saveTimeout) {
      window.clearTimeout(this.saveTimeout);
    }

    this.saveTimeout = window.setTimeout(() => {
      this.event.trigger('requiringToSaveCurrentfile', []);
    }, 5000);
  }

  _switchSession(path) {
    this.currentSession = path;
    this.editor.setSession(this.sessions[this.currentSession]);
    this.editor.setReadOnly(this.readOnlySessions[this.currentSession]);
    this.editor.focus();
  }
  /**
   * Get Ace mode base of the extension of the session file
   * @param {string} path Path of the file
   */


  _getMode(path) {
    if (!path) return this.modes['txt'];
    const root = path.split('#')[0].split('?')[0];
    let ext = root.indexOf('.') !== -1 ? /[^.]+$/.exec(root) : null;
    if (ext) ext = ext[0];else ext = 'txt';
    return ext && this.modes[ext] ? this.modes[ext] : this.modes['txt'];
  }
  /**
   * Create an Ace session
   * @param {string} content Content of the file to open
   * @param {string} mode Ace Mode for this file [Default is `text`]
   */


  _createSession(content, mode) {
    const s = new ace.EditSession(content);
    s.setMode(mode || 'ace/mode/text');
    s.setUndoManager(new ace.UndoManager());
    s.setTabSize(4);
    s.setUseSoftTabs(true);
    return s;
  }
  /**
   * Attempts to find the string in the current document
   * @param {string} string
   */


  find(string) {
    return this.editor.find(string);
  }
  /**
   * Display an Empty read-only session
   */


  displayEmptyReadOnlySession() {
    this.currentSession = null;
    this.editor.setSession(this.emptySession);
    this.editor.setReadOnly(true);
  }
  /**
   * Sets a breakpoint on the row number
   * @param {number} row Line index of the breakpoint
   * @param {string} className Class of the breakpoint
   */


  setBreakpoint(row, className) {
    this.editor.session.setBreakpoint(row, className);
  }
  /**
   * Increment the font size (in pixels) for the editor text.
   * @param {number} incr The amount of pixels to add to the font.
   */


  editorFontSize(incr) {
    let newSize = this.editor.getFontSize() + incr;

    if (newSize >= 6) {
      this.editor.setFontSize(newSize);
    }
  }
  /**
   * Set the text in the current session, if any.
   * @param {string} text New text to be place.
   */


  setText(text) {
    if (this.currentSession && this.sessions[this.currentSession]) {
      this.sessions[this.currentSession].setValue(text);
    }
  }
  /**
   * Upsert and open a session.
   * @param {string} path Path of the session to open.
   * @param {string} content Content of the document or update.
   */


  open(path, content) {
    /*
      we have the following cases:
       - URL prepended with "localhost"
       - URL prepended with "browser"
       - URL not prepended with the file explorer. We assume (as it is in the whole app, that this is a "browser" URL
    */
    if (!path.startsWith('localhost') && !path.startsWith('browser')) path = `browser/${path}`;

    if (!this.sessions[path]) {
      const session = this._createSession(content, this._getMode(path));

      this.sessions[path] = session;
      this.readOnlySessions[path] = false;
    } else if (this.sessions[path].getValue() !== content) {
      this.sessions[path].setValue(content);
    }

    this._switchSession(path);
  }
  /**
   * Upsert and Open a session and set it as Read-only.
   * @param {string} path Path of the session to open.
   * @param {string} content Content of the document or update.
   */


  openReadOnly(path, content) {
    if (!this.sessions[path]) {
      const session = this._createSession(content, this._getMode(path));

      this.sessions[path] = session;
      this.readOnlySessions[path] = true;
    }

    this._switchSession(path);
  }
  /**
   * Content of the current session
   * @return {String} content of the file referenced by @arg path
   */


  currentContent() {
    return this.get(this.current());
  }
  /**
   * Content of the session targeted by @arg path
   * if @arg path is null, the content of the current session is returned
   * @param {string} path Path of the session to get.
   * @return {String} content of the file referenced by @arg path
   */


  get(path) {
    if (!path || this.currentSession === path) {
      return this.editor.getValue();
    } else if (this.sessions[path]) {
      return this.sessions[path].getValue();
    }
  }
  /**
   * Path of the currently editing file
   * returns `undefined` if no session is being editer
   * @return {String} path of the current session
   */


  current() {
    if (this.editor.getSession() === this.emptySession) {
      return;
    }

    return this.currentSession;
  }
  /**
   * The position of the cursor
   */


  getCursorPosition() {
    return this.editor.session.doc.positionToIndex(this.editor.getCursorPosition(), 0);
  }
  /**
   * Remove the current session from the list of sessions.
   */


  discardCurrentSession() {
    if (this.sessions[this.currentSession]) {
      delete this.sessions[this.currentSession];
      this.currentSession = null;
    }
  }
  /**
   * Remove a session based on its path.
   * @param {string} path
   */


  discard(path) {
    if (this.sessions[path]) delete this.sessions[path];
    if (this.currentSession === path) this.currentSession = null;
  }
  /**
   * Resize the editor, and sets whether or not line wrapping is enabled.
   * @param {boolean} useWrapMode Enable (or disable) wrap mode
   */


  resize(useWrapMode) {
    this.editor.resize();
    const session = this.editor.getSession();
    session.setUseWrapMode(useWrapMode);

    if (session.getUseWrapMode()) {
      const characterWidth = this.editor.renderer.characterWidth;
      const contentWidth = this.editor.container.ownerDocument.getElementsByClassName('ace_scroller')[0].clientWidth;

      if (contentWidth > 0) {
        session.setWrapLimit(parseInt(contentWidth / characterWidth, 10));
      }
    }
  }
  /**
   * Adds a new marker to the given `Range`.
   * @param {*} lineColumnPos
   * @param {string} source Path of the session to add the mark on.
   * @param {string} cssClass css to apply to the mark.
   */


  addMarker(lineColumnPos, source, cssClass) {
    const currentRange = new Range(lineColumnPos.start.line, lineColumnPos.start.column, lineColumnPos.end.line, lineColumnPos.end.column);

    if (this.sessions[source]) {
      return this.sessions[source].addMarker(currentRange, cssClass);
    }

    return null;
  }
  /**
   * Scrolls to a line. If center is true, it puts the line in middle of screen (or attempts to).
   * @param {number} line The line to scroll to
   * @param {boolean} center If true
   * @param {boolean} animate If true animates scrolling
   * @param {Function} callback Function to be called when the animation has finished
   */


  scrollToLine(line, center, animate, callback) {
    this.editor.scrollToLine(line, center, animate, callback);
  }
  /**
   * Remove a marker from the session
   * @param {string} markerId Id of the marker
   * @param {string} source Path of the session
   */


  removeMarker(markerId, source) {
    if (this.sessions[source]) {
      this.sessions[source].removeMarker(markerId);
    }
  }
  /**
   * Clears all the annotations for the current session.
   */


  clearAnnotations() {
    this.sourceAnnotations = [];
    this.editor.getSession().clearAnnotations();
  }
  /**
   * Add an annotation to the current session.
   * @param {Object} annotation
   */


  addAnnotation(annotation) {
    this.sourceAnnotations[this.sourceAnnotations.length] = annotation;
    this.setAnnotations(this.sourceAnnotations);
  }
  /**
   * Set a list of annotations to the current session.
   * @param {Array<Object>} annotation
   */


  setAnnotations(sourceAnnotations) {
    this.editor.getSession().setAnnotations(sourceAnnotations);
  }
  /**
   * Moves the cursor and focus to the specified line and column number
   * @param {number} line
   * @param {number} col
   */


  gotoLine(line, col) {
    this.editor.focus();
    this.editor.gotoLine(line + 1, col - 1, true);
  }

}

module.exports = Editor;

/***/ }),

/***/ "./app/editor/example-contracts.js":
/*!*****************************************!*\
  !*** ./app/editor/example-contracts.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const storage = `pragma solidity >=0.4.22 <0.7.0;

/**
 * @title Storage
 * @dev Store & retrieve value in a variable
 */
contract Storage {

    uint256 number;

    /**
     * @dev Store value in variable
     * @param num value to store
     */
    function store(uint256 num) public {
        number = num;
    }

    /**
     * @dev Return value 
     * @return value of 'number'
     */
    function retrieve() public view returns (uint256){
        return number;
    }
}`;
const owner = `pragma solidity >=0.4.22 <0.7.0;

/**
 * @title Owner
 * @dev Set & change owner
 */
contract Owner {

    address private owner;
    
    // event for EVM logging
    event OwnerSet(address indexed oldOwner, address indexed newOwner);
    
    // modifier to check if caller is owner
    modifier isOwner() {
        // If the first argument of 'require' evaluates to 'false', execution terminates and all
        // changes to the state and to Ether balances are reverted.
        // This used to consume all gas in old EVM versions, but not anymore.
        // It is often a good idea to use 'require' to check if functions are called correctly.
        // As a second argument, you can also provide an explanation about what went wrong.
        require(msg.sender == owner, "Caller is not owner");
        _;
    }
    
    /**
     * @dev Set contract deployer as owner
     */
    constructor() public {
        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor
        emit OwnerSet(address(0), owner);
    }

    /**
     * @dev Change owner
     * @param newOwner address of new owner
     */
    function changeOwner(address newOwner) public isOwner {
        emit OwnerSet(owner, newOwner);
        owner = newOwner;
    }

    /**
     * @dev Return owner address 
     * @return address of owner
     */
    function getOwner() external view returns (address) {
        return owner;
    }
}`;
const ballot = `pragma solidity >=0.4.22 <0.7.0;

/** 
 * @title Ballot
 * @dev Implements voting process along with vote delegation
 */
contract Ballot {
   
    struct Voter {
        uint weight; // weight is accumulated by delegation
        bool voted;  // if true, that person already voted
        address delegate; // person delegated to
        uint vote;   // index of the voted proposal
    }

    struct Proposal {
        // If you can limit the length to a certain number of bytes, 
        // always use one of bytes1 to bytes32 because they are much cheaper
        bytes32 name;   // short name (up to 32 bytes)
        uint voteCount; // number of accumulated votes
    }

    address public chairperson;

    mapping(address => Voter) public voters;

    Proposal[] public proposals;

    /** 
     * @dev Create a new ballot to choose one of 'proposalNames'.
     * @param proposalNames names of proposals
     */
    constructor(bytes32[] memory proposalNames) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;

        for (uint i = 0; i < proposalNames.length; i++) {
            // 'Proposal({...})' creates a temporary
            // Proposal object and 'proposals.push(...)'
            // appends it to the end of 'proposals'.
            proposals.push(Proposal({
                name: proposalNames[i],
                voteCount: 0
            }));
        }
    }
    
    /** 
     * @dev Give 'voter' the right to vote on this ballot. May only be called by 'chairperson'.
     * @param voter address of voter
     */
    function giveRightToVote(address voter) public {
        require(
            msg.sender == chairperson,
            "Only chairperson can give right to vote."
        );
        require(
            !voters[voter].voted,
            "The voter already voted."
        );
        require(voters[voter].weight == 0);
        voters[voter].weight = 1;
    }

    /**
     * @dev Delegate your vote to the voter 'to'.
     * @param to address to which vote is delegated
     */
    function delegate(address to) public {
        Voter storage sender = voters[msg.sender];
        require(!sender.voted, "You already voted.");
        require(to != msg.sender, "Self-delegation is disallowed.");

        while (voters[to].delegate != address(0)) {
            to = voters[to].delegate;

            // We found a loop in the delegation, not allowed.
            require(to != msg.sender, "Found loop in delegation.");
        }
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegate_ = voters[to];
        if (delegate_.voted) {
            // If the delegate already voted,
            // directly add to the number of votes
            proposals[delegate_.vote].voteCount += sender.weight;
        } else {
            // If the delegate did not vote yet,
            // add to her weight.
            delegate_.weight += sender.weight;
        }
    }

    /**
     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.
     * @param proposal index of proposal in the proposals array
     */
    function vote(uint proposal) public {
        Voter storage sender = voters[msg.sender];
        require(sender.weight != 0, "Has no right to vote");
        require(!sender.voted, "Already voted.");
        sender.voted = true;
        sender.vote = proposal;

        // If 'proposal' is out of the range of the array,
        // this will throw automatically and revert all
        // changes.
        proposals[proposal].voteCount += sender.weight;
    }

    /** 
     * @dev Computes the winning proposal taking all previous votes into account.
     * @return winningProposal_ index of winning proposal in the proposals array
     */
    function winningProposal() public view
            returns (uint winningProposal_)
    {
        uint winningVoteCount = 0;
        for (uint p = 0; p < proposals.length; p++) {
            if (proposals[p].voteCount > winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposal_ = p;
            }
        }
    }

    /** 
     * @dev Calls winningProposal() function to get the index of the winner contained in the proposals array and then
     * @return winnerName_ the name of the winner
     */
    function winnerName() public view
            returns (bytes32 winnerName_)
    {
        winnerName_ = proposals[winningProposal()].name;
    }
}
`;
var ballotTest = `pragma solidity >=0.4.22 <0.7.0;
import "remix_tests.sol"; // this import is automatically injected by Remix.
import "../3_Ballot.sol";

contract BallotTest {
   
    bytes32[] proposalNames;
   
    Ballot ballotToTest;
    function beforeAll () public {
        proposalNames.push(bytes32("candidate1"));
        ballotToTest = new Ballot(proposalNames);
    }
    
    function checkWinningProposal () public {
        ballotToTest.vote(0);
        Assert.equal(ballotToTest.winningProposal(), uint(0), "proposal at index 0 should be the winning proposal");
        Assert.equal(ballotToTest.winnerName(), bytes32("candidate1"), "candidate1 should be the winner name");
    }
    
    function checkWinninProposalWithReturnValue () public view returns (bool) {
        return ballotToTest.winningProposal() == 0;
    }
}
`;
module.exports = {
  storage: {
    name: '1_Storage.sol',
    content: storage
  },
  owner: {
    name: '2_Owner.sol',
    content: owner
  },
  ballot: {
    name: '3_Ballot.sol',
    content: ballot
  },
  ballot_test: {
    name: 'tests/4_Ballot_test.sol',
    content: ballotTest
  }
};

/***/ }),

/***/ "./app/editor/sourceHighlighter.js":
/*!*****************************************!*\
  !*** ./app/editor/sourceHighlighter.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const globlalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

class SourceHighlighter {
  constructor(localRegistry) {
    this._components = {};
    this._components.registry = localRegistry || globlalRegistry; // dependencies

    this._deps = {
      editor: this._components.registry.get('editor').api,
      config: this._components.registry.get('config').api,
      fileManager: this._components.registry.get('filemanager').api,
      compilerArtefacts: this._components.registry.get('compilersartefacts').api
    };
    this.position = null;
    this.statementMarker = null;
    this.fullLineMarker = null;
    this.source = null;
  }

  currentSourceLocation(lineColumnPos, location) {
    if (this.statementMarker) this._deps.editor.removeMarker(this.statementMarker, this.source);
    if (this.fullLineMarker) this._deps.editor.removeMarker(this.fullLineMarker, this.source);
    let lastCompilationResult = this._deps.compilerArtefacts['__last'];

    if (location && location.file !== undefined && lastCompilationResult) {
      const path = lastCompilationResult.getSourceName(location.file);

      if (path) {
        this.currentSourceLocationFromfileName(lineColumnPos, path);
      }
    }
  }

  async currentSourceLocationFromfileName(lineColumnPos, filePath, style) {
    if (this.statementMarker) this._deps.editor.removeMarker(this.statementMarker, this.source);
    if (this.fullLineMarker) this._deps.editor.removeMarker(this.fullLineMarker, this.source);
    this.statementMarker = null;
    this.fullLineMarker = null;
    this.source = null;

    if (lineColumnPos) {
      this.source = filePath;

      if (this._deps.fileManager.currentFile() !== this.source) {
        await this._deps.fileManager.open(this.source);
        this.source = this._deps.fileManager.currentFile();
      }

      const css = csjs`
        .highlightcode {
          position:absolute;
          z-index:20;
          opacity: 0.3;
          background-color: ${style || 'var(--info)'};
        }
        .highlightcode_fullLine {
          position:absolute;
          z-index:20;
          opacity: 0.5;
          background-color: ${style || 'var(--info)'};
        }
        .customBackgroundColor {
          background-color: ${style || 'var(--info)'};
        }
        `;
      this.statementMarker = this._deps.editor.addMarker(lineColumnPos, this.source, css.highlightcode.className + ' ' + css.customBackgroundColor.className + ' ' + `highlightLine${lineColumnPos.start.line}`);

      this._deps.editor.scrollToLine(lineColumnPos.start.line, true, true, function () {});

      this.position = lineColumnPos;

      if (lineColumnPos.start.line === lineColumnPos.end.line) {
        this.fullLineMarker = this._deps.editor.addMarker({
          start: {
            line: lineColumnPos.start.line,
            column: 0
          },
          end: {
            line: lineColumnPos.start.line + 1,
            column: 0
          }
        }, this.source, css.highlightcode_fullLine.className);
      }
    }
  }

}

module.exports = SourceHighlighter;

/***/ }),

/***/ "./app/editor/styles/contextView-styles.js":
/*!*************************************************!*\
  !*** ./app/editor/styles/contextView-styles.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .contextview {
    opacity             : 1;
    position            : relative;
    height              : 25px;
  }
  .container {
    padding             : 1px 15px;
  }
  .line {
    display             : flex;
    justify-content     : flex-end;
    align-items         : center;
    text-overflow       : ellipsis;
    overflow            : hidden;
    white-space         : nowrap;
    font-size           : 13px;
  }
  .type {
    font-style        : italic;
    margin-right      : 5px;
  }
  .name  {
    font-weight       : bold;
  }
  .jump {
    cursor            : pointer;
    margin            : 0 5px;
  }
  .jump:hover              {
    color             : var(--secondary);
  }
  .referencesnb {
    float             : right;
    margin-left       : 15px;
  }
  .gasEstimation {
    margin-right      : 15px;
    display           : flex;
    align-items       : center;
  }
  .gasStationIcon {
    margin-right      : 5px;
  }
  .contextviewcontainer {
    z-index           : 50;
    border-radius     : 1px;
    border            : 2px solid var(--secondary);
  }
  .contextviewcontainer{
    z-index           : 50;
    border-radius     : 1px;
    border            : 2px solid var(--secondary);
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/files/compiler-metadata.js":
/*!****************************************!*\
  !*** ./app/files/compiler-metadata.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var CompilerAbstract = __webpack_require__(/*! ../compiler/compiler-abstract */ "./app/compiler/compiler-abstract.js");

const profile = {
  name: 'compilerMetadata',
  methods: ['deployMetadataOf'],
  events: [],
  version: packageJson.version
};

class CompilerMetadata extends _engine.Plugin {
  constructor(blockchain, fileManager, config) {
    super(profile);
    this.blockchain = blockchain;
    this.fileManager = fileManager;
    this.config = config;
    this.networks = ['VM:-', 'main:1', 'ropsten:3', 'rinkeby:4', 'kovan:42', 'grli:5', 'Custom'];
    this.innerPath = 'artifacts';
  }

  _JSONFileName(path, contractName) {
    return path + '/' + this.innerPath + '/' + contractName + '.json';
  }

  onActivation() {
    var self = this;
    this.on('solidity', 'compilationFinished', (file, source, languageVersion, data) => {
      if (!self.config.get('settings/generate-contract-metadata')) return;
      let compiler = new CompilerAbstract(languageVersion, data, source);
      var provider = self.fileManager.currentFileProvider();
      var path = self.fileManager.currentPath();

      if (provider && path) {
        compiler.visitContracts(contract => {
          if (contract.file !== source.target) return;

          var fileName = self._JSONFileName(path, contract.name);

          provider.get(fileName, (error, content) => {
            if (!error) {
              content = content || '{}';
              var metadata;

              try {
                metadata = JSON.parse(content);
              } catch (e) {
                console.log(e);
              }

              var deploy = metadata.deploy || {};
              self.networks.forEach(network => {
                deploy[network] = self._syncContext(contract, deploy[network] || {});
              });
              var data = {
                deploy,
                data: {
                  bytecode: contract.object.evm.bytecode,
                  deployedBytecode: contract.object.evm.deployedBytecode,
                  gasEstimates: contract.object.evm.gasEstimates,
                  methodIdentifiers: contract.object.evm.methodIdentifiers
                },
                abi: contract.object.abi
              };
              provider.set(fileName, JSON.stringify(data, null, '\t'));
            }
          });
        });
      }
    });
  }

  _syncContext(contract, metadata) {
    var linkReferences = metadata['linkReferences'];
    var autoDeployLib = metadata['autoDeployLib'];
    if (!linkReferences) linkReferences = {};
    if (autoDeployLib === undefined) autoDeployLib = true;

    for (var libFile in contract.object.evm.bytecode.linkReferences) {
      if (!linkReferences[libFile]) linkReferences[libFile] = {};

      for (var lib in contract.object.evm.bytecode.linkReferences[libFile]) {
        if (!linkReferences[libFile][lib]) {
          linkReferences[libFile][lib] = '<address>';
        }
      }
    }

    metadata['linkReferences'] = linkReferences;
    metadata['autoDeployLib'] = autoDeployLib;
    return metadata;
  } // TODO: is only called by dropdownLogic and can be moved there


  deployMetadataOf(contractName) {
    return new Promise((resolve, reject) => {
      var provider = this.fileManager.currentFileProvider();
      var path = this.fileManager.currentPath();

      if (provider && path) {
        this.blockchain.detectNetwork((err, {
          id,
          name
        } = {}) => {
          if (err) {
            console.log(err);
            reject(err);
          } else {
            var fileName = this._JSONFileName(path, contractName);

            provider.get(fileName, (error, content) => {
              if (error) return reject(error);
              if (!content) return resolve();

              try {
                var metadata = JSON.parse(content);
                metadata = metadata.deploy || {};
                return resolve(metadata[name + ':' + id] || metadata[name] || metadata[id] || metadata[name.toLowerCase() + ':' + id] || metadata[name.toLowerCase()]);
              } catch (e) {
                reject(e.message);
              }
            });
          }
        });
      } else {
        reject(`Please select the folder in the file explorer where the metadata of ${contractName} can be found`);
      }
    });
  }

}

module.exports = CompilerMetadata;

/***/ }),

/***/ "./app/files/file-explorer.js":
/*!************************************!*\
  !*** ./app/files/file-explorer.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global FileReader */

/* global fetch */
const async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

const Gists = __webpack_require__(/*! gists */ "../../../node_modules/gists/index.js");

const modalDialogCustom = __webpack_require__(/*! ../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

const tooltip = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

const QueryParams = __webpack_require__(/*! ../../lib/query-params */ "./lib/query-params.js");

const helper = __webpack_require__(/*! ../../lib/helper */ "./lib/helper.js");

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const Treeview = __webpack_require__(/*! ../ui/TreeView */ "./app/ui/TreeView.js");

const modalDialog = __webpack_require__(/*! ../ui/modaldialog */ "./app/ui/modaldialog.js");

const EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

const contextMenu = __webpack_require__(/*! ../ui/contextMenu */ "./app/ui/contextMenu.js");

const css = __webpack_require__(/*! ./styles/file-explorer-styles */ "./app/files/styles/file-explorer-styles.js");

const globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

const queryParams = new QueryParams();
let MENU_HANDLE;

function fileExplorer(localRegistry, files, menuItems) {
  var self = this;
  this.events = new EventManager(); // file provider backend

  this.files = files; // element currently focused on

  this.focusElement = null; // path currently focused on

  this.focusPath = null;
  let allItems = [{
    action: 'createNewFile',
    title: 'Create New File',
    icon: 'fas fa-plus-circle'
  }, {
    action: 'publishToGist',
    title: 'Publish all [browser] explorer files to a github gist',
    icon: 'fab fa-github'
  }, {
    action: 'uploadFile',
    title: 'Add Local file to the Browser Storage Explorer',
    icon: 'far fa-folder-open'
  }, {
    action: 'updateGist',
    title: 'Update the current [gist] explorer',
    icon: 'fab fa-github'
  }]; // menu items

  this.menuItems = allItems.filter(item => {
    if (menuItems) return menuItems.find(name => {
      return name === item.action;
    });
  });
  self._components = {};
  self._components.registry = localRegistry || globalRegistry;
  self._deps = {
    config: self._components.registry.get('config').api,
    editor: self._components.registry.get('editor').api,
    fileManager: self._components.registry.get('filemanager').api
  };
  self.events.register('focus', function (path) {
    self._deps.fileManager.open(path);
  });

  self._components.registry.put({
    api: self,
    name: `fileexplorer/${self.files.type}`
  }); // warn if file changed outside of Remix


  function remixdDialog() {
    return yo`<div>This file has been changed outside of Remix IDE.</div>`;
  }

  this.files.event.register('fileExternallyChanged', (path, file) => {
    if (self._deps.config.get('currentFile') === path && self._deps.editor.currentContent() && self._deps.editor.currentContent() !== file.content) {
      if (this.files.isReadOnly(path)) return self._deps.editor.setText(file.content);
      modalDialog(path + ' changed', remixdDialog(), {
        label: 'Replace by the new content',
        fn: () => {
          self._deps.editor.setText(file.content);
        }
      }, {
        label: 'Keep the content displayed in Remix',
        fn: () => {}
      });
    }
  }); // register to event of the file provider

  files.event.register('fileRemoved', fileRemoved);
  files.event.register('fileRenamed', fileRenamed);
  files.event.register('fileRenamedError', fileRenamedError);
  files.event.register('fileAdded', fileAdded);
  files.event.register('folderAdded', folderAdded);

  function fileRenamedError(error) {
    modalDialogCustom.alert(error);
  }

  function fileAdded(filepath) {
    self.ensureRoot(() => {
      const folderpath = filepath.split('/').slice(0, -1).join('/');
      const currentTree = self.treeView.nodeAt(folderpath);
      if (!self.treeView.isExpanded(folderpath)) self.treeView.expand(folderpath);

      if (currentTree) {
        self.files.resolveDirectory(folderpath, (error, fileTree) => {
          if (error) console.error(error);
          if (!fileTree) return;
          fileTree = normalize(folderpath, fileTree);
          self.treeView.updateNodeFromJSON(folderpath, fileTree, true);
          self.focusElement = self.treeView.labelAt(self.focusPath); // TODO: here we update the selected file (it applicable)
          // cause we are refreshing the interface of the whole directory when there's a new file.

          if (self.focusElement && !self.focusElement.classList.contains('bg-secondary')) {
            self.focusElement.classList.add('bg-secondary');
          }
        });
      }
    });
  }

  function extractNameFromKey(key) {
    const keyPath = key.split('/');
    return keyPath[keyPath.length - 1];
  }

  function folderAdded(folderpath) {
    self.ensureRoot(() => {
      folderpath = folderpath.split('/').slice(0, -1).join('/');
      self.files.resolveDirectory(folderpath, (error, fileTree) => {
        if (error) console.error(error);
        if (!fileTree) return;
        fileTree = normalize(folderpath, fileTree);
        self.treeView.updateNodeFromJSON(folderpath, fileTree, true);
        if (!self.treeView.isExpanded(folderpath)) self.treeView.expand(folderpath);
      });
    });
  }

  function fileRemoved(filepath) {
    const label = self.treeView.labelAt(filepath);
    filepath = filepath.split('/').slice(0, -1).join('/');

    if (label && label.parentElement) {
      label.parentElement.removeChild(label);
    }

    self.updatePath(filepath);
  }

  function fileRenamed(oldName, newName, isFolder) {
    fileRemoved(oldName);
    fileAdded(newName);
  } // make interface and register to nodeClick, leafClick


  self.treeView = new Treeview({
    extractData: function extractData(value, tree, key) {
      var newValue = {}; // var isReadOnly = false

      var isFile = false;
      Object.keys(value).filter(function keep(x) {
        if (x === '/content') isFile = true;
        if (x[0] !== '/') return true;
      }).forEach(function (x) {
        newValue[x] = value[x];
      });
      return {
        path: (tree || {}).path ? tree.path + '/' + key : key,
        children: isFile ? undefined : value instanceof Array ? value.map((item, index) => ({
          key: index,
          value: item
        })) : value instanceof Object ? Object.keys(value).map(subkey => ({
          key: subkey,
          value: value[subkey]
        })) : undefined
      };
    },
    formatSelf: function formatSelf(key, data, li) {
      const isRoot = data.path === self.files.type;
      const isFolder = !!data.children;
      return yo`
        <div class="${css.items}">
          <span
            title="${data.path}"
            class="${css.label} ${!isRoot ? !isFolder ? css.leaf : css.folder : ''}"
            data-path="${data.path}"
            style="${isRoot ? 'font-weight:bold;' : ''}"
            onkeydown=${editModeOff}
            onblur=${editModeOff}
          >
            ${key.split('/').pop()}
          </span>
          ${isRoot ? self.renderMenuItems() : ''}
        </div>
      `;
    }
  });
  /**
   * Extracts first two folders as a subpath from the path.
   **/

  function extractExternalFolder(path) {
    const firstSlIndex = path.indexOf('/', 1);
    if (firstSlIndex === -1) return '';
    const secondSlIndex = path.indexOf('/', firstSlIndex + 1);
    if (secondSlIndex === -1) return '';
    return path.substring(0, secondSlIndex);
  }

  self.treeView.event.register('nodeRightClick', function (key, data, label, event) {
    if (self.files.readonly) return;
    if (key === self.files.type) return;
    MENU_HANDLE && MENU_HANDLE.hide(null, true);
    let actions = {};

    const provider = self._deps.fileManager.fileProviderOf(key);

    actions['Create File'] = () => self.createNewFile(key);

    actions['Create Folder'] = () => self.createNewFolder(key); // @todo(#2386) not fully implemented. Readd later when fixed


    if (provider.isExternalFolder(key)) {
      /* actions['Discard changes'] = () => {
        modalDialogCustom.confirm(
          'Discard changes',
          'Are you sure you want to discard all your changes?',
          () => { self.files.discardChanges(key) },
          () => {}
        )
      } */
    } else {
      const folderPath = extractExternalFolder(key);

      actions['Rename'] = () => {
        if (self.files.isReadOnly(key)) {
          return tooltip('cannot rename folder. ' + self.files.type + ' is a read only explorer');
        }

        var name = label.querySelector('span[data-path="' + key + '"]');
        if (name) editModeOn(name);
      };

      actions['Delete'] = () => {
        if (self.files.isReadOnly(key)) {
          return tooltip('cannot delete folder. ' + self.files.type + ' is a read only explorer');
        }

        const currentFoldername = extractNameFromKey(key);
        modalDialogCustom.confirm(`Confirm to delete folder`, `Are you sure you want to delete ${currentFoldername} folder?`, async () => {
          const fileManager = self._deps.fileManager;
          const removeFolder = await fileManager.remove(key);

          if (!removeFolder) {
            tooltip(`failed to remove ${key}. Make sure the directory is empty before removing it.`);
          }
        }, () => {});
      };

      if (folderPath === 'browser/gists') {
        actions['Push changes to gist'] = () => {
          const id = key.substr(key.lastIndexOf('/') + 1, key.length - 1);
          modalDialogCustom.confirm('Push back to Gist', 'Are you sure you want to push all your changes back to Gist?', () => {
            self.toGist(id);
          }, () => {});
        };
      }
    }

    MENU_HANDLE = contextMenu(event, actions);
  });
  self.treeView.event.register('leafRightClick', function (key, data, label, event) {
    if (key === self.files.type) return;
    MENU_HANDLE && MENU_HANDLE.hide(null, true);
    let actions = {};

    const provider = self._deps.fileManager.fileProviderOf(key);

    if (!provider.isExternalFolder(key)) {
      actions['Create Folder'] = () => self.createNewFolder(self._deps.fileManager.extractPathOf(key));

      actions['Rename'] = () => {
        if (self.files.isReadOnly(key)) {
          return tooltip('cannot rename file. ' + self.files.type + ' is a read only explorer');
        }

        var name = label.querySelector('span[data-path="' + key + '"]');
        if (name) editModeOn(name);
      };

      actions['Delete'] = () => {
        if (self.files.isReadOnly(key)) {
          return tooltip('cannot delete file. ' + self.files.type + ' is a read only explorer');
        }

        const currentFilename = extractNameFromKey(key);
        modalDialogCustom.confirm(`Delete file`, `Are you sure you want to delete ${currentFilename} file?`, async () => {
          const fileManager = self._deps.fileManager;
          const removeFile = await fileManager.remove(key);

          if (!removeFile) {
            tooltip(`Failed to remove file ${key}.`);
          }
        }, () => {});
      };
    }

    MENU_HANDLE = contextMenu(event, actions);
  });
  self.treeView.event.register('leafClick', function (key, data, label) {
    self.events.trigger('focus', [key]);
  });
  self.treeView.event.register('nodeClick', function (path, childrenContainer) {
    if (!childrenContainer) return;
    if (childrenContainer.style.display === 'none') return;
    self.updatePath(path);
  }); // register to main app, trigger when the current file in the editor changed

  self._deps.fileManager.events.on('currentFileChanged', newFile => {
    const provider = self._deps.fileManager.fileProviderOf(newFile);

    if (self.focusElement && self.focusPath !== newFile) {
      self.focusElement.classList.remove('bg-secondary');
      self.focusElement = null;
      self.focusPath = null;
    }

    if (provider && provider.type === files.type) {
      self.focusElement = self.treeView.labelAt(newFile);

      if (self.focusElement) {
        self.focusElement.classList.add('bg-secondary');
        self.focusPath = newFile;
      }
    }
  });

  self._deps.fileManager.events.on('noFileSelected', () => {
    if (self.focusElement) {
      self.focusElement.classList.remove('bg-secondary');
      self.focusElement = null;
      self.focusPath = null;
    }
  });

  var textUnderEdit = null;

  function selectElementContents(el) {
    var range = document.createRange();
    range.selectNodeContents(el);
    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }

  function editModeOn(label) {
    textUnderEdit = label.innerText;
    label.setAttribute('contenteditable', true);
    label.classList.add('bg-light');
    label.focus();
    selectElementContents(label);
  }

  function editModeOff(event) {
    let label = this;
    const isFolder = label.className.indexOf('folder') !== -1;

    function rename() {
      var newPath = label.dataset.path;
      newPath = newPath.split('/');
      newPath[newPath.length - 1] = label.innerText;
      newPath = newPath.join('/');

      if (label.innerText === '') {
        modalDialogCustom.alert('File name cannot be empty');
        label.innerText = textUnderEdit;
      } else if (helper.checkSpecialChars(label.innerText)) {
        modalDialogCustom.alert('Special characters are not allowed');
        label.innerText = textUnderEdit;
      } else {
        files.exists(newPath, (error, exist) => {
          if (error) return modalDialogCustom.alert('Unexpected error while renaming: ' + error);

          if (!exist) {
            files.rename(label.dataset.path, newPath, isFolder);
          } else {
            modalDialogCustom.alert('File already exists.');
            label.innerText = textUnderEdit;
          }
        });
      }
    }

    if (event.which === 13) event.preventDefault();

    if ((event.type === 'blur' || event.which === 13) && label.getAttribute('contenteditable')) {
      var save = textUnderEdit !== label.innerText;

      if (save) {
        modalDialogCustom.confirm('Confirm to rename a ' + (isFolder ? 'folder' : 'file'), 'Are you sure you want to rename ' + textUnderEdit + '?', () => {
          rename();
        }, () => {
          label.innerText = textUnderEdit;
        });
      }

      label.removeAttribute('contenteditable');
      label.classList.remove('bg-light');
    }
  }
}

fileExplorer.prototype.updatePath = function (path) {
  this.files.resolveDirectory(path, (error, fileTree) => {
    if (error) console.error(error);
    if (!fileTree) return;
    var newTree = normalize(path, fileTree);
    this.treeView.updateNodeFromJSON(path, newTree, true);
  });
};

fileExplorer.prototype.hide = function () {
  if (this.container) this.container.style.display = 'none';
};

fileExplorer.prototype.show = function () {
  if (this.container) this.container.style.display = 'block';
};

fileExplorer.prototype.init = function () {
  this.container = yo`<div></div>`;
  return this.container;
};

fileExplorer.prototype.publishToGist = function () {
  modalDialogCustom.confirm('Create a public gist', 'Are you sure you want to publish all your files in browser directory anonymously as a public gist on github.com? Note: this will not include directories.', () => {
    this.toGist();
  });
};

fileExplorer.prototype.uploadFile = function (event) {
  // TODO The file explorer is merely a view on the current state of
  // the files module. Please ask the user here if they want to overwrite
  // a file and then just use `files.add`. The file explorer will
  // pick that up via the 'fileAdded' event from the files module.
  let self = this;
  [...event.target.files].forEach(file => {
    let files = this.files;

    function loadFile() {
      var fileReader = new FileReader();

      fileReader.onload = async function (event) {
        if (helper.checkSpecialChars(file.name)) {
          modalDialogCustom.alert('Special characters are not allowed');
          return;
        }

        var success = await files.set(name, event.target.result);

        if (!success) {
          modalDialogCustom.alert('Failed to create file ' + name);
        } else {
          self.events.trigger('focus', [name]);
        }
      };

      fileReader.readAsText(file);
    }

    var name = files.type + '/' + file.name;
    files.exists(name, (error, exist) => {
      if (error) console.log(error);

      if (!exist) {
        loadFile();
      } else {
        modalDialogCustom.confirm('Confirm overwrite', `The file ${name} already exists! Would you like to overwrite it?`, () => {
          loadFile();
        });
      }
    });
  });
};

fileExplorer.prototype.toGist = function (id) {
  let proccedResult = function (error, data) {
    if (error) {
      modalDialogCustom.alert('Failed to manage gist: ' + error);
      console.log('Failed to manage gist: ' + error);
    } else {
      if (data.html_url) {
        modalDialogCustom.confirm('Gist is ready', `The gist is at ${data.html_url}. Would you like to open it in a new window?`, () => {
          window.open(data.html_url, '_blank');
        });
      } else {
        modalDialogCustom.alert(data.message + ' ' + data.documentation_url + ' ' + JSON.stringify(data.errors, null, '\t'));
      }
    }
  };
  /**
   * This function is to get the original content of given gist
   * @params id is the gist id to fetch
   */


  async function getOriginalFiles(id) {
    if (!id) {
      return [];
    }

    const url = `https://api.github.com/gists/${id}`;
    const res = await fetch(url);
    const data = await res.json();
    return data.files || [];
  } // If 'id' is not defined, it is not a gist update but a creation so we have to take the files from the browser explorer.


  const folder = id ? 'browser/gists/' + id : 'browser/';
  this.packageFiles(this.files, folder, (error, packaged) => {
    if (error) {
      console.log(error);
      modalDialogCustom.alert('Failed to create gist: ' + error.message);
    } else {
      // check for token
      var tokenAccess = this._deps.config.get('settings/gist-access-token');

      if (!tokenAccess) {
        modalDialogCustom.alert('Remix requires an access token (which includes gists creation permission). Please go to the settings tab to create one.');
      } else {
        const description = 'Created using remix-ide: Realtime Ethereum Contract Compiler and Runtime. \n Load this file by pasting this gists URL or ID at https://remix.ethereum.org/#version=' + queryParams.get().version + '&optimize=' + queryParams.get().optimize + '&gist=';
        const gists = new Gists({
          token: tokenAccess
        });

        if (id) {
          const originalFileList = getOriginalFiles(id); // Telling the GIST API to remove files

          const updatedFileList = Object.keys(packaged);
          const allItems = Object.keys(originalFileList).filter(fileName => updatedFileList.indexOf(fileName) === -1).reduce((acc, deleteFileName) => ({ ...acc,
            [deleteFileName]: null
          }), originalFileList); // adding new files

          updatedFileList.forEach(file => {
            const _items = file.split('/');

            const _fileName = _items[_items.length - 1];
            allItems[_fileName] = packaged[file];
          });
          tooltip('Saving gist (' + id + ') ...');
          gists.edit({
            description: description,
            public: true,
            files: allItems,
            id: id
          }, (error, result) => {
            proccedResult(error, result);

            if (!error) {
              for (const key in allItems) {
                if (allItems[key] === null) delete allItems[key];
              }
            }
          });
        } else {
          // id is not existing, need to create a new gist
          tooltip('Creating a new gist ...');
          gists.create({
            description: description,
            public: true,
            files: packaged
          }, (error, result) => {
            proccedResult(error, result);
          });
        }
      }
    }
  });
}; // return all the files, except the temporary/readonly ones..


fileExplorer.prototype.packageFiles = function (filesProvider, directory, callback) {
  let ret = {};
  filesProvider.resolveDirectory(directory, (error, files) => {
    if (error) callback(error);else {
      async.eachSeries(Object.keys(files), (path, cb) => {
        if (filesProvider.isDirectory(path)) {
          cb();
        } else {
          filesProvider.get(path, (error, content) => {
            if (error) return cb(error);

            if (/^\s+$/.test(content) || !content.length) {
              content = '// this line is added to create a gist. Empty file is not allowed.';
            }

            ret[path] = {
              content
            };
            cb();
          });
        }
      }, error => {
        callback(error, ret);
      });
    }
  });
};

fileExplorer.prototype.createNewFile = function (parentFolder = 'browser') {
  let self = this;
  modalDialogCustom.prompt('Create new file', 'File Name (e.g Untitled.sol)', 'Untitled.sol', input => {
    if (!input) input = 'New file';
    helper.createNonClashingName(parentFolder + '/' + input, self.files, async (error, newName) => {
      if (error) return tooltip('Failed to create file ' + newName + ' ' + error);
      const fileManager = self._deps.fileManager;
      const createFile = await fileManager.writeFile(newName, '');

      if (!createFile) {
        tooltip('Failed to create file ' + newName);
      } else {
        await fileManager.open(newName);

        if (newName.includes('_test.sol')) {
          self.events.trigger('newTestFileCreated', [newName]);
        }
      }
    });
  }, null, true);
};

fileExplorer.prototype.createNewFolder = function (parentFolder) {
  let self = this;
  modalDialogCustom.prompt('Create new folder', '', 'New folder', input => {
    if (!input) {
      return tooltip('Failed to create folder. The name can not be empty');
    }

    const currentPath = !parentFolder ? self._deps.fileManager.currentPath() : parentFolder;
    let newName = currentPath ? currentPath + '/' + input : self.files.type + '/' + input;
    newName = newName + '/';
    self.files.exists(newName, (error, exist) => {
      if (error) return tooltip('Unexpected error while creating folder: ' + error);

      if (!exist) {
        self.files.set(newName, '');
      } else {
        tooltip('Folder already exists.', () => {});
      }
    });
  }, null, true);
};

fileExplorer.prototype.renderMenuItems = function () {
  let items = '';

  if (this.menuItems) {
    items = this.menuItems.map(({
      action,
      title,
      icon
    }) => {
      if (action === 'uploadFile') {
        return yo`
          <label
            id=${action}
            data-id="fileExplorerUploadFile${action}"
            class="${icon} mb-0 ${css.newFile}"
            title="${title}"
          >
            <input id="fileUpload" data-id="fileExplorerFileUpload" type="file" onchange=${event => {
          event.stopPropagation();
          this.uploadFile(event);
        }} multiple />
          </label>
        `;
      } else {
        return yo`
          <span
            id=${action}
            data-id="fileExplorerNewFile${action}"
            onclick=${event => {
          event.stopPropagation();
          this[action]();
        }}
            class="newFile ${icon} ${css.newFile}"
            title=${title}
          >
          </span>
        `;
      }
    });
  }

  return yo`<span class=" ${css.menu}">${items}</span>`;
};

fileExplorer.prototype.ensureRoot = function (cb) {
  cb = cb || (() => {});

  var self = this;
  if (self.element) return cb();
  const root = {};
  root[this.files.type] = {};
  var element = self.treeView.render(root, false);
  element.classList.add(css.fileexplorer);
  element.events = self.events;
  element.api = self.api;
  self.container.appendChild(element);
  self.element = element;
  if (cb) cb();
  self.treeView.expand(self.files.type);
};

function normalize(path, filesList) {
  var prefix = path.split('/')[0];
  var newList = {};
  Object.keys(filesList).forEach(key => {
    newList[prefix + '/' + key] = filesList[key].isDirectory ? {} : {
      '/content': true
    };
  });
  return newList;
}

module.exports = fileExplorer;

/***/ }),

/***/ "./app/files/fileManager.js":
/*!**********************************!*\
  !*** ./app/files/fileManager.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _yoYo = _interopRequireDefault(__webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js"));

var _async = _interopRequireDefault(__webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js"));

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

const globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

const CompilerImport = __webpack_require__(/*! ../compiler/compiler-imports */ "./app/compiler/compiler-imports.js");

const toaster = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

const modalDialogCustom = __webpack_require__(/*! ../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

const helper = __webpack_require__(/*! ../../lib/helper.js */ "./lib/helper.js");

/*
  attach to files event (removed renamed)
  trigger: currentFileChanged
*/
const profile = {
  name: 'fileManager',
  displayName: 'File manager',
  description: 'Service - read/write to any files or folders, require giving permissions',
  icon: 'assets/img/fileManager.webp',
  permission: true,
  version: packageJson.version,
  methods: ['file', 'exists', 'open', 'writeFile', 'readFile', 'copyFile', 'rename', 'mkdir', 'readdir', 'remove', 'getCurrentFile', 'getFile', 'getFolder', 'setFile', 'switchFile'],
  kind: 'file-system'
};
const errorMsg = {
  ENOENT: 'No such file or directory',
  EISDIR: 'Path is a directory',
  ENOTDIR: 'Path is not on a directory',
  EEXIST: 'File already exists',
  EPERM: 'Permission denied'
};

const createError = err => {
  return new Error(`${errorMsg[err.code]} ${err.message || ''}`);
};

class FileManager extends _engine.Plugin {
  constructor(editor, appManager) {
    super(profile);
    this.openedFiles = {}; // list all opened files

    this.events = new EventEmitter();
    this.editor = editor;
    this._components = {};
    this._components.compilerImport = new CompilerImport();
    this._components.registry = globalRegistry;
    this.appManager = appManager;
    this.init();
  }
  /**
  * Emit error if path doesn't exist
  * @param {string} path path of the file/directory
  * @param {string} message message to display if path doesn't exist.
  */


  async _handleExists(path, message) {
    const exists = await this.exists(path);

    if (!exists) {
      throw createError({
        code: 'ENOENT',
        message
      });
    }
  }
  /**
   * Emit error if path is not a file
   * @param {string} path path of the file/directory
   * @param {string} message message to display if path is not a file.
   */


  async _handleIsFile(path, message) {
    const isFile = await this.isFile(path);

    if (!isFile) {
      throw createError({
        code: 'EISDIR',
        message
      });
    }
  }
  /**
   * Emit error if path is not a directory
   * @param {string} path path of the file/directory
   * @param {string} message message to display if path is not a directory.
   */


  async _handleIsDir(path, message) {
    const isDir = await this.isDirectory(path);

    if (!isDir) {
      throw createError({
        code: 'ENOTDIR',
        message
      });
    }
  }
  /** The current opened file */


  file() {
    const file = this.currentFile();
    if (!file) throw createError({
      code: 'ENOENT',
      message: 'No file selected'
    });
    return file;
  }
  /**
   * Verify if the path exists (directory or file)
   * @param {string} path path of the directory or file
   * @returns {boolean} true if the path exists
   */


  exists(path) {
    const provider = this.fileProviderOf(path);
    const result = provider.exists(path, (err, result) => {
      if (err) return false;
      return result;
    });
    return result;
  }
  /**
   * Verify if the path provided is a file
   * @param {string} path path of the directory or file
   * @returns {boolean} true if path is a file.
   */


  isFile(path) {
    const provider = this.fileProviderOf(path);
    const result = provider.isFile(path);
    return result;
  }
  /**
  * Verify if the path provided is a directory
  * @param {string} path path of the directory
  * @returns {boolean} true if path is a directory.
  */


  isDirectory(path) {
    const provider = this.fileProviderOf(path);
    const result = provider.isDirectory(path);
    return result;
  }
  /**
   * Open the content of the file in the context (eg: Editor)
   * @param {string} path path of the file
   * @returns {void}
   */


  async open(path) {
    await this._handleExists(path, `Cannot open file ${path}`);
    await this._handleIsFile(path, `Cannot open file ${path}`);
    return this.openFile(path);
  }
  /**
   * Set the content of a specific file
   * @param {string} path path of the file
   * @param {string} data content to write on the file
   * @returns {void}
   */


  async writeFile(path, data) {
    if (await this.exists(path)) {
      await this._handleIsFile(path, `Cannot write file ${path}`);
      return await this.setFileContent(path, data);
    } else {
      return await this.setFileContent(path, data);
    }
  }
  /**
   * Return the content of a specific file
   * @param {string} path path of the file
   * @returns {string} content of the file
   */


  async readFile(path) {
    await this._handleExists(path, `Cannot read file ${path}`);
    await this._handleIsFile(path, `Cannot read file ${path}`);
    return this.getFileContent(path);
  }
  /**
   * Upsert a file with the content of the source file
   * @param {string} src path of the source file
   * @param {string} dest path of the destrination file
   * @returns {void}
   */


  async copyFile(src, dest) {
    await this._handleExists(src, `Cannot copy from ${src}`);
    await this._handleIsFile(src, `Cannot copy from ${src}`);
    await this._handleIsFile(dest, `Cannot paste content into ${dest}`);
    const content = await this.readFile(src);
    await this.writeFile(dest, content);
  }
  /**
   * Change the path of a file/directory
   * @param {string} oldPath current path of the file/directory
   * @param {string} newPath new path of the file/directory
   * @returns {void}
   */


  async rename(oldPath, newPath) {
    await this._handleExists(oldPath, `Cannot rename ${oldPath}`);
    const isFile = await this.isFile(oldPath);
    const newPathExists = await this.exists(newPath);
    const provider = this.fileProviderOf(oldPath);

    if (isFile) {
      if (newPathExists) {
        modalDialogCustom.alert('File already exists.');
        return;
      }

      return provider.rename(oldPath, newPath, false);
    } else {
      if (newPathExists) {
        modalDialogCustom.alert('Folder already exists.');
        return;
      }

      return provider.rename(oldPath, newPath, true);
    }
  }
  /**
   * Create a directory
   * @param {string} path path of the new directory
   * @returns {void}
   */


  async mkdir(path) {
    if (await this.exists(path)) {
      throw createError({
        code: 'EEXIST',
        message: `Cannot create directory ${path}`
      });
    }

    const provider = this.fileProviderOf(path);
    provider.createDir(path);
  }
  /**
   * Get the list of files in the directory
   * @param {string} path path of the directory
   * @returns {string[]} list of the file/directory name in this directory
   */


  async readdir(path) {
    await this._handleExists(path);
    await this._handleIsDir(path);
    return new Promise((resolve, reject) => {
      const provider = this.fileProviderOf(path);
      provider.resolveDirectory(path, (error, filesProvider) => {
        if (error) reject(error);
        resolve(filesProvider);
      });
    });
  }
  /**
   * Removes a file or directory recursively
   * @param {string} path path of the directory/file to remove
   * @returns {void}
   */


  async remove(path) {
    await this._handleExists(path, `Cannot remove file or directory ${path}`);
    const provider = this.fileProviderOf(path);
    return await provider.remove(path);
  }

  init() {
    this._deps = {
      config: this._components.registry.get('config').api,
      browserExplorer: this._components.registry.get('fileproviders/browser').api,
      localhostExplorer: this._components.registry.get('fileproviders/localhost').api,
      filesProviders: this._components.registry.get('fileproviders').api
    };

    this._deps.browserExplorer.event.register('fileChanged', path => {
      this.fileChangedEvent(path);
    });

    this._deps.browserExplorer.event.register('fileRenamed', (oldName, newName, isFolder) => {
      this.fileRenamedEvent(oldName, newName, isFolder);
    });

    this._deps.localhostExplorer.event.register('fileRenamed', (oldName, newName, isFolder) => {
      this.fileRenamedEvent(oldName, newName, isFolder);
    });

    this._deps.browserExplorer.event.register('fileRemoved', path => {
      this.fileRemovedEvent(path);
    });

    this._deps.localhostExplorer.event.register('fileRemoved', path => {
      this.fileRemovedEvent(path);
    });

    this._deps.localhostExplorer.event.register('errored', event => {
      this.removeTabsOf(this._deps.localhostExplorer);
    });

    this._deps.localhostExplorer.event.register('closed', event => {
      this.removeTabsOf(this._deps.localhostExplorer);
    });

    this.getCurrentFile = this.file;
    this.getFile = this.readFile;
    this.getFolder = this.readdir;
    this.setFile = this.writeFile;
    this.switchFile = this.open;
  }

  fileChangedEvent(path) {// @todo(#2386) use only for discard changes function.
    // this.syncEditor(path)
  }

  fileRenamedEvent(oldName, newName, isFolder) {
    if (!isFolder) {
      this._deps.config.set('currentFile', '');

      this.editor.discard(oldName);

      if (this.openedFiles[oldName]) {
        delete this.openedFiles[oldName];
        this.openedFiles[newName] = newName;
      }

      this.openFile(newName);
    } else {
      var newFocus;

      for (var k in this.openedFiles) {
        if (k.indexOf(oldName + '/') === 0) {
          var newAbsolutePath = k.replace(oldName, newName);
          this.openedFiles[newAbsolutePath] = newAbsolutePath;
          delete this.openedFiles[k];

          if (this._deps.config.get('currentFile') === k) {
            newFocus = newAbsolutePath;
          }
        }
      }

      if (newFocus) {
        this.openFile(newFocus);
      }
    } // TODO: Only keep `this.emit` (issue#2210)


    this.emit('fileRenamed', oldName, newName, isFolder);
    this.events.emit('fileRenamed', oldName, newName, isFolder);
  }

  currentFileProvider() {
    var path = this.currentPath();

    if (path) {
      return this.fileProviderOf(path);
    }

    return null;
  }

  currentFile() {
    return this._deps.config.get('currentFile');
  }

  closeFile(name) {
    delete this.openedFiles[name];

    if (!Object.keys(this.openedFiles).length) {
      this._deps.config.set('currentFile', ''); // TODO: Only keep `this.emit` (issue#2210)


      this.emit('noFileSelected');
      this.events.emit('noFileSelected');
    } // TODO: Only keep `this.emit` (issue#2210)


    this.emit('fileClosed', name);
    this.events.emit('fileClosed', name);
  }

  currentPath() {
    var currentFile = this._deps.config.get('currentFile');

    return this.extractPathOf(currentFile);
  }

  extractPathOf(file) {
    var reg = /(.*)(\/).*/;
    var path = reg.exec(file);
    return path ? path[1] : null;
  }

  getFileContent(path) {
    const provider = this.fileProviderOf(path);
    if (!provider) throw createError({
      code: 'ENOENT',
      message: `${path} not available`
    }); // TODO: change provider to Promise

    return new Promise((resolve, reject) => {
      if (this.currentFile() === path) return resolve(this.editor.currentContent());
      provider.get(path, (err, content) => {
        if (err) reject(err);
        resolve(content);
      });
    });
  }

  async setFileContent(path, content) {
    if (this.currentRequest) {
      const canCall = await this.askUserPermission('writeFile', '');

      if (canCall) {
        // inform the user about modification after permission is granted and even if permission was saved before
        toaster((0, _yoYo.default)`
          <div>
            <i class="fas fa-exclamation-triangle text-danger mr-1"></i>
            <span>
              ${this.currentRequest.from}
              <span class="font-weight-bold text-warning">
                is modifying 
              </span>${path}
            </span>
          </div>
        `, '', {
          time: 3000
        });
      }
    }

    return await this._setFileInternal(path, content);
  }

  _setFileInternal(path, content) {
    const provider = this.fileProviderOf(path);
    if (!provider) throw createError({
      code: 'ENOENT',
      message: `${path} not available`
    }); // TODO : Add permission
    // TODO : Change Provider to Promise

    return new Promise((resolve, reject) => {
      provider.set(path, content, error => {
        if (error) reject(error);
        this.syncEditor(path);
        resolve(true);
      });
    });
  }

  _saveAsCopy(path, content) {
    const fileProvider = this.fileProviderOf(path);

    if (fileProvider) {
      helper.createNonClashingNameWithPrefix(path, fileProvider, '', (error, copyName) => {
        if (error) {
          copyName = path + '.' + this.currentRequest.from;
        }

        this._setFileInternal(copyName, content);

        this.openFile(copyName);
      });
    }
  }

  removeTabsOf(provider) {
    for (var tab in this.openedFiles) {
      if (this.fileProviderOf(tab).type === provider.type) {
        this.fileRemovedEvent(tab);
      }
    }
  }

  fileRemovedEvent(path) {
    if (!this.openedFiles[path]) return;

    if (path === this._deps.config.get('currentFile')) {
      this._deps.config.set('currentFile', '');
    }

    this.editor.discard(path);
    delete this.openedFiles[path]; // TODO: Only keep `this.emit` (issue#2210)

    this.emit('fileRemoved', path);
    this.events.emit('fileRemoved', path);
    this.openFile();
  }

  unselectCurrentFile() {
    this.saveCurrentFile();

    this._deps.config.set('currentFile', ''); // TODO: Only keep `this.emit` (issue#2210)


    this.emit('noFileSelected');
    this.events.emit('noFileSelected');
  }

  openFile(file) {
    const _openFile = file => {
      this.saveCurrentFile();
      const provider = this.fileProviderOf(file);
      if (!provider) return console.error(`no provider for ${file}`);
      file = provider.getPathFromUrl(file) || file; // in case an external URL is given as input, we resolve it to the right internal path

      this._deps.config.set('currentFile', file);

      this.openedFiles[file] = file;
      provider.get(file, (error, content) => {
        if (error) {
          console.log(error);
        } else {
          if (provider.isReadOnly(file)) {
            this.editor.openReadOnly(file, content);
          } else {
            this.editor.open(file, content);
          } // TODO: Only keep `this.emit` (issue#2210)


          this.emit('currentFileChanged', file);
          this.events.emit('currentFileChanged', file);
        }
      });
    };

    if (file) return _openFile(file);else {
      var browserProvider = this._deps.filesProviders['browser'];
      browserProvider.resolveDirectory('browser', (error, filesProvider) => {
        if (error) console.error(error);
        var fileList = Object.keys(filesProvider);

        if (fileList.length) {
          _openFile(browserProvider.type + '/' + fileList[0]);
        } else {
          // TODO: Only keep `this.emit` (issue#2210)
          this.emit('noFileSelected');
          this.events.emit('noFileSelected');
        }
      });
    }
  }

  getProvider(name) {
    return this._deps.filesProviders[name];
  }

  fileProviderOf(file) {
    if (file.indexOf('localhost') === 0) {
      return this._deps.filesProviders['localhost'];
    }

    return this._deps.filesProviders['browser'];
  } // returns the list of directories inside path


  dirList(path) {
    const dirPaths = [];

    const collectList = path => {
      return new Promise((resolve, reject) => {
        this.readdir(path).then(ls => {
          const promises = Object.keys(ls).map((item, index) => {
            const root = path.indexOf('/') === -1 ? path : path.substr(0, path.indexOf('/'));
            const curPath = `${root}/${item}`; // adding 'browser' or 'localhost'

            if (ls[item].isDirectory && !dirPaths.includes(curPath)) {
              dirPaths.push(curPath);
              resolve(dirPaths);
            }

            return new Promise((resolve, reject) => {
              resolve();
            });
          });
          Promise.all(promises).then(() => {
            resolve(dirPaths);
          });
        });
      });
    };

    return collectList(path);
  }

  isRemixDActive() {
    return this.appManager.isActive('remixd');
  }

  saveCurrentFile() {
    var currentFile = this._deps.config.get('currentFile');

    if (currentFile && this.editor.current()) {
      var input = this.editor.get(currentFile);

      if (input) {
        var provider = this.fileProviderOf(currentFile);

        if (provider) {
          provider.set(currentFile, input);
        } else {
          console.log('cannot save ' + currentFile + '. Does not belong to any explorer');
        }
      }
    }
  }

  syncEditor(path) {
    var currentFile = this._deps.config.get('currentFile');

    if (path !== currentFile) return;
    var provider = this.fileProviderOf(currentFile);

    if (provider) {
      provider.get(currentFile, (error, content) => {
        if (error) console.log(error);
        this.editor.setText(content);
      });
    } else {
      console.log('cannot save ' + currentFile + '. Does not belong to any explorer');
    }
  }

  setBatchFiles(filesSet, fileProvider, override, callback) {
    const self = this;
    if (!fileProvider) fileProvider = 'browser';
    if (override === undefined) override = false;

    _async.default.each(Object.keys(filesSet), (file, callback) => {
      if (override) {
        self._deps.filesProviders[fileProvider].set(file, filesSet[file].content);

        self.syncEditor(fileProvider + file);
        return callback();
      }

      helper.createNonClashingName(file, self._deps.filesProviders[fileProvider], (error, name) => {
        if (error) {
          modalDialogCustom.alert('Unexpected error loading the file ' + error);
        } else if (helper.checkSpecialChars(name)) {
          modalDialogCustom.alert('Special characters are not allowed');
        } else {
          self._deps.filesProviders[fileProvider].set(name, filesSet[file].content);

          self.syncEditor(fileProvider + name);
        }

        callback();
      });
    }, error => {
      if (callback) callback(error);
    });
  }

}

module.exports = FileManager;

/***/ }),

/***/ "./app/files/fileProvider.js":
/*!***********************************!*\
  !*** ./app/files/fileProvider.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const CompilerImport = __webpack_require__(/*! ../compiler/compiler-imports */ "./app/compiler/compiler-imports.js");

const EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

const modalDialogCustom = __webpack_require__(/*! ../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

const tooltip = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const Storage = remixLib.Storage;

class FileProvider {
  constructor(name) {
    this.event = new EventManager();
    this.type = name;
    this.providerExternalsStorage = new Storage('providerExternals:');
    this.externalFolders = [this.type + '/swarm', this.type + '/ipfs', this.type + '/github', this.type + '/gists', this.type + '/https'];
  }

  addNormalizedName(path, url) {
    this.providerExternalsStorage.set(this.type + '/' + path, url);
    this.providerExternalsStorage.set('reverse-' + url, this.type + '/' + path);
  }

  removeNormalizedName(path) {
    const value = this.providerExternalsStorage.get(path);
    this.providerExternalsStorage.remove(path);
    this.providerExternalsStorage.remove('reverse-' + value);
  }

  normalizedNameExists(path) {
    return this.providerExternalsStorage.exists(path);
  }

  getNormalizedName(path) {
    return this.providerExternalsStorage.get(path);
  }

  getPathFromUrl(url) {
    return this.providerExternalsStorage.get('reverse-' + url);
  }

  isExternalFolder(path) {
    return this.externalFolders.includes(path);
  }

  discardChanges(path) {
    this.remove(path);
    const compilerImport = new CompilerImport();
    this.providerExternalsStorage.keys().map(value => {
      if (value.indexOf(path) === 0) {
        compilerImport.import(this.getNormalizedName(value), true, loadingMsg => {
          tooltip(loadingMsg);
        }, (error, content, cleanUrl, type, url) => {
          if (error) {
            modalDialogCustom.alert(error);
          } else {
            this.addExternal(type + '/' + cleanUrl, content, url);
          }
        });
      }
    });
  }

  exists(path, cb) {
    // todo check the type (directory/file) as well #2386
    // currently it is not possible to have a file and folder with same path
    return cb(null, this._exists(path));
  }

  _exists(path) {
    var unprefixedpath = this.removePrefix(path);
    return path === this.type ? true : window.remixFileSystem.existsSync(unprefixedpath);
  }

  init(cb) {
    cb();
  }

  get(path, cb) {
    cb = cb || function () {};

    path = this.getPathFromUrl(path) || path; // ensure we actually use the normalized path from here

    var unprefixedpath = this.removePrefix(path);
    var exists = window.remixFileSystem.existsSync(unprefixedpath);
    if (!exists) return cb(null, null);
    window.remixFileSystem.readFile(unprefixedpath, 'utf8', (err, content) => {
      cb(err, content);
    });
  }

  set(path, content, cb) {
    cb = cb || function () {};

    var unprefixedpath = this.removePrefix(path);
    var exists = window.remixFileSystem.existsSync(unprefixedpath);

    if (exists && window.remixFileSystem.readFileSync(unprefixedpath, 'utf8') === content) {
      cb();
      return true;
    }

    if (!exists && unprefixedpath.indexOf('/') !== -1) {
      // the last element is the filename and we should remove it
      this.createDir(path.substr(0, path.lastIndexOf('/')));
    }

    try {
      window.remixFileSystem.writeFileSync(unprefixedpath, content);
    } catch (e) {
      cb(e);
      return false;
    }

    if (!exists) {
      this.event.trigger('fileAdded', [this._normalizePath(unprefixedpath), false]);
    } else {
      this.event.trigger('fileChanged', [this._normalizePath(unprefixedpath)]);
    }

    cb();
    return true;
  }

  createDir(path, cb) {
    const unprefixedpath = this.removePrefix(path);
    const paths = unprefixedpath.split('/');
    if (paths.length && paths[0] === '') paths.shift();
    let currentCheck = '';
    paths.forEach(value => {
      currentCheck = currentCheck + '/' + value;

      if (!window.remixFileSystem.existsSync(currentCheck)) {
        window.remixFileSystem.mkdirSync(currentCheck);
        this.event.trigger('folderAdded', [this._normalizePath(currentCheck)]);
      }
    });
    if (cb) cb();
  } // this will not add a folder as readonly but keep the original url to be able to restore it later


  addExternal(path, content, url) {
    if (url) this.addNormalizedName(path, url);
    return this.set(path, content);
  }

  isReadOnly(path) {
    return false;
  }

  isDirectory(path) {
    const unprefixedpath = this.removePrefix(path);
    return path === this.type ? true : window.remixFileSystem.statSync(unprefixedpath).isDirectory();
  }

  isFile(path) {
    path = this.removePrefix(path);
    return window.remixFileSystem.statSync(path).isFile();
  }
  /**
   * Removes the folder recursively
   * @param {*} path is the folder to be removed
   */


  remove(path) {
    return new Promise((resolve, reject) => {
      path = this.removePrefix(path);

      if (window.remixFileSystem.existsSync(path)) {
        const stat = window.remixFileSystem.statSync(path);

        try {
          if (!stat.isDirectory()) {
            resolve(this.removeFile(path));
          } else {
            const items = window.remixFileSystem.readdirSync(path);

            if (items.length !== 0) {
              items.forEach((item, index) => {
                const curPath = `${path}/${item}`;

                if (window.remixFileSystem.statSync(curPath).isDirectory()) {
                  // delete folder
                  this.remove(curPath);
                } else {
                  // delete file
                  this.removeFile(curPath);
                }
              });
              if (window.remixFileSystem.readdirSync(path).length === 0) window.remixFileSystem.rmdirSync(path, console.log);
            } else {
              // folder is empty
              window.remixFileSystem.rmdirSync(path, console.log);
            }

            this.event.trigger('fileRemoved', [this._normalizePath(path)]);
          }
        } catch (e) {
          console.log(e);
          return resolve(false);
        }
      }

      return resolve(true);
    });
  }

  removeFile(path) {
    path = this.removePrefix(path);

    if (window.remixFileSystem.existsSync(path) && !window.remixFileSystem.statSync(path).isDirectory()) {
      window.remixFileSystem.unlinkSync(path, console.log);
      this.event.trigger('fileRemoved', [this._normalizePath(path)]);
      return true;
    } else return false;
  }

  rename(oldPath, newPath, isFolder) {
    var unprefixedoldPath = this.removePrefix(oldPath);
    var unprefixednewPath = this.removePrefix(newPath);

    if (this._exists(unprefixedoldPath)) {
      window.remixFileSystem.renameSync(unprefixedoldPath, unprefixednewPath);
      this.event.trigger('fileRenamed', [this._normalizePath(unprefixedoldPath), this._normalizePath(unprefixednewPath), isFolder]);
      return true;
    }

    return false;
  }

  resolveDirectory(path, callback) {
    if (!path) return callback(null, {
      [this.type]: {}
    });
    path = this.removePrefix(path);
    if (path.indexOf('/') !== 0) path = '/' + path;
    window.remixFileSystem.readdir(path, (error, files) => {
      var ret = {};

      if (files) {
        files.forEach(element => {
          const absPath = (path === '/' ? '' : path) + '/' + element;
          ret[absPath.indexOf('/') === 0 ? absPath.substr(1, absPath.length) : absPath] = {
            isDirectory: window.remixFileSystem.statSync(absPath).isDirectory()
          }; // ^ ret does not accept path starting with '/'
        });
      }

      callback(error, ret);
    });
  }

  removePrefix(path) {
    path = path.indexOf(this.type) === 0 ? path.replace(this.type, '') : path;
    return path;
  }

  _normalizePath(path) {
    if (path.indexOf('/') !== 0) path = '/' + path;
    return this.type + path;
  }

}

module.exports = FileProvider;

/***/ }),

/***/ "./app/files/remixDProvider.js":
/*!*************************************!*\
  !*** ./app/files/remixDProvider.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

module.exports = class RemixDProvider {
  constructor(appManager) {
    this.event = new EventManager();
    this._appManager = appManager;
    this.type = 'localhost';
    this.error = {
      'EEXIST': 'File already exists'
    };
    this._isReady = false;
    this._readOnlyFiles = {};
    this._readOnlyMode = false;
    this.filesContent = {};
    this.files = {};
  }

  _registerEvent() {
    var remixdEvents = ['connecting', 'connected', 'errored', 'closed'];
    remixdEvents.forEach(value => {
      this._appManager.on('remixd', value, event => {
        this.event.trigger(value, [event]);
      });
    });

    this._appManager.on('remixd', 'folderAdded', path => {
      this.event.trigger('folderAdded', [this.addPrefix(path)]);
    });

    this._appManager.on('remixd', 'fileAdded', path => {
      this.event.trigger('fileAdded', [this.addPrefix(path)]);
    });

    this._appManager.on('remixd', 'fileChanged', path => {
      this.event.trigger('fileChanged', [this.addPrefix(path)]);
    });

    this._appManager.on('remixd', 'fileRemoved', path => {
      this.event.trigger('fileRemoved', [this.addPrefix(path)]);
    });

    this._appManager.on('remixd', 'fileRenamed', (oldPath, newPath) => {
      this.event.trigger('fileRemoved', [this.addPrefix(oldPath), this.addPrefix(newPath)]);
    });
  }

  isConnected() {
    return this._isReady;
  }

  close(cb) {
    this._isReady = false;
    cb();
  }

  init(cb) {
    if (this._isReady) return cb && cb();

    this._appManager.call('remixd', 'folderIsReadOnly', {}).then(result => {
      this._isReady = true;
      this._readOnlyMode = result;

      this._registerEvent();

      cb && cb();
    }).catch(error => {
      cb && cb(error);
    });
  }

  exists(path, cb) {
    if (!this._isReady) return cb && cb('provider not ready');
    const unprefixedpath = this.removePrefix(path);
    return this._appManager.call('remixd', 'exists', {
      path: unprefixedpath
    }).then(result => {
      if (cb) return cb(null, result);
      return result;
    }).catch(error => {
      if (cb) return cb(error);
      throw new Error(error);
    });
  }

  getNormalizedName(path) {
    return path;
  }

  getPathFromUrl(path) {
    return path;
  }

  get(path, cb) {
    if (!this._isReady) return cb && cb('provider not ready');
    var unprefixedpath = this.removePrefix(path);

    this._appManager.call('remixd', 'get', {
      path: unprefixedpath
    }).then(file => {
      this.filesContent[path] = file.content;

      if (file.readonly) {
        this._readOnlyFiles[path] = 1;
      }

      cb(null, file.content);
    }).catch(error => {
      if (error) console.log(error); // display the last known content.
      // TODO should perhaps better warn the user that the file is not synced.

      return cb(null, this.filesContent[path]);
    });
  }

  async set(path, content, cb) {
    if (!this._isReady) return cb && cb('provider not ready');
    const unprefixedpath = this.removePrefix(path);
    return this._appManager.call('remixd', 'set', {
      path: unprefixedpath,
      content: content
    }).then(async result => {
      if (cb) return cb(null, result);
    }).catch(error => {
      if (cb) return cb(error);
      throw new Error(error);
    });
  }

  isReadOnly(path) {
    return this._readOnlyMode || this._readOnlyFiles[path] === 1;
  }

  remove(path) {
    return new Promise((resolve, reject) => {
      if (!this._isReady) return reject('provider not ready');
      const unprefixedpath = this.removePrefix(path);

      this._appManager.call('remixd', 'remove', {
        path: unprefixedpath
      }).then(result => {
        const path = this.type + '/' + unprefixedpath;
        delete this.filesContent[path];
        resolve(true);
        this.init();
      }).catch(error => {
        if (error) console.log(error);
        resolve(false);
      });
    });
  }

  rename(oldPath, newPath, isFolder) {
    const unprefixedoldPath = this.removePrefix(oldPath);
    const unprefixednewPath = this.removePrefix(newPath);
    if (!this._isReady) return new Promise((resolve, reject) => reject('provider not ready'));
    return this._appManager.call('remixd', 'rename', {
      oldPath: unprefixedoldPath,
      newPath: unprefixednewPath
    }).then(result => {
      const newPath = this.type + '/' + unprefixednewPath;
      const oldPath = this.type + '/' + unprefixedoldPath;
      this.filesContent[newPath] = this.filesContent[oldPath];
      delete this.filesContent[oldPath];
      this.init(() => {
        this.event.trigger('fileRenamed', [oldPath, newPath, isFolder]);
      });
      return result;
    }).catch(error => {
      console.log(error);
      if (this.error[error.code]) error = this.error[error.code];
      this.event.trigger('fileRenamedError', [this.error[error.code]]);
    });
  }

  isExternalFolder(path) {
    return false;
  }

  removePrefix(path) {
    path = path.indexOf(this.type) === 0 ? path.replace(this.type, '') : path;
    if (path[0] === '/') return path.substring(1);
    return path;
  }

  addPrefix(path) {
    if (path.indexOf(this.type + '/') === 0) return path;
    if (path[0] === '/') return 'localhost' + path;
    return 'localhost/' + path;
  }

  resolveDirectory(path, callback) {
    var self = this;
    if (path[0] === '/') path = path.substring(1);
    if (!path) return callback(null, {
      [self.type]: {}
    });
    const unprefixedpath = this.removePrefix(path);
    if (!this._isReady) return callback && callback('provider not ready');

    this._appManager.call('remixd', 'resolveDirectory', {
      path: unprefixedpath
    }).then(result => {
      callback(null, result);
    }).catch(callback);
  }

  async isDirectory(path) {
    const unprefixedpath = this.removePrefix(path);
    if (!this._isReady) throw new Error('provider not ready');
    return await this._appManager.call('remixd', 'isDirectory', {
      path: unprefixedpath
    });
  }

  async isFile(path) {
    const unprefixedpath = this.removePrefix(path);
    if (!this._isReady) throw new Error('provider not ready');
    return await this._appManager.call('remixd', 'isFile', {
      path: unprefixedpath
    });
  }

};

/***/ }),

/***/ "./app/files/remixd-handle.js":
/*!************************************!*\
  !*** ./app/files/remixd-handle.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemixdHandle = void 0;

var _isElectron = _interopRequireDefault(__webpack_require__(/*! is-electron */ "../../../node_modules/is-electron/index.js"));

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var modalDialog = __webpack_require__(/*! ../ui/modaldialog */ "./app/ui/modaldialog.js");

var modalDialogCustom = __webpack_require__(/*! ../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .dialog {
    display: flex;
    flex-direction: column;
  }
  .dialogParagraph {
    margin-bottom: 2em;
    word-break: break-word;
  }
`;
const profile = {
  name: 'remixd',
  displayName: 'RemixD',
  url: 'ws://127.0.0.1:65520',
  methods: ['folderIsReadOnly', 'resolveDirectory', 'get', 'exists', 'isFile', 'set', 'rename', 'remove', 'isDirectory', 'list'],
  events: [],
  description: 'Using Remixd daemon, allow to access file system',
  kind: 'other',
  version: packageJson.version
};

class RemixdHandle extends _engine.WebsocketPlugin {
  constructor(fileSystemExplorer, locahostProvider, appManager) {
    super(profile);
    this.fileSystemExplorer = fileSystemExplorer;
    this.locahostProvider = locahostProvider;
    this.appManager = appManager;
  }

  deactivate() {
    this.fileSystemExplorer.hide();
    if (super.socket) super.deactivate();
    this.locahostProvider.close(error => {
      if (error) console.log(error);
    });
  }

  activate() {
    this.fileSystemExplorer.show();
    this.connectToLocalhost();
  }

  async canceled() {
    this.appManager.ensureDeactivated('remixd');
  }
  /**
    * connect to localhost if no connection and render the explorer
    * disconnect from localhost if connected and remove the explorer
    *
    * @param {String} txHash - hash of the transaction
    */


  async connectToLocalhost() {
    let connection = error => {
      if (error) {
        console.log(error);
        modalDialogCustom.alert('Cannot connect to the remixd daemon.' + 'Please make sure you have the remixd running in the background.');
        this.canceled();
      } else {
        const intervalId = setInterval(() => {
          if (!this.socket || this.socket && this.socket.readyState === 3) {
            // 3 means connection closed
            clearInterval(intervalId);
            console.log(error);
            modalDialogCustom.alert('Connection to remixd terminated' + 'Please make sure remixd is still running in the background.');
            this.canceled();
          }
        }, 3000);
        this.locahostProvider.init(_ => this.fileSystemExplorer.ensureRoot());
      }
    };

    if (this.locahostProvider.isConnected()) {
      this.deactivate();
    } else if (!(0, _isElectron.default)()) {
      // warn the user only if he/she is in the browser context
      modalDialog('Connect to localhost', remixdDialog(), {
        label: 'Connect',
        fn: () => {
          try {
            super.activate();
            setTimeout(() => {
              if (!this.socket || this.socket && this.socket.readyState === 3) {
                // 3 means connection closed
                connection(new Error('Connection with daemon failed.'));
              } else {
                connection();
              }
            }, 3000);
          } catch (error) {
            connection(error);
          }
        }
      }, {
        label: 'Cancel',
        fn: () => {
          this.canceled();
        }
      });
    } else {
      try {
        super.activate();
        setTimeout(() => {
          connection();
        }, 2000);
      } catch (error) {
        connection(error);
      }
    }
  }

}

exports.RemixdHandle = RemixdHandle;

function remixdDialog() {
  return yo`
    <div class=${css.dialog}>
      <div class=${css.dialogParagraph}>Interact with your file system from Remix. Click connect and find shared folder in the Remix file explorer (under localhost).
        Before you get started, check out the <a target="_blank" href="https://remix-ide.readthedocs.io/en/latest/remixd.html">Remixd tutorial</a>.
        to find out how to run Remixd.
      </div>
      <div class=${css.dialogParagraph}>If you have looked at that tutorial and are just looking for the remixd command, <br> here it is:
        <br><b>remixd -s absolute-path-to-the-shared-folder --remix-ide your-remix-ide-URL-instance</b>
      </div>
      <div class=${css.dialogParagraph}>Connection will start a session between <em>${window.location.href}</em> and your local file system <i>ws://127.0.0.1:65520</i>
        so please make sure your system is secured enough (port 65520 neither opened nor forwarded).
        <i class="fas fa-link"></i> will show you current connection status.
      </div>
      <div class=${css.dialogParagraph}>This feature is still in Alpha, so we recommend you to keep a copy of the shared folder.</div>
    </div>
  `;
}

/***/ }),

/***/ "./app/files/styles/file-explorer-styles.js":
/*!**************************************************!*\
  !*** ./app/files/styles/file-explorer-styles.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .label {
    margin-top        : 4px;
  }
  .leaf {
    overflow          : hidden;
    text-overflow     : ellipsis;
    width             : 90%;
    margin-bottom     : 0px;
  }
  .fileexplorer       {
    box-sizing        : border-box;
  }
  input[type="file"] {
      display: none;
  }
  .folder,
  .file               {
    font-size         : 14px;
    cursor            : pointer;
  }
  .file               {
    padding           : 4px;
  }
  .newFile            {
    padding-right     : 10px;
  }
  .newFile i          {
    cursor            : pointer;
  }
  .newFile:hover    {
    transform         : scale(1.3);
  }
  .menu               {
    margin-left       : 20px;
  }
  .items              {
    display           : inline
  }
  .hasFocus           {
  }
  .rename             {
  }
  .remove             {
    margin-left       : auto;
    padding-left      : 5px;
    padding-right     : 5px;
  }
  .activeMode         {
    display           : flex;
    width             : 100%;
    margin-right      : 10px;
    padding-right     : 19px;
  }
  .activeMode > div   {
    min-width         : 10px;
  }
  ul                  {
    padding           : 0;
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/panels/file-panel.js":
/*!**********************************!*\
  !*** ./app/panels/file-panel.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var FileExplorer = __webpack_require__(/*! ../files/file-explorer */ "./app/files/file-explorer.js");

var {
  RemixdHandle
} = __webpack_require__(/*! ../files/remixd-handle.js */ "./app/files/remixd-handle.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var css = __webpack_require__(/*! ./styles/file-panel-styles */ "./app/panels/styles/file-panel-styles.js");

var canUpload = window.File || window.FileReader || window.FileList || window.Blob;
/*
  Overview of APIs:
   * fileManager: @args fileProviders (browser, shared-folder, swarm, github, etc ...) & config & editor
      - listen on browser & localhost file provider (`fileRenamed` & `fileRemoved`)
      - update the tabs, switchFile
      - trigger `currentFileChanged`
      - set the current file in the config
   * fileProvider: currently browser, swarm, localhost, github, gist
      - link to backend
      - provide properties `type`, `readonly`
      - provide API `resolveDirectory`, `remove`, `exists`, `rename`, `get`, `set`
      - trigger `fileExternallyChanged`, `fileRemoved`, `fileRenamed`, `fileRenamedError`, `fileAdded`
   * file-explorer: treeview @args fileProvider
      - listen on events triggered by fileProvider
      - call fileProvider API
*/

const profile = {
  name: 'fileExplorers',
  displayName: 'File explorers',
  methods: [],
  events: [],
  icon: 'assets/img/fileManager.webp',
  description: ' - ',
  kind: 'fileexplorer',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/file_explorer.html',
  version: packageJson.version
};
module.exports = class Filepanel extends _engine.ViewPlugin {
  constructor(appManager) {
    super(profile);
    var self = this;
    self._components = {};
    self._components.registry = globalRegistry;
    self._deps = {
      fileProviders: self._components.registry.get('fileproviders').api,
      fileManager: self._components.registry.get('filemanager').api,
      config: self._components.registry.get('config').api
    };

    function createProvider(key, menuItems) {
      return new FileExplorer(self._components.registry, self._deps.fileProviders[key], menuItems);
    }

    var fileExplorer = createProvider('browser', ['createNewFile', 'publishToGist', canUpload ? 'uploadFile' : '']);
    var fileSystemExplorer = createProvider('localhost');
    self.remixdHandle = new RemixdHandle(fileSystemExplorer, self._deps.fileProviders['localhost'], appManager);
    const explorers = yo`
      <div>
        <div class="pl-2 ${css.treeview}" data-id="filePanelFileExplorerTree">${fileExplorer.init()}</div>
        <div class="pl-2 filesystemexplorer ${css.treeview}">${fileSystemExplorer.init()}</div>
      </div>
    `;

    function template() {
      return yo`
        <div class=${css.container}>
          <div class="${css.fileexplorer}">           
            <div class="${css.fileExplorerTree}">
              ${explorers}
            </div>
          </div>
        </div>
      `;
    }

    var event = new EventManager();
    self.event = event;
    var element = template();
    fileExplorer.ensureRoot();

    self._deps.fileProviders['localhost'].event.register('connecting', event => {});

    self._deps.fileProviders['localhost'].event.register('connected', event => {
      fileSystemExplorer.show();
    });

    self._deps.fileProviders['localhost'].event.register('errored', event => {
      fileSystemExplorer.hide();
    });

    self._deps.fileProviders['localhost'].event.register('closed', event => {
      fileSystemExplorer.hide();
    });

    self.render = function render() {
      return element;
    };
  }

};

/***/ }),

/***/ "./app/panels/main-view.js":
/*!*********************************!*\
  !*** ./app/panels/main-view.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MainView = void 0;

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var {
  TabProxy
} = __webpack_require__(/*! ./tab-proxy.js */ "./app/panels/tab-proxy.js");

var ContextView = __webpack_require__(/*! ../editor/contextView */ "./app/editor/contextView.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .mainview            {
    display           : flex;
    flex-direction    : column;
    height            : 100%;
    width             : 100%;
  }
`;

class MainView {
  constructor(contextualListener, editor, mainPanel, fileManager, appManager, terminal) {
    var self = this;
    self.event = new EventManager();
    self._view = {};
    self._components = {};
    self._components.registry = globalRegistry;
    self.editor = editor;
    self.fileManager = fileManager;
    self.mainPanel = mainPanel;
    self.txListener = globalRegistry.get('txlistener').api;
    self._components.terminal = terminal;
    self._components.contextualListener = contextualListener;
    this.appManager = appManager;
    this.init();
  }

  showApp(name) {
    this.fileManager.unselectCurrentFile();
    this.mainPanel.showContent(name);
    this._view.editor.style.display = 'none';

    this._components.contextView.hide();

    this._view.mainPanel.style.display = 'block';
  }

  getAppPanel() {
    return this.mainPanel;
  }

  init() {
    var self = this;
    self._deps = {
      config: self._components.registry.get('config').api,
      fileManager: self._components.registry.get('filemanager').api
    };
    self.tabProxy = new TabProxy(self.fileManager, self.editor, self.appManager);
    /*
      We listen here on event from the tab component to display / hide the editor and mainpanel
      depending on the content that should be displayed
    */

    self.fileManager.events.on('currentFileChanged', file => {
      // we check upstream for "fileChanged"
      self._view.editor.style.display = 'block';
      self._view.mainPanel.style.display = 'none';

      self._components.contextView.show();
    });
    self.tabProxy.event.on('openFile', file => {
      self._view.editor.style.display = 'block';
      self._view.mainPanel.style.display = 'none';

      self._components.contextView.show();
    });
    self.tabProxy.event.on('closeFile', file => {});
    self.tabProxy.event.on('switchApp', self.showApp.bind(self));
    self.tabProxy.event.on('closeApp', name => {
      self._view.editor.style.display = 'block';

      self._components.contextView.show();

      self._view.mainPanel.style.display = 'none';
    });
    self.tabProxy.event.on('tabCountChanged', count => {
      if (!count) this.editor.displayEmptyReadOnlySession();
    });
    self.data = {
      _layout: {
        top: {
          offset: self._terminalTopOffset(),
          show: true
        }
      }
    };
    const contextView = new ContextView({
      contextualListener: self._components.contextualListener,
      editor: self.editor
    });
    self._components.contextView = contextView;

    self._components.terminal.event.register('resize', delta => self._adjustLayout('top', delta));

    if (self.txListener) {
      self._components.terminal.event.register('listenOnNetWork', listenOnNetWork => {
        self.txListener.setListenOnNetwork(listenOnNetWork);
      });
    }
  }

  _terminalTopOffset() {
    return this._deps.config.get('terminal-top-offset') || 150;
  }

  _adjustLayout(direction, delta) {
    var limitUp = 0;
    var limitDown = 32;
    var containerHeight = window.innerHeight - limitUp; // - menu bar containerHeight

    var self = this;
    var layout = self.data._layout[direction];

    if (layout) {
      if (delta === undefined) {
        layout.show = !layout.show;
        if (layout.show) delta = layout.offset;else delta = 0;
      } else {
        layout.show = true;

        self._deps.config.set(`terminal-${direction}-offset`, delta);

        layout.offset = delta;
      }
    }

    var tmp = delta - limitDown;
    delta = tmp > 0 ? tmp : 0;

    if (direction === 'top') {
      var mainPanelHeight = containerHeight - delta;
      mainPanelHeight = mainPanelHeight < 0 ? 0 : mainPanelHeight;
      self._view.editor.style.height = `${mainPanelHeight}px`;
      self._view.mainPanel.style.height = `${mainPanelHeight}px`;
      self._view.terminal.style.height = `${delta}px`; // - menu bar height

      self.editor.resize((document.querySelector('#editorWrap') || {}).checked);

      self._components.terminal.scroll2bottom();
    }
  }

  minimizeTerminal() {
    this._adjustLayout('top');
  }

  showTerminal(offset) {
    this._adjustLayout('top', offset || this._terminalTopOffset());
  }

  getTerminal() {
    return this._components.terminal;
  }

  getEditor() {
    var self = this;
    return self.editor;
  }

  refresh() {
    var self = this;

    self._view.tabs.onmouseenter();
  }

  log(data = {}) {
    var self = this;
    var command = self._components.terminal.commands[data.type];
    if (typeof command === 'function') command(data.value);
  }

  logMessage(msg) {
    var self = this;
    self.log({
      type: 'log',
      value: msg
    });
  }

  logHtmlMessage(msg) {
    var self = this;
    self.log({
      type: 'html',
      value: msg
    });
  }

  render() {
    var self = this;
    if (self._view.mainview) return self._view.mainview;
    self._view.editor = self.editor.render();
    self._view.editor.style.display = 'none';
    self._view.mainPanel = self.mainPanel.render();
    self._view.terminal = self._components.terminal.render();
    self._view.mainview = yo`
      <div class=${css.mainview}>
        ${self.tabProxy.renderTabsbar()}
        ${self._view.editor}
        ${self._view.mainPanel}
        ${self._components.contextView.render()}
        ${self._view.terminal}
      </div>
    `; // INIT

    self._adjustLayout('top', self.data._layout.top.offset);

    document.addEventListener('keydown', e => {
      if (e.altKey && e.keyCode === 84) self.tabProxy.switchNextTab(); // alt + t
    });
    return self._view.mainview;
  }

  registerCommand(name, command, opts) {
    var self = this;
    return self._components.terminal.registerCommand(name, command, opts);
  }

  updateTerminalFilter(filter) {
    this._components.terminal.updateJournal(filter);
  }

}

exports.MainView = MainView;

/***/ }),

/***/ "./app/panels/styles/file-panel-styles.js":
/*!************************************************!*\
  !*** ./app/panels/styles/file-panel-styles.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .container {
    display           : flex;
    flex-direction    : row;
    width             : 100%;
    height            : 100%;
    box-sizing        : border-box;
  }
  .fileexplorer       {
    display           : flex;
    flex-direction    : column;
    position          : relative;
    width             : 100%;
    padding-left      : 6px;
    padding-top       : 6px;
  }
  .fileExplorerTree   {
    cursor            : default;
  }
  .gist            {
    padding           : 10px;
  }
  .gist i          {
    cursor            : pointer;
  }
  .gist i:hover    {
    color             : orange;
  }
  .connectToLocalhost {
    padding           : 10px;
  }
  .connectToLocalhost i {
    cursor            : pointer;
  }
  .connectToLocalhost i:hover   {
    color             : var(--secondary)
  }
  .uploadFile         {
    padding           : 10px;
  }
  .uploadFile label:hover   {
    color             : var(--secondary)
  }
  .uploadFile label   {
    cursor            : pointer;
  }
  .treeview {
    overflow-y        : auto;
  }  
  .dialog {
    display: flex;
    flex-direction: column;
  }
  .dialogParagraph {
    margin-bottom: 2em;
    word-break: break-word;
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/panels/styles/terminal-styles.js":
/*!**********************************************!*\
  !*** ./app/panels/styles/terminal-styles.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .panel              {
    position          : relative;
    display           : flex;
    flex-direction    : column;
    font-size         : 12px;
    min-height        : 3em;
  }
  .bar                {
    display           : flex;
    z-index           : 2;
  }
  .menu               {
    position             : relative;
    display              : flex;
    align-items          : center;
    width                : 100%;
    max-height           : 35px;
    min-height           : 35px;
  }
  .toggleTerminal              {
    cursor            : pointer;
  }
  .toggleTerminal:hover              {
    color             : var(--secondary);
  }
  .terminal_container   {
    display             : flex;
    flex-direction      : column;
    height              : 100%;
    overflow-y          : auto;
    font-family         : monospace;
    margin              : 0px;
    background-repeat   : no-repeat;
    background-position : center 15%;
    background-size     : auto calc(75% -  1.7em);
  }
  .terminal    {
    position          : relative;
    display           : flex;
    flex-direction    : column;
    height            : 100%;
  }
  .journal            {
    margin-top        : auto;
    font-family       : monospace;
  }
  .block              {
    word-break        : break-word;
    white-space       : pre-wrap;
    line-height       : 2ch;
    padding           : 1ch;
    margin-top        : 2ch;
  }
  .cli                {
    line-height       : 1.7em;
    font-family       : monospace;
    padding           : .4em;
    color             : var(--primary)
    border-top        : solid 2px var(--secondary);
  }
  .prompt             {
    margin-right      : 0.5em;
    font-family       : monospace;
    font-weight       : bold;
    font-size         : 14px;
  }
  .input              {
    word-break        : break-word;
    outline           : none;
    font-family       : monospace;
  }
  .search {
    display           : flex;
    align-items       : center;
    width             : 330px;
    padding-left      : 20px;
    height            : 100%;
    padding-top       : 1px;
    padding-bottom    : 1px;
  }
  .filter                       {
    height                      : 80%;
    white-space                 : nowrap;
    overflow                    : hidden;
    text-overflow               : ellipsis;
  }
  .searchIcon                   {
    height                      : 100%;
    width                       : 25px;
    border-top-left-radius      : 3px;
    border-bottom-left-radius   : 3px;
    display                     : flex;
    align-items                 : center;
    justify-content             : center;
    margin-right                : 5px;
  }
  .listen         {
    margin-right  : 30px;
    min-width     : 40px;
    height        : 13px;
    display       : flex;
    align-items   : center;
  }
  .listenLabel {
    min-width: 50px;
  }
  .verticalLine {
    border-left       : 1px solid var(--secondary)
    height            : 65%;
  }
  .dragbarHorizontal  {
    position          : absolute;
    top               : 0;
    height            : 0.5em;
    right             : 0;
    left              : 0;
    cursor            : ns-resize;
    z-index           : 999;
  }
  .listenOnNetwork {
    min-height: auto;
  }
  .ghostbar           {
    position          : absolute;
    height            : 6px;
    opacity           : 0.5;
    cursor            : row-resize;
    z-index           : 9999;
    left              : 0;
    right             : 0;
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/panels/tab-proxy.js":
/*!*********************************!*\
  !*** ./app/panels/tab-proxy.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TabProxy = void 0;

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

const EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

const globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

__webpack_require__(/*! remix-tabs */ "../../../node_modules/remix-tabs/dist/bundle.js");

class TabProxy {
  constructor(fileManager, editor, appManager) {
    this.event = new EventEmitter();
    this.fileManager = fileManager;
    this.appManager = appManager;
    this.editor = editor;
    this.data = {};
    this._view = {};
    this._handlers = {};
    globalRegistry.get('themeModule').api.events.on('themeChanged', theme => {
      // update invert for all icons
      this.updateImgStyles();
    });
    fileManager.events.on('fileRemoved', name => {
      this.removeTab(name);
    });
    fileManager.events.on('fileClosed', name => {
      this.removeTab(name);
    });
    fileManager.events.on('currentFileChanged', file => {
      if (this._handlers[file]) {
        this._view.filetabs.activateTab(file);

        return;
      }

      this.addTab(file, '', () => {
        this.fileManager.open(file);
        this.event.emit('openFile', file);
      }, () => {
        this.fileManager.closeFile(file);
        this.event.emit('closeFile', file);
      });
    });
    fileManager.events.on('fileRenamed', (oldName, newName, isFolder) => {
      if (isFolder) return; // should change the tab title too

      this.addTab(newName, '', () => {
        this.fileManager.open(newName);
        this.event.emit('openFile', newName);
      }, () => {
        this.fileManager.closeFile(newName);
        this.event.emit('closeFile', newName);
      });
      this.removeTab(oldName);
    });
    appManager.event.on('activate', ({
      name,
      location,
      displayName,
      icon
    }) => {
      if (location === 'mainPanel') {
        this.addTab(name, displayName, () => this.event.emit('switchApp', name), () => {
          this.event.emit('closeApp', name);
          this.appManager.deactivatePlugin(name);
        }, icon);
        this.switchTab(name);
      }
    });
    appManager.event.on('deactivate', profile => {
      this.removeTab(profile.name);
    });
    appManager.event.on('ensureActivated', name => {
      if (name === 'home') {
        // if someone force activation of home, we switch to it
        this.event.emit('switchApp', name);

        this._view.filetabs.activateTab(name);
      }
    });
  }

  updateImgStyles() {
    const images = this._view.filetabs.getElementsByClassName('image');

    if (images.length !== 0) {
      for (let element of images) {
        globalRegistry.get('themeModule').api.fixInvert(element);
      }

      ;
    }
  }

  switchTab(tabName) {
    if (this._handlers[tabName]) {
      this._handlers[tabName].switchTo();

      this._view.filetabs.activateTab(tabName);
    }
  }

  switchNextTab() {
    const active = this._view.filetabs.active;

    if (active && this._handlers[active]) {
      const handlers = Object.keys(this._handlers);
      let i = handlers.indexOf(active);

      if (i >= 0) {
        i = handlers[i + 1] ? i + 1 : 0;
        this.switchTab(handlers[i]);
      }
    }
  }

  switchPreviousTab() {
    const active = this._view.filetabs.active;

    if (active && this._handlers[active]) {
      const handlers = Object.keys(this._handlers);
      let i = handlers.indexOf(active);

      if (i >= 0) {
        i = handlers[i - 1] ? i - 1 : handlers.length - 1;
        this.switchTab(handlers[i]);
      }
    }
  }

  switchToActiveTab() {
    const active = this._view.filetabs.active;

    if (active && this._handlers[active]) {
      this.switchTab(active);
    }
  }

  addTab(name, title, switchTo, close, icon) {
    if (this._handlers[name]) return;
    var slash = name.split('/');

    if (!title) {
      title = name.indexOf('/') !== -1 ? slash[slash.length - 1] : name;
    }

    this._view.filetabs.addTab({
      id: name,
      title,
      icon,
      tooltip: name
    });

    this.updateImgStyles();
    this._handlers[name] = {
      switchTo,
      close
    };
  }

  removeTab(name) {
    this._view.filetabs.removeTab(name);

    delete this._handlers[name];
    this.switchToActiveTab();
  }

  addHandler(type, fn) {
    this.handlers[type] = fn;
  }

  onZoomOut() {
    this.editor.editorFontSize(-1);
  }

  onZoomIn() {
    this.editor.editorFontSize(1);
  }

  renderTabsbar() {
    this._view.filetabs = yo`<remix-tabs></remix-tabs>`;

    this._view.filetabs.addEventListener('tabClosed', event => {
      if (this._handlers[event.detail]) this._handlers[event.detail].close();
      this.event.emit('tabCountChanged', this._view.filetabs.tabs.length);
    });

    this._view.filetabs.addEventListener('tabActivated', event => {
      if (this._handlers[event.detail]) this._handlers[event.detail].switchTo();
      this.event.emit('tabCountChanged', this._view.filetabs.tabs.length);
    });

    this._view.filetabs.canAdd = false;
    const zoomBtns = yo`
      <div class="d-flex flex-row justify-content-center align-items-center">
        <span data-id="tabProxyZoomOut" class="btn btn-sm px-1 fas fa-search-minus text-dark" onclick=${() => this.onZoomOut()}></span>
        <span data-id="tabProxyZoomIn" class="btn btn-sm px-1 fas fa-search-plus text-dark" onclick=${() => this.onZoomIn()}></span>
      </div>
    `; // @todo(#2492) remove style after the mainPanel layout fix.

    this._view.tabs = yo`
      <div  style="display: -webkit-box; max-height: 32px">
        ${zoomBtns}
        ${this._view.filetabs}
      </div>
    `; // tabs

    var $filesEl = $(this._view.filetabs); // Switch tab

    var self = this;
    $filesEl.on('click', '.file:not(.active)', function (ev) {
      ev.preventDefault();
      var name = $(this).find('.name').text();

      self._handlers[name].switchTo();

      return false;
    }); // Remove current tab

    $filesEl.on('click', '.file .remove', function (ev) {
      ev.preventDefault();
      var name = $(this).parent().find('.name').text();

      self._handlers[name].close();

      return false;
    });
    return this._view.tabs;
  }

}

exports.TabProxy = TabProxy;

/***/ }),

/***/ "./app/panels/terminal.js":
/*!********************************!*\
  !*** ./app/panels/terminal.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* global Node, requestAnimationFrame */
var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var javascriptserialize = __webpack_require__(/*! javascript-serialize */ "../../../node_modules/javascript-serialize/javascriptserialize.js");

var jsbeautify = __webpack_require__(/*! js-beautify */ "../../../node_modules/js-beautify/js/index.js");

var ethers = __webpack_require__(/*! ethers */ "../../../node_modules/ethers/dist/ethers.min.js");

var type = __webpack_require__(/*! component-type */ "../../../node_modules/component-type/index.js");

var vm = __webpack_require__(/*! vm */ "../../../node_modules/node-libs-browser/node_modules/vm-browserify/index.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

var swarmgw = __webpack_require__(/*! swarmgw */ "../../../node_modules/swarmgw/index.js")();

var CommandInterpreterAPI = __webpack_require__(/*! ../../lib/cmdInterpreterAPI */ "./lib/cmdInterpreterAPI.js");

var AutoCompletePopup = __webpack_require__(/*! ../ui/auto-complete-popup */ "./app/ui/auto-complete-popup.js");

var TxLogger = __webpack_require__(/*! ../../app/ui/txLogger */ "./app/ui/txLogger.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = __webpack_require__(/*! ./styles/terminal-styles */ "./app/panels/styles/terminal-styles.js");

var KONSOLES = [];

function register(api) {
  KONSOLES.push(api);
}

var ghostbar = yo`<div class=${css.ghostbar} bg-secondary></div>`;
const profile = {
  displayName: 'Terminal',
  name: 'terminal',
  methods: [],
  events: [],
  description: ' - ',
  version: packageJson.version
};

class Terminal extends _engine.Plugin {
  constructor(opts, api) {
    super(profile);
    var self = this;
    self.event = new EventManager();
    self.blockchain = opts.blockchain;
    self._api = api;
    self._opts = opts;
    self.data = {
      lineLength: opts.lineLength || 80,
      // ????
      session: [],
      activeFilters: {
        commands: {},
        input: ''
      },
      filterFns: {}
    };
    self._view = {
      el: null,
      bar: null,
      input: null,
      term: null,
      journal: null,
      cli: null
    };
    self._components = {};
    self._components.cmdInterpreter = new CommandInterpreterAPI(this, null, self.blockchain);
    self._components.autoCompletePopup = new AutoCompletePopup(self._opts);

    self._components.autoCompletePopup.event.register('handleSelect', function (input) {
      let textList = self._view.input.innerText.split(' ');

      textList.pop();
      textList.push(input);
      self._view.input.innerText = textList;

      self._view.input.focus();

      self.putCursor2End(self._view.input);
    });

    self._commands = {};
    self.commands = {};
    self._JOURNAL = [];
    self._jobs = [];
    self._INDEX = {};
    self._INDEX.all = [];
    self._INDEX.allMain = [];
    self._INDEX.commands = {};
    self._INDEX.commandsMain = {};
    self.registerCommand('html', self._blocksRenderer('html'), {
      activate: true
    });
    self.registerCommand('log', self._blocksRenderer('log'), {
      activate: true
    });
    self.registerCommand('info', self._blocksRenderer('info'), {
      activate: true
    });
    self.registerCommand('warn', self._blocksRenderer('warn'), {
      activate: true
    });
    self.registerCommand('error', self._blocksRenderer('error'), {
      activate: true
    });
    self.registerCommand('script', function execute(args, scopedCommands, append) {
      var script = String(args[0]);
      scopedCommands.log(`> ${script}`);

      self._shell(script, scopedCommands, function (error, output) {
        if (error) scopedCommands.error(error);else if (output) scopedCommands.log(output);
      });
    }, {
      activate: true
    });

    function basicFilter(value, query) {
      try {
        return value.indexOf(query) !== -1;
      } catch (e) {
        return false;
      }
    }

    self.registerFilter('log', basicFilter);
    self.registerFilter('info', basicFilter);
    self.registerFilter('warn', basicFilter);
    self.registerFilter('error', basicFilter);
    self.registerFilter('script', basicFilter);
    self._jsSandboxContext = {};
    self._jsSandboxRegistered = {};
    if (opts.shell) self._shell = opts.shell; // ???

    register(self);
  }

  onActivation() {
    this.on('scriptRunner', 'log', msg => {
      this.commands['log'].apply(this.commands, msg.data);
    });
    this.on('scriptRunner', 'info', msg => {
      this.commands['info'].apply(this.commands, msg.data);
    });
    this.on('scriptRunner', 'warn', msg => {
      this.commands['warn'].apply(this.commands, msg.data);
    });
    this.on('scriptRunner', 'error', msg => {
      this.commands['error'].apply(this.commands, msg.data);
    });
  }

  onDeactivation() {
    this.off('scriptRunner', 'log');
    this.off('scriptRunner', 'info');
    this.off('scriptRunner', 'warn');
    this.off('scriptRunner', 'error');
  }

  logHtml(html) {
    var command = this.commands['html'];
    if (typeof command === 'function') command(html);
  }

  focus() {
    if (this._view.input) this._view.input.focus();
  }

  render() {
    var self = this;
    if (self._view.el) return self._view.el;
    self._view.journal = yo`<div id="journal" class=${css.journal} data-id="terminalJournal"></div>`;
    self._view.input = yo`
      <span class=${css.input} onload=${() => {
      this.focus();
    }} onpaste=${paste} onkeydown=${change}></span>
    `;

    self._view.input.setAttribute('spellcheck', 'false');

    self._view.input.setAttribute('contenteditable', 'true');

    self._view.input.setAttribute('id', 'terminalCliInput');

    self._view.input.setAttribute('data-id', 'terminalCliInput');

    self._view.input.innerText = '\n';
    self._view.cli = yo`
      <div id="terminalCli" data-id="terminalCli" class="${css.cli}" onclick=${focusinput}>
        <span class=${css.prompt}>${'>'}</span>
        ${self._view.input}
      </div>
    `;
    self._view.icon = yo`
      <i onmouseenter=${hover} onmouseleave=${hover} onmousedown=${minimize}
      class="mx-2 ${css.toggleTerminal} fas fa-angle-double-down" data-id="terminalToggleIcon"></i>`;
    self._view.dragbar = yo`
      <div onmousedown=${mousedown} class=${css.dragbarHorizontal}></div>`;
    self._view.pendingTxCount = yo`<div class="mx-2" title='Pending Transactions'>0</div>`;
    self._view.inputSearch = yo`<input
      spellcheck="false"
      type="text"
      class="border ${css.filter} form-control"
      id="searchInput"
      onkeydown=${filter}
      placeholder="Search with transaction hash or address"
      data-id="terminalInputSearch">
    </input>`;
    self._view.bar = yo`
      <div class="${css.bar}">
        ${self._view.dragbar}
        <div class="${css.menu} border-top border-dark bg-light" data-id="terminalToggleMenu">
          ${self._view.icon}
          <div class="mx-2" id="clearConsole" data-id="terminalClearConsole" onclick=${clear}>
            <i class="fas fa-ban" aria-hidden="true" title="Clear console"
            onmouseenter=${hover} onmouseleave=${hover}></i>
          </div>
          ${self._view.pendingTxCount}
          <div class=${css.verticalLine}></div>
          <div class="mx-2 d-flex pb-1 align-items-center ${css.listenOnNetwork} custom-control custom-checkbox">
            <input
              class="pb-0 form-check-input custom-control-input"
              id="listenNetworkCheck"
              onchange=${listenOnNetwork}
              type="checkbox"
              title="If checked Remix will listen on all transactions mined in the current environment and not only transactions created by you"
            >
            <label
              class="pt-1 form-check-label custom-control-label text-nowrap""
              title="If checked Remix will listen on all transactions mined in the current environment and not only transactions created by you"
              for="listenNetworkCheck"
            >
              listen on network
            </label>
          </div>
          <div class=${css.search}>
            <i class="fas fa-search ${css.searchIcon} bg-light" aria-hidden="true"></i>
            ${self._view.inputSearch}
          </div>
        </div>
      </div>
    `;
    self._view.term = yo`
      <div class="${css.terminal_container}" tabindex="-1" data-id="terminalContainer" onscroll=${throttle(reattach, 10)} onkeydown=${focusinput}>
        ${self._components.autoCompletePopup.render()}
        <div data-id="terminalContainerDisplay" style="
          position: absolute;
          height: 100%;
          width: 100%;
          opacity: 0.1;
          z-index: -1;
        "></div>
        <div class=${css.terminal}>
            ${self._view.journal}
            ${self._view.cli}
        </div>
      </div>
    `;
    self._view.el = yo`
      <div class="${css.panel}" style="height: 180px;">
        ${self._view.bar}
        ${self._view.term}
      </div>
    `;
    setInterval(async () => {
      try {
        self._view.pendingTxCount.innerHTML = await self.call('udapp', 'pendingTransactionsCount');
      } catch (err) {}
    }, 1000);

    function listenOnNetwork(ev) {
      self.event.trigger('listenOnNetWork', [ev.currentTarget.checked]);
    }

    function paste(event) {
      const selection = window.getSelection();
      if (!selection.rangeCount) return false;
      event.preventDefault();
      event.stopPropagation();
      var clipboard = event.clipboardData || window.clipboardData;
      var text = clipboard.getData('text/plain');
      text = text.replace(/[^\x20-\xFF]/gi, ''); // remove non-UTF-8 characters

      var temp = document.createElement('div');
      temp.innerHTML = text;
      var textnode = document.createTextNode(temp.textContent);
      selection.getRangeAt(0).insertNode(textnode);
      selection.empty();
      self.scroll2bottom();
      placeCaretAtEnd(event.currentTarget);
    }

    function placeCaretAtEnd(el) {
      el.focus();
      var range = document.createRange();
      range.selectNodeContents(el);
      range.collapse(false);
      var sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }

    function throttle(fn, wait) {
      var time = Date.now();
      return function debounce() {
        if (time + wait - Date.now() < 0) {
          fn.apply(this, arguments);
          time = Date.now();
        }
      };
    }

    var css2 = csjs`
      .anchor            {
        position         : static;
        border-top       : 2px dotted blue;
        height           : 10px;
      }
      .overlay           {
        position         : absolute;
        width            : 100%;
        display          : flex;
        align-items      : center;
        justify-content  : center;
        bottom           : 0;
        right            : 15px;
        min-height       : 20px;
      }
      .text              {
        z-index          : 2;
        color            : black;
        font-weight      : bold;
        pointer-events   : none;
      }
      .background        {
        z-index          : 1;
        opacity          : 0.8;
        background-color : #a6aeba;
        cursor           : pointer;
      }
      .ul                 {
        padding-left     : 20px;
        padding-bottom   : 5px;
      }
    `;
    var text = yo`<div class="${css2.overlay} ${css2.text}"></div>`;
    var background = yo`<div class="${css2.overlay} ${css2.background}"></div>`;
    var placeholder = yo`<div class=${css2.anchor}>${background}${text}</div>`;
    var inserted = false;
    window.addEventListener('resize', function (event) {
      self.event.trigger('resize', []);
      self.event.trigger('resize', []);
    });

    function focusinput(event) {
      if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.key === 'Down' || event.key === 'ArrowDown' || event.key === 'Up' || event.key === 'ArrowUp' || event.key === 'Left' || event.key === 'ArrowLeft' || event.key === 'Right' || event.key === 'ArrowRight' || event.key === 'Esc' || event.key === 'Escape') return;
      refocus();
    }

    function refocus() {
      self._view.input.focus();

      reattach({
        currentTarget: self._view.term
      });
      delete self.scroll2bottom;
      self.scroll2bottom();
    }

    function reattach(event) {
      var el = event.currentTarget;
      var isBottomed = el.scrollHeight - el.scrollTop - el.clientHeight < 30;

      if (isBottomed) {
        if (inserted) {
          text.innerText = '';
          background.onclick = undefined;
          if (placeholder.parentElement) self._view.journal.removeChild(placeholder);
        }

        inserted = false;
        delete self.scroll2bottom;
      } else {
        if (!inserted) self._view.journal.appendChild(placeholder);
        inserted = true;
        check();

        if (!placeholder.nextElementSibling) {
          placeholder.style.display = 'none';
        } else {
          placeholder.style = '';
        }

        self.scroll2bottom = function () {
          var next = placeholder.nextElementSibling;

          if (next) {
            placeholder.style = '';
            check();
            var messages = 1;

            while (next = next.nextElementSibling) messages += 1;

            text.innerText = `${messages} new unread log entries`;
          } else {
            placeholder.style.display = 'none';
          }
        };
      }
    }

    function check() {
      var pos1 = self._view.term.offsetHeight + self._view.term.scrollTop - self._view.el.offsetHeight * 0.15;
      var pos2 = placeholder.offsetTop;

      if (pos1 - pos2 > 0) {
        text.style.display = 'none';
        background.style.position = 'relative';
        background.style.opacity = 0.3;
        background.style.right = 0;
        background.style.borderBox = 'content-box';
        background.style.padding = '2px';
        background.style.height = self._view.journal.offsetHeight - (placeholder.offsetTop + placeholder.offsetHeight) + 'px';
        background.onclick = undefined;
        background.style.cursor = 'default';
        background.style.pointerEvents = 'none';
      } else {
        background.style = '';
        text.style = '';

        background.onclick = function (event) {
          placeholder.scrollIntoView();
          check();
        };
      }
    }

    function hover(event) {
      event.currentTarget.classList.toggle(css.hover);
    }

    function minimize(event) {
      event.preventDefault();
      event.stopPropagation();

      if (event.button === 0) {
        var classList = self._view.icon.classList;
        classList.toggle('fa-angle-double-down');
        classList.toggle('fa-angle-double-up');
        self.event.trigger('resize', []);
      }
    }

    var filtertimeout = null;

    function filter(event) {
      if (filtertimeout) {
        clearTimeout(filtertimeout);
      }

      filtertimeout = setTimeout(() => {
        self.updateJournal({
          type: 'search',
          value: self._view.inputSearch.value
        });
        self.scroll2bottom();
      }, 500);
    }

    function clear(event) {
      refocus();
      self._view.journal.innerHTML = '';
    } // ----------------- resizeable ui ---------------


    function mousedown(event) {
      event.preventDefault();

      if (event.which === 1) {
        moveGhostbar(event);
        document.body.appendChild(ghostbar);
        document.addEventListener('mousemove', moveGhostbar);
        document.addEventListener('mouseup', removeGhostbar);
        document.addEventListener('keydown', cancelGhostbar);
      }
    }

    function cancelGhostbar(event) {
      if (event.keyCode === 27) {
        document.body.removeChild(ghostbar);
        document.removeEventListener('mousemove', moveGhostbar);
        document.removeEventListener('mouseup', removeGhostbar);
        document.removeEventListener('keydown', cancelGhostbar);
      }
    }

    function moveGhostbar(event) {
      // @NOTE HORIZONTAL ghostbar
      ghostbar.style.top = self._api.getPosition(event) + 'px';
    }

    function removeGhostbar(event) {
      if (self._view.icon.classList.contains('fa-angle-double-up')) {
        self._view.icon.classList.toggle('fa-angle-double-down');

        self._view.icon.classList.toggle('fa-angle-double-up');
      }

      document.body.removeChild(ghostbar);
      document.removeEventListener('mousemove', moveGhostbar);
      document.removeEventListener('mouseup', removeGhostbar);
      document.removeEventListener('keydown', cancelGhostbar);
      self.event.trigger('resize', [self._api.getPosition(event)]);
    }

    self._cmdHistory = [];
    self._cmdIndex = -1;
    self._cmdTemp = '';
    var intro = yo`
      <div><div> - Welcome to Remix ${packageJson.version} - </div><br>
      <div>You can use this terminal for: </div>
      <ul class=${css2.ul}>
        <li>Checking transactions details and start debugging.</li>
        <li>Running JavaScript scripts. The following libraries are accessible:
          <ul class=${css2.ul}>
            <li><a target="_blank" href="https://web3js.readthedocs.io/en/1.0/">web3 version 1.0.0</a></li>
            <li><a target="_blank" href="https://docs.ethers.io/ethers.js/html/">ethers.js</a> </li>
            <li><a target="_blank" href="https://www.npmjs.com/package/swarmgw">swarmgw</a> </li>
            <li>remix (run remix.help() for more info)</li>
          </ul>
        </li>
        <li>Executing common command to interact with the Remix interface (see list of commands above). Note that these commands can also be included and run from a JavaScript script.</li>
        <li>Use exports/.register(key, obj)/.remove(key)/.clear() to register and reuse object across script executions.</li>
      </ul>
      </div>
    `;

    self._shell('remix.help()', self.commands, () => {});

    self.commands.html(intro);
    self._components.txLogger = new TxLogger(this, self.blockchain);

    self._components.txLogger.event.register('debuggingRequested', async hash => {
      // TODO should probably be in the run module
      if (!(await self._opts.appManager.isActive('debugger'))) await self._opts.appManager.activatePlugin('debugger');
      this.call('debugger', 'debug', hash);
      this.call('menuicons', 'select', 'debugger');
    });

    return self._view.el;

    function change(event) {
      if (self._components.autoCompletePopup.handleAutoComplete(event, self._view.input.innerText)) return;
      if (self._view.input.innerText.length === 0) self._view.input.innerText += '\n';

      if (event.which === 13) {
        if (event.ctrlKey) {
          // <ctrl+enter>
          self._view.input.innerText += '\n';
          self.putCursor2End(self._view.input);
          self.scroll2bottom();

          self._components.autoCompletePopup.removeAutoComplete();
        } else {
          // <enter>
          self._cmdIndex = -1;
          self._cmdTemp = '';
          event.preventDefault();

          var script = self._view.input.innerText.trim();

          self._view.input.innerText = '\n';

          if (script.length) {
            self._cmdHistory.unshift(script);

            self.commands.script(script);
          }

          self._components.autoCompletePopup.removeAutoComplete();
        }
      } else if (event.which === 38) {
        // <arrowUp>
        var len = self._cmdHistory.length;
        if (len === 0) return event.preventDefault();

        if (self._cmdHistory.length - 1 > self._cmdIndex) {
          self._cmdIndex++;
        }

        self._view.input.innerText = self._cmdHistory[self._cmdIndex];
        self.putCursor2End(self._view.input);
        self.scroll2bottom();
      } else if (event.which === 40) {
        // <arrowDown>
        if (self._cmdIndex > -1) {
          self._cmdIndex--;
        }

        self._view.input.innerText = self._cmdIndex >= 0 ? self._cmdHistory[self._cmdIndex] : self._cmdTemp;
        self.putCursor2End(self._view.input);
        self.scroll2bottom();
      } else {
        self._cmdTemp = self._view.input.innerText;
      }
    }
  }

  putCursor2End(editable) {
    var range = document.createRange();
    range.selectNode(editable);
    var child = editable;
    var chars;

    while (child) {
      if (child.lastChild) child = child.lastChild;else break;

      if (child.nodeType === Node.TEXT_NODE) {
        chars = child.textContent.length;
      } else {
        chars = child.innerHTML.length;
      }
    }

    range.setEnd(child, chars);
    var toStart = true;
    var toEnd = !toStart;
    range.collapse(toEnd);
    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
    editable.focus();
  }

  updateJournal(filterEvent) {
    var self = this;
    var commands = self.data.activeFilters.commands;
    var value = filterEvent.value;

    if (filterEvent.type === 'select') {
      commands[value] = true;
      if (!self._INDEX.commandsMain[value]) return;

      self._INDEX.commandsMain[value].forEach(item => {
        item.root.steps.forEach(item => {
          self._JOURNAL[item.gidx] = item;
        });
        self._JOURNAL[item.gidx] = item;
      });
    } else if (filterEvent.type === 'deselect') {
      commands[value] = false;
      if (!self._INDEX.commandsMain[value]) return;

      self._INDEX.commandsMain[value].forEach(item => {
        item.root.steps.forEach(item => {
          self._JOURNAL[item.gidx].hide = true;
        });
        self._JOURNAL[item.gidx].hide = true;
      });
    } else if (filterEvent.type === 'search') {
      if (value !== self.data.activeFilters.input) {
        var query = self.data.activeFilters.input = value;
        var items = self._JOURNAL;

        for (var gidx = 0, len = items.length; gidx < len; gidx++) {
          var item = items[gidx];

          if (item && self.data.filterFns[item.cmd]) {
            var show = query.length ? self.data.filterFns[item.cmd](item.args, query) : true;
            item.hide = !show;
          }
        }
      }
    }

    var df = document.createDocumentFragment();

    self._JOURNAL.forEach(item => {
      if (item && item.el && !item.hide) df.appendChild(item.el);
    });

    self._view.journal.innerHTML = '';
    requestAnimationFrame(function updateDOM() {
      self._view.journal.appendChild(df);
    });
  }

  _appendItem(item) {
    var self = this;
    var {
      el,
      gidx
    } = item;
    self._JOURNAL[gidx] = item;

    if (!self._jobs.length) {
      requestAnimationFrame(function updateTerminal() {
        self._jobs.forEach(el => self._view.journal.appendChild(el));

        self.scroll2bottom();
        self._jobs = [];
      });
    }

    if (self.data.activeFilters.commands[item.cmd]) self._jobs.push(el);
  }

  scroll2bottom() {
    var self = this;
    setTimeout(function () {
      self._view.term.scrollTop = self._view.term.scrollHeight;
    }, 0);
  }

  _blocksRenderer(mode) {
    if (mode === 'html') {
      return function logger(args, scopedCommands, append) {
        if (args.length) append(args[0]);
      };
    }

    mode = {
      log: 'text-info',
      info: 'text-info',
      warn: 'text-warning',
      error: 'text-danger'
    }[mode]; // defaults

    if (mode) {
      return function logger(args, scopedCommands, append) {
        var types = args.map(type);
        var values = javascriptserialize.apply(null, args).map(function (val, idx) {
          if (typeof args[idx] === 'string') val = args[idx];
          if (types[idx] === 'element') val = jsbeautify.html(val);
          return val;
        });
        append(yo`<span class="${mode}" >${values}</span>`);
      };
    } else {
      throw new Error('mode is not supported');
    }
  }

  _scopeCommands(append) {
    var self = this;
    var scopedCommands = {};
    Object.keys(self.commands).forEach(function makeScopedCommand(cmd) {
      var command = self._commands[cmd];

      scopedCommands[cmd] = function _command() {
        var args = [...arguments];
        command(args, scopedCommands, el => append(cmd, args, blockify(el)));
      };
    });
    return scopedCommands;
  }

  registerFilter(commandName, filterFn) {
    this.data.filterFns[commandName] = filterFn;
  }

  registerCommand(name, command, opts) {
    var self = this;
    name = String(name);
    if (self._commands[name]) throw new Error(`command "${name}" exists already`);
    if (typeof command !== 'function') throw new Error(`invalid command: ${command}`);
    self._commands[name] = command;
    self._INDEX.commands[name] = [];
    self._INDEX.commandsMain[name] = [];

    self.commands[name] = function _command() {
      var args = [...arguments];
      var steps = [];
      var root = {
        steps,
        cmd: name
      };
      var ITEM = {
        root,
        cmd: name
      };
      root.gidx = self._INDEX.allMain.push(ITEM) - 1;
      root.idx = self._INDEX.commandsMain[name].push(ITEM) - 1;

      function append(cmd, params, el) {
        var item;

        if (cmd) {
          // subcommand
          item = {
            el,
            cmd,
            root
          };
        } else {
          // command
          item = ITEM;
          item.el = el;
          cmd = name;
        }

        item.gidx = self._INDEX.all.push(item) - 1;
        item.idx = self._INDEX.commands[cmd].push(item) - 1;
        item.step = steps.push(item) - 1;
        item.args = params;

        self._appendItem(item);
      }

      var scopedCommands = self._scopeCommands(append);

      command(args, scopedCommands, el => append(null, args, blockify(el)));
    };

    var help = typeof command.help === 'string' ? command.help : ['// no help available for:', `terminal.commands.${name}(...)`].join('\n');

    self.commands[name].toString = _ => {
      return help;
    };

    self.commands[name].help = help;
    self.data.activeFilters.commands[name] = opts && opts.activate;

    if (opts.filterFn) {
      self.registerFilter(name, opts.filterFn);
    }

    return self.commands[name];
  }

  async _shell(script, scopedCommands, done) {
    // default shell
    if (script.indexOf('remix:') === 0) {
      return done(null, 'This type of command has been deprecated and is not functionning anymore. Please run remix.help() to list available commands.');
    }

    var self = this;

    if (script.indexOf('remix.') === 0) {
      // we keep the old feature. This will basically only be called when the command is querying the "remix" object.
      // for all the other case, we use the Code Executor plugin
      var context = domTerminalFeatures(self, scopedCommands, self.blockchain);

      try {
        var cmds = vm.createContext(Object.assign(self._jsSandboxContext, context, self._jsSandboxRegistered));
        var result = vm.runInContext(script, cmds);
        self._jsSandboxContext = Object.assign(cmds, context);
        return done(null, result);
      } catch (error) {
        return done(error.message);
      }
    }

    try {
      await this.call('scriptRunner', 'execute', script);
      done();
    } catch (error) {
      done(error.message);
    }
  }

}

function domTerminalFeatures(self, scopedCommands, blockchain) {
  return {
    swarmgw,
    ethers,
    remix: self._components.cmdInterpreter,
    web3: new Web3(blockchain.web3().currentProvider),
    console: {
      log: function () {
        scopedCommands.log.apply(scopedCommands, arguments);
      },
      info: function () {
        scopedCommands.info.apply(scopedCommands, arguments);
      },
      warn: function () {
        scopedCommands.warn.apply(scopedCommands, arguments);
      },
      error: function () {
        scopedCommands.error.apply(scopedCommands, arguments);
      }
    },
    setTimeout: (fn, time) => {
      return setTimeout(() => {
        self._shell('(' + fn.toString() + ')()', scopedCommands, () => {});
      }, time);
    },
    setInterval: (fn, time) => {
      return setInterval(() => {
        self._shell('(' + fn.toString() + ')()', scopedCommands, () => {});
      }, time);
    },
    clearTimeout: clearTimeout,
    clearInterval: clearInterval,
    exports: {
      register: (key, obj) => {
        self._jsSandboxRegistered[key] = obj;
      },
      remove: key => {
        delete self._jsSandboxRegistered[key];
      },
      clear: () => {
        self._jsSandboxRegistered = {};
      }
    }
  };
}

function blockify(el) {
  return yo`<div class="px-4 ${css.block}" data-id="block_${el.getAttribute ? el.getAttribute('id') : ''}">${el}</div>`;
}

module.exports = Terminal;

/***/ }),

/***/ "./app/tabs/analysis-tab.js":
/*!**********************************!*\
  !*** ./app/tabs/analysis-tab.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var _events = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var StaticAnalysis = __webpack_require__(/*! ./staticanalysis/staticAnalysisView */ "./app/tabs/staticanalysis/staticAnalysisView.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

const profile = {
  name: 'solidityStaticAnalysis',
  displayName: 'Solidity static analysis',
  methods: [],
  events: [],
  icon: 'assets/img/staticAnalysis.webp',
  description: 'Checks the contract code for security vulnerabilities and bad practices.',
  kind: 'analysis',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/static_analysis.html',
  version: packageJson.version
};

class AnalysisTab extends _engine.ViewPlugin {
  constructor(registry) {
    super(profile);
    this.event = new EventManager();
    this.events = new _events.EventEmitter();
    this.registry = registry;
  }

  render() {
    if (!this.staticanalysis) this.staticanalysis = new StaticAnalysis(this.registry, this);
    this.staticanalysis.event.register('staticAnaysisWarning', count => {
      if (count > 0) {
        this.emit('statusChanged', {
          key: count,
          title: `${count} warning${count === 1 ? '' : 's'}`,
          type: 'warning'
        });
      } else if (count === 0) {
        this.emit('statusChanged', {
          key: 'succeed',
          title: 'no warning',
          type: 'success'
        });
      } else {
        // count ==-1 no compilation result
        this.emit('statusChanged', {
          key: 'none'
        });
      }
    });
    this.registry.put({
      api: this.staticanalysis,
      name: 'staticanalysis'
    });
    return yo`<div class="px-3 pb-1" id="staticanalysisView">${this.staticanalysis.render()}</div>`;
  }

}

module.exports = AnalysisTab;

/***/ }),

/***/ "./app/tabs/compile-tab.js":
/*!*********************************!*\
  !*** ./app/tabs/compile-tab.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _publishToStorage = _interopRequireDefault(__webpack_require__(/*! ../../publishToStorage */ "./publishToStorage.js"));

var _compilerHelpers = __webpack_require__(/*! ../compiler/compiler-helpers */ "./app/compiler/compiler-helpers.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* global */
const EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

const $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const copy = __webpack_require__(/*! copy-text-to-clipboard */ "../../../node_modules/copy-text-to-clipboard/index.js");

var QueryParams = __webpack_require__(/*! ../../lib/query-params */ "./lib/query-params.js");

const TreeView = __webpack_require__(/*! ../ui/TreeView */ "./app/ui/TreeView.js");

const modalDialog = __webpack_require__(/*! ../ui/modaldialog */ "./app/ui/modaldialog.js");

const copyToClipboard = __webpack_require__(/*! ../ui/copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

const modalDialogCustom = __webpack_require__(/*! ../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

const parseContracts = __webpack_require__(/*! ./compileTab/contractParser */ "./app/tabs/compileTab/contractParser.js");

const addTooltip = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

const globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var css = __webpack_require__(/*! ./styles/compile-tab-styles */ "./app/tabs/styles/compile-tab-styles.js");

const CompileTabLogic = __webpack_require__(/*! ./compileTab/compileTab.js */ "./app/tabs/compileTab/compileTab.js");

const CompilerContainer = __webpack_require__(/*! ./compileTab/compilerContainer.js */ "./app/tabs/compileTab/compilerContainer.js");

const profile = {
  name: 'solidity',
  displayName: 'Solidity compiler',
  icon: 'assets/img/solidity.webp',
  description: 'Compile solidity contracts',
  kind: 'compiler',
  permission: true,
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/solidity_editor.html',
  version: packageJson.version,
  methods: ['getCompilationResult', 'compile', 'compileWithParameters', 'setCompilerConfig']
}; // EditorApi:
// - events: ['compilationFinished'],
// - methods: ['getCompilationResult']

class CompileTab extends _engine.ViewPlugin {
  constructor(editor, config, renderer, fileProvider, fileManager) {
    super(profile);
    this.events = new EventEmitter();
    this._view = {
      el: null,
      warnCompilationSlow: null,
      errorContainer: null,
      contractEl: null
    };
    this.queryParams = new QueryParams();
    this.fileProvider = fileProvider; // dependencies

    this.editor = editor;
    this.config = config;
    this.renderer = renderer;
    this.fileManager = fileManager;
    this.data = {
      contractsDetails: {},
      eventHandlers: {},
      loading: false
    };
  }

  onActivationInternal() {
    this.compileTabLogic = new CompileTabLogic(this.queryParams, this.fileManager, this.editor, this.config, this.fileProvider);
    this.compiler = this.compileTabLogic.compiler;
    this.compileTabLogic.init();
    this.compilerContainer = new CompilerContainer(this.compileTabLogic, this.editor, this.config, this.queryParams);
  }
  /************
   * EVENTS
   */


  listenToEvents() {
    this.data.eventHandlers.onContentChanged = () => {
      this.emit('statusChanged', {
        key: 'edited',
        title: 'the content has changed, needs recompilation',
        type: 'info'
      });
    };

    this.editor.event.register('contentChanged', this.data.eventHandlers.onContentChanged);

    this.data.eventHandlers.onLoadingCompiler = () => {
      this.data.loading = true;
      this.emit('statusChanged', {
        key: 'loading',
        title: 'loading compiler...',
        type: 'info'
      });
    };

    this.compiler.event.register('loadingCompiler', this.data.eventHandlers.onLoadingCompiler);

    this.data.eventHandlers.onCompilerLoaded = () => {
      this.data.loading = false;
      this.emit('statusChanged', {
        key: 'none'
      });
    };

    this.compiler.event.register('compilerLoaded', this.data.eventHandlers.onCompilerLoaded);

    this.data.eventHandlers.onStartingCompilation = () => {
      if (this._view.errorContainer) {
        this._view.errorContainer.innerHTML = '';
      }

      this.emit('statusChanged', {
        key: 'loading',
        title: 'compiling...',
        type: 'info'
      });
    };

    this.compileTabLogic.event.on('startingCompilation', this.data.eventHandlers.onStartingCompilation);

    this.data.eventHandlers.onCurrentFileChanged = name => {
      this.compilerContainer.currentFile = name;
    };

    this.fileManager.events.on('currentFileChanged', this.data.eventHandlers.onCurrentFileChanged);

    this.data.eventHandlers.onNoFileSelected = () => {
      this.compilerContainer.currentFile = '';
    };

    this.fileManager.events.on('noFileSelected', this.data.eventHandlers.onNoFileSelected);

    this.data.eventHandlers.onCompilationFinished = (success, data, source) => {
      this._view.errorContainer.appendChild(yo`<span data-id="compilationFinishedWith_${this.getCurrentVersion()}"></span>`);

      if (success) {
        // forwarding the event to the appManager infra
        this.emit('compilationFinished', source.target, source, 'soljson', data);

        if (data.errors && data.errors.length > 0) {
          this.emit('statusChanged', {
            key: data.errors.length,
            title: `compilation finished successful with warning${data.errors.length > 1 ? 's' : ''}`,
            type: 'warning'
          });
        } else this.emit('statusChanged', {
          key: 'succeed',
          title: 'compilation successful',
          type: 'success'
        }); // Store the contracts


        this.data.contractsDetails = {};
        this.compiler.visitContracts(contract => {
          this.data.contractsDetails[contract.name] = parseContracts(contract.name, contract.object, this.compiler.getSource(contract.file));
        });
      } else {
        const count = data.errors ? data.errors.filter(error => error.severity === 'error').length : 0 + data.error ? 1 : 0;
        this.emit('statusChanged', {
          key: count,
          title: `compilation failed with ${count} error${count.length > 1 ? 's' : ''}`,
          type: 'error'
        });
      } // Update contract Selection


      let contractMap = {};
      if (success) this.compiler.visitContracts(contract => {
        contractMap[contract.name] = contract;
      });
      let contractSelection = this.contractSelection(contractMap);
      yo.update(this._view.contractSelection, contractSelection);

      if (data['error']) {
        this.renderer.error(data['error'].formattedMessage || data['error'], this._view.errorContainer, {
          type: data['error'].severity || 'error'
        });

        if (data['error'].mode === 'panic') {
          return modalDialogCustom.alert(yo`
            <div><i class="fas fa-exclamation-circle ${css.panicError}" aria-hidden="true"></i>
            The compiler returned with the following internal error: <br> <b>${data['error'].formattedMessage}.<br>
            The compiler might be in a non-sane state, please be careful and do not use further compilation data to deploy to mainnet.
            It is heavily recommended to use another browser not affected by this issue (Firefox is known to not be affected).</b><br>
            Please join <a href="https://gitter.im/ethereum/remix" target="blank" >remix gitter channel</a> for more information.</div>`);
        }
      }

      if (data.errors && data.errors.length) {
        data.errors.forEach(err => {
          if (this.config.get('hideWarnings')) {
            if (err.severity !== 'warning') {
              this.renderer.error(err.formattedMessage, this._view.errorContainer, {
                type: err.severity
              });
            }
          } else {
            this.renderer.error(err.formattedMessage, this._view.errorContainer, {
              type: err.severity
            });
          }
        });
      }
    };

    this.compiler.event.register('compilationFinished', this.data.eventHandlers.onCompilationFinished);

    this.data.eventHandlers.onThemeChanged = theme => {
      const invert = theme.quality === 'dark' ? 1 : 0;
      const img = document.getElementById('swarmLogo');

      if (img) {
        img.style.filter = `invert(${invert})`;
      }
    };

    globalRegistry.get('themeModule').api.events.on('themeChanged', this.data.eventHandlers.onThemeChanged); // Run the compiler instead of trying to save the website

    $(window).keydown(e => {
      // ctrl+s or command+s
      if ((e.metaKey || e.ctrlKey) && e.keyCode === 83) {
        e.preventDefault();
        this.compileTabLogic.runCompiler();
      }
    });
  }

  getCompilationResult() {
    return this.compileTabLogic.compiler.state.lastCompilationResult;
  }
  /**
   * compile using @arg fileName.
   * The module UI will be updated accordingly to the new compilation result.
   * This function is used by remix-plugin compiler API.
   * @param {string} fileName to compile
   */


  compile(fileName) {
    addTooltip(yo`<div><b>${this.currentRequest.from}</b> is requiring to compile <b>${fileName}</b></div>`);
    return this.compileTabLogic.compileFile(fileName);
  }
  /**
  * compile using @arg compilationTargets and @arg settings
  * The module UI will *not* be updated, the compilation result is returned
  * This function is used by remix-plugin compiler API.
  * @param {object} map of source files.
  * @param {object} settings {evmVersion, optimize, version, language}
  */


  async compileWithParameters(compilationTargets, settings) {
    return await (0, _compilerHelpers.compile)(compilationTargets, settings);
  } // This function is used for passing the compiler remix-tests


  getCurrentVersion() {
    return this.compilerContainer.data.selectedVersion;
  } // This function is used for passing the compiler configuration to 'remix-tests'


  getCurrentCompilerConfig() {
    return {
      currentVersion: this.compilerContainer.data.selectedVersion,
      evmVersion: this.compileTabLogic.evmVersion,
      optimize: this.compileTabLogic.optimize
    };
  }
  /**
   * set the compiler configuration
   * This function is used by remix-plugin compiler API.
   * @param {object} settings {evmVersion, optimize, version, language}
   */


  setCompilerConfig(settings) {
    return new Promise((resolve, reject) => {
      addTooltip(yo`<div><b>${this.currentRequest.from}</b> is updating the <b>Solidity compiler configuration</b>.<pre class="text-left">${JSON.stringify(settings, null, '\t')}</pre></div>`);
      this.compilerContainer.setConfiguration(settings); // @todo(#2875) should use loading compiler return value to check whether the compiler is loaded instead of "setInterval"

      let timeout = 0;
      const id = setInterval(() => {
        timeout++;
        console.log(this.data.loading);

        if (!this.data.loading || timeout > 10) {
          resolve();
          clearInterval(id);
        }
      }, 200);
    });
  }
  /*********
   * SUB-COMPONENTS
   */

  /**
   * Section to select the compiled contract
   * @param {string[]} contractList Names of the compiled contracts
   */


  contractSelection(contractMap) {
    // Return the file name of a path: ex "browser/ballot.sol" -> "ballot.sol"
    const getFileName = path => {
      const part = path.split('/');
      return part[part.length - 1];
    };

    const contractList = contractMap ? Object.keys(contractMap).map(key => ({
      name: key,
      file: getFileName(contractMap[key].file)
    })) : [];
    let selectEl = yo`
      <select
        onchange="${e => this.selectContract(e.target.value)}"
        data-id="compiledContracts" id="compiledContracts" class="custom-select"
      >
        ${contractList.map(({
      name,
      file
    }) => yo`<option value="${name}">${name} (${file})</option>`)}
      </select>
    `; // define swarm logo

    let result = contractList.length ? yo`<section class="${css.compilerSection} pt-3">
      <!-- Select Compiler Version -->
      <div class="mb-3">
        <label class="${css.compilerLabel} form-check-label" for="compiledContracts">Contract</label>
        ${selectEl}
      </div>
      <article class="mt-2 pb-0">
        <button id="publishOnSwarm" class="btn btn-secondary btn-block" title="Publish on Swarm" onclick="${() => {
      (0, _publishToStorage.default)('swarm', this.fileProvider, this.fileManager, this.data.contractsDetails[this.selectedContract]);
    }}">
          <span>Publish on Swarm</span>
          <img id="swarmLogo" class="${css.storageLogo} ml-2" src="assets/img/swarm.webp">
        </button>
        <button id="publishOnIpfs" class="btn btn-secondary btn-block" title="Publish on Ipfs" onclick="${() => {
      (0, _publishToStorage.default)('ipfs', this.fileProvider, this.fileManager, this.data.contractsDetails[this.selectedContract]);
    }}">
        <span>Publish on Ipfs</span>
        <img id="ipfsLogo" class="${css.storageLogo} ml-2" src="assets/img/ipfs.webp">
      </button>
        <button data-id="compilation-details" class="btn btn-secondary btn-block" title="Display Contract Details" onclick="${() => {
      this.details();
    }}">
          Compilation Details
        </button>
        <!-- Copy to Clipboard -->
        <div class="${css.contractHelperButtons}">
          <div class="input-group">
            <div class="btn-group" role="group" aria-label="Copy to Clipboard">
              <button class="btn ${css.copyButton}" title="Copy ABI to clipboard" onclick="${() => {
      this.copyABI();
    }}">
                <i class="${css.copyIcon} far fa-copy" aria-hidden="true"></i>
                <span>ABI</span>
              </button>
              <button class="btn ${css.copyButton}" title="Copy Bytecode to clipboard" onclick="${() => {
      this.copyBytecode();
    }}">
                <i class="${css.copyIcon} far fa-copy" aria-hidden="true"></i>
                <span>Bytecode</span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </section>` : yo`<section class="${css.container} clearfix"><article class="px-2 mt-2 pb-0 d-flex">
      <span class="mt-2 mx-3 w-100 alert alert-warning" role="alert">No Contract Compiled Yet</span>
    </article></section>`;

    if (contractList.length) {
      this.selectedContract = selectEl.value;
    } else {
      delete this.selectedContract;
    }

    return result;
  } // TODO : Add success alert when compilation succeed


  contractCompiledSuccess() {
    return yo`<div></div>`;
  } // TODO : Add error alert when compilation failed


  contractCompiledError() {
    return yo`<div></div>`;
  }
  /************
   * METHODS
   */


  selectContract(contractName) {
    this.selectedContract = contractName;
  }

  details() {
    const help = {
      'Assembly': 'Assembly opcodes describing the contract including corresponding solidity source code',
      'Opcodes': 'Assembly opcodes describing the contract',
      'Runtime Bytecode': 'Bytecode storing the state and being executed during normal contract call',
      'bytecode': 'Bytecode being executed during contract creation',
      'functionHashes': 'List of declared function and their corresponding hash',
      'gasEstimates': 'Gas estimation for each function call',
      'metadata': 'Contains all informations related to the compilation',
      'metadataHash': 'Hash representing all metadata information',
      'abi': 'ABI: describing all the functions (input/output params, scope, ...)',
      'name': 'Name of the compiled contract',
      'swarmLocation': 'Swarm url where all metadata information can be found (contract needs to be published first)',
      'web3Deploy': 'Copy/paste this code to any JavaScript/Web3 console to deploy this contract'
    };
    if (!this.selectedContract) throw new Error('No contract compiled yet');
    const contractProperties = this.data.contractsDetails[this.selectedContract];
    const log = yo`<div class="${css.detailsJSON}"></div>`;
    Object.keys(contractProperties).map(propertyName => {
      const copyDetails = yo`<span class="${css.copyDetails}">${copyToClipboard(() => contractProperties[propertyName])}</span>`;
      const questionMark = yo`<span class="${css.questionMark}"><i title="${help[propertyName]}" class="fas fa-question-circle" aria-hidden="true"></i></span>`;
      log.appendChild(yo`<div class=${css.log}>
        <div class="${css.key}">${propertyName} ${copyDetails} ${questionMark}</div>
        ${this.insertValue(contractProperties, propertyName)}
      </div>`);
    });
    modalDialog(this.selectedContract, log, {
      label: ''
    }, {
      label: 'Close'
    });
  }

  insertValue(details, propertyName) {
    var node;

    if (propertyName === 'web3Deploy' || propertyName === 'name' || propertyName === 'Assembly') {
      node = yo`<pre>${details[propertyName]}</pre>`;
    } else if (propertyName === 'abi' || propertyName === 'metadata') {
      const treeView = new TreeView({
        extractData: function (item, parent, key) {
          var ret = {};

          if (item instanceof Array) {
            ret.children = item.map((item, index) => ({
              key: index,
              value: item
            }));
            ret.self = '';
          } else if (item instanceof Object) {
            ret.children = Object.keys(item).map(key => ({
              key: key,
              value: item[key]
            }));
            ret.self = '';
          } else {
            ret.self = item;
            ret.children = [];
          }

          return ret;
        }
      });

      if (details[propertyName] !== '') {
        try {
          node = yo`
          <div>
            ${treeView.render(typeof details[propertyName] === 'object' ? details[propertyName] : JSON.parse(details[propertyName]))}
          </div>`; // catch in case the parsing fails.
        } catch (e) {
          node = yo`<div>Unable to display "${propertyName}": ${e.message}</div>`;
        }
      } else {
        node = yo`<div> - </div>`;
      }
    } else {
      node = yo`<div>${JSON.stringify(details[propertyName], null, 4)}</div>`;
    }

    return yo`<pre class="${css.value}">${node || ''}</pre>`;
  }

  getContractProperty(property) {
    if (!this.selectedContract) throw new Error('No contract compiled yet');
    const contractProperties = this.data.contractsDetails[this.selectedContract];
    return contractProperties[property] || null;
  }

  copyContractProperty(property) {
    let content = this.getContractProperty(property);

    if (!content) {
      addTooltip('No content available for ' + property);
      return;
    }

    try {
      if (typeof content !== 'string') {
        content = JSON.stringify(content, null, '\t');
      }
    } catch (e) {}

    copy(content);
    addTooltip('Copied value to clipboard');
  }

  copyABI() {
    this.copyContractProperty('abi');
  }

  copyBytecode() {
    this.copyContractProperty('bytecode');
  }

  render() {
    if (this._view.el) return this._view.el;
    this.onActivationInternal();
    this._view.errorContainer = yo`<div class="${css.errorBlobs} p-4" data-id="compiledErrors" ></div>`;
    this._view.contractSelection = this.contractSelection();
    this._view.compilerContainer = this.compilerContainer.render();
    this.compilerContainer.activate();
    this._view.el = yo`
      <div id="compileTabView">
        ${this._view.compilerContainer}
        ${this._view.contractSelection}
        ${this._view.errorContainer}
      </div>`;
    return this._view.el;
  }

  onActivation() {
    this.listenToEvents();
  }

  onDeactivation() {
    this.compilerContainer.deactivate();
    this.editor.event.unregister('contentChanged', this.data.eventHandlers.onContentChanged);
    this.compiler.event.unregister('loadingCompiler', this.data.eventHandlers.onLoadingCompiler);
    this.compiler.event.unregister('compilerLoaded', this.data.eventHandlers.onCompilerLoaded);
    this.compileTabLogic.event.removeListener('startingCompilation', this.data.eventHandlers.onStartingCompilation);
    this.fileManager.events.removeListener('currentFileChanged', this.data.eventHandlers.onCurrentFileChanged);
    this.fileManager.events.removeListener('noFileSelected', this.data.eventHandlers.onNoFileSelected);
    this.compiler.event.unregister('compilationFinished', this.data.eventHandlers.onCompilationFinished);
    globalRegistry.get('themeModule').api.events.removeListener('themeChanged', this.data.eventHandlers.onThemeChanged);
  }

}

module.exports = CompileTab;

/***/ }),

/***/ "./app/tabs/compileTab/compileTab.js":
/*!*******************************************!*\
  !*** ./app/tabs/compileTab/compileTab.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

const EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var remixTests = __webpack_require__(/*! @remix-project/remix-tests */ "../../../dist/libs/remix-tests/src/index.js");

var Compiler = __webpack_require__(/*! @remix-project/remix-solidity */ "../../../dist/libs/remix-solidity/index.js").Compiler;

var CompilerImport = __webpack_require__(/*! ../../compiler/compiler-imports */ "./app/compiler/compiler-imports.js"); // TODO: move this to the UI


const addTooltip = __webpack_require__(/*! ../../ui/tooltip */ "./app/ui/tooltip.js");

class CompileTab {
  constructor(queryParams, fileManager, editor, config, fileProvider) {
    this.event = new EventEmitter();
    this.queryParams = queryParams;
    this.compilerImport = new CompilerImport();
    this.compiler = new Compiler((url, cb) => this.importFileCb(url, cb));
    this.fileManager = fileManager;
    this.editor = editor;
    this.config = config;
    this.fileProvider = fileProvider;
  }

  init() {
    this.optimize = this.queryParams.get().optimize;
    this.optimize = this.optimize === 'true';
    this.queryParams.update({
      optimize: this.optimize
    });
    this.compiler.set('optimize', this.optimize);
    this.evmVersion = this.queryParams.get().evmVersion;

    if (this.evmVersion === 'undefined' || this.evmVersion === 'null' || !this.evmVersion) {
      this.evmVersion = null;
    }

    this.queryParams.update({
      evmVersion: this.evmVersion
    });
    this.compiler.set('evmVersion', this.evmVersion);
  }

  setOptimize(newOptimizeValue) {
    this.optimize = newOptimizeValue;
    this.queryParams.update({
      optimize: this.optimize
    });
    this.compiler.set('optimize', this.optimize);
  }

  setEvmVersion(newEvmVersion) {
    this.evmVersion = newEvmVersion;
    this.queryParams.update({
      evmVersion: this.evmVersion
    });
    this.compiler.set('evmVersion', this.evmVersion);
  }
  /**
   * Set the compiler to using Solidity or Yul (default to Solidity)
   * @params lang {'Solidity' | 'Yul'} ...
   */


  setLanguage(lang) {
    this.compiler.set('language', lang);
  }
  /**
   * Compile a specific file of the file manager
   * @param {string} target the path to the file to compile
   */


  compileFile(target) {
    if (!target) throw new Error('No target provided for compiliation');
    const provider = this.fileManager.fileProviderOf(target);
    if (!provider) throw new Error(`cannot compile ${target}. Does not belong to any explorer`);
    return new Promise((resolve, reject) => {
      provider.get(target, (error, content) => {
        if (error) return reject(error);
        const sources = {
          [target]: {
            content
          }
        };
        this.event.emit('startingCompilation'); // setTimeout fix the animation on chrome... (animation triggered by 'staringCompilation')

        setTimeout(() => {
          this.compiler.compile(sources, target);
          resolve();
        }, 100);
      });
    });
  }

  runCompiler() {
    try {
      this.fileManager.saveCurrentFile();
      this.editor.clearAnnotations();
      var currentFile = this.config.get('currentFile');
      return this.compileFile(currentFile);
    } catch (err) {
      console.error(err);
    }
  }

  importExternal(url, cb) {
    this.compilerImport.import(url, // TODO: move to an event that is generated, the UI shouldn't be here
    loadingMsg => {
      addTooltip(loadingMsg);
    }, (error, content, cleanUrl, type, url) => {
      if (error) return cb(error);

      if (this.fileProvider) {
        this.fileProvider.addExternal(type + '/' + cleanUrl, content, url);
      }

      cb(null, content);
    });
  }
  /**
    * import the content of @arg url.
    * first look in the browser localstorage (browser explorer) or locahost explorer. if the url start with `browser/*` or  `localhost/*`
    * then check if the @arg url is located in the localhost, in the node_modules or installed_contracts folder
    * then check if the @arg url match any external url
    *
    * @param {String} url  - URL of the content. can be basically anything like file located in the browser explorer, in the localhost explorer, raw HTTP, github address etc...
    * @param {Function} cb  - callback
    */


  importFileCb(url, filecb) {
    if (url.indexOf('remix_tests.sol') !== -1) return filecb(null, remixTests.assertLibCode);
    var provider = this.fileManager.fileProviderOf(url);

    if (provider) {
      if (provider.type === 'localhost' && !provider.isConnected()) {
        return filecb(`file provider ${provider.type} not available while trying to resolve ${url}`);
      }

      provider.exists(url, (error, exist) => {
        if (error) return filecb(error);
        if (!exist && provider.type === 'localhost') return filecb(`not found ${url}`);
        /*
          if the path is absolute and the file does not exist, we can stop here
          Doesn't make sense to try to resolve "localhost/node_modules/localhost/node_modules/<path>" and we'll end in an infinite loop.
        */

        if (!exist && url.startsWith('browser/')) return filecb(`not found ${url}`);
        if (!exist && url.startsWith('localhost/')) return filecb(`not found ${url}`);
        if (exist) return provider.get(url, filecb); // try to resolve localhost modules (aka truffle imports) - e.g from the node_modules folder

        const localhostProvider = this.fileManager.getProvider('localhost');

        if (localhostProvider.isConnected()) {
          var splitted = /([^/]+)\/(.*)$/g.exec(url);
          return async.tryEach([cb => {
            this.importFileCb('localhost/installed_contracts/' + url, cb);
          }, cb => {
            if (!splitted) {
              cb('URL not parseable: ' + url);
            } else {
              this.importFileCb('localhost/installed_contracts/' + splitted[1] + '/contracts/' + splitted[2], cb);
            }
          }, cb => {
            this.importFileCb('localhost/node_modules/' + url, cb);
          }, cb => {
            if (!splitted) {
              cb('URL not parseable: ' + url);
            } else {
              this.importFileCb('localhost/node_modules/' + splitted[1] + '/contracts/' + splitted[2], cb);
            }
          }], (error, result) => {
            if (error) return this.importExternal(url, filecb);
            filecb(null, result);
          });
        } else {
          // try to resolve external content
          this.importExternal(url, filecb);
        }
      });
    }
  }

}

module.exports = CompileTab;

/***/ }),

/***/ "./app/tabs/compileTab/compilerContainer.js":
/*!**************************************************!*\
  !*** ./app/tabs/compileTab/compilerContainer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _compilerUtils = __webpack_require__(/*! ../../compiler/compiler-utils */ "./app/compiler/compiler-utils.js");

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const helper = __webpack_require__(/*! ../../../lib/helper */ "./lib/helper.js");

const addTooltip = __webpack_require__(/*! ../../ui/tooltip */ "./app/ui/tooltip.js");

const semver = __webpack_require__(/*! semver */ "../../../node_modules/semver/semver.js");

const modalDialogCustom = __webpack_require__(/*! ../../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

const css = __webpack_require__(/*! ../styles/compile-tab-styles */ "./app/tabs/styles/compile-tab-styles.js");

class CompilerContainer {
  constructor(compileTabLogic, editor, config, queryParams) {
    this._view = {};
    this.compileTabLogic = compileTabLogic;
    this.editor = editor;
    this.config = config;
    this.queryParams = queryParams;
    this.data = {
      hideWarnings: config.get('hideWarnings') || false,
      autoCompile: config.get('autoCompile'),
      compileTimeout: null,
      timeout: 300,
      allversions: null,
      selectedVersion: null,
      defaultVersion: 'soljson-v0.6.6+commit.6c089d02.js' // this default version is defined: in makeMockCompiler (for browser test) and in package.json (downloadsolc_root) for the builtin compiler

    };
  }
  /**
   * Update the compilation button with the name of the current file
   */


  set currentFile(name = '') {
    if (name && name !== '') {
      this._setCompilerVersionFromPragma(name);
    }

    if (!this._view.compilationButton) return;
    const button = this.compilationButton(name.split('/').pop());

    this._disableCompileBtn(!name || name && !this.isSolFileSelected(name));

    yo.update(this._view.compilationButton, button);
  }

  isSolFileSelected(currentFile = '') {
    if (!currentFile) currentFile = this.config.get('currentFile');
    if (!currentFile) return false;
    const extention = currentFile.substr(currentFile.length - 3, currentFile.length);
    return extention.toLowerCase() === 'sol' || extention.toLowerCase() === 'yul';
  }

  deactivate() {
    // deactivate editor listeners
    this.editor.event.unregister('contentChanged');
    this.editor.event.unregister('sessionSwitched');
  }

  activate() {
    this.currentFile = this.config.get('currentFile');
    this.listenToEvents();
  }

  listenToEvents() {
    this.editor.event.register('sessionSwitched', () => {
      if (!this._view.compileIcon) return;
      this.scheduleCompilation();
    });
    this.compileTabLogic.event.on('startingCompilation', () => {
      if (!this._view.compileIcon) return;

      this._view.compileIcon.setAttribute('title', 'compiling...');

      this._view.compileIcon.classList.remove(`${css.bouncingIcon}`);

      this._view.compileIcon.classList.add(`${css.spinningIcon}`);
    });
    this.compileTabLogic.compiler.event.register('compilationDuration', speed => {
      if (!this._view.warnCompilationSlow) return;

      if (speed > 1000) {
        const msg = `Last compilation took ${speed}ms. We suggest to turn off autocompilation.`;

        this._view.warnCompilationSlow.setAttribute('title', msg);

        this._view.warnCompilationSlow.style.visibility = 'visible';
      } else {
        this._view.warnCompilationSlow.style.visibility = 'hidden';
      }
    });
    this.editor.event.register('contentChanged', () => {
      if (!this._view.compileIcon) return;
      this.scheduleCompilation();

      this._view.compileIcon.classList.add(`${css.bouncingIcon}`); // @TODO: compileView tab

    });
    this.compileTabLogic.compiler.event.register('loadingCompiler', () => {
      if (!this._view.compileIcon) return;

      this._disableCompileBtn(true);

      this._view.compileIcon.setAttribute('title', 'compiler is loading, please wait a few moments.');

      this._view.compileIcon.classList.add(`${css.spinningIcon}`);

      this._view.warnCompilationSlow.style.visibility = 'hidden';

      this._updateLanguageSelector();
    });
    this.compileTabLogic.compiler.event.register('compilerLoaded', () => {
      if (!this._view.compileIcon) return;

      this._disableCompileBtn(false);

      this._view.compileIcon.setAttribute('title', '');

      this._view.compileIcon.classList.remove(`${css.spinningIcon}`);

      if (this.data.autoCompile) this.compileIfAutoCompileOn();
    });
    this.compileTabLogic.compiler.event.register('compilationFinished', (success, data, source) => {
      if (!this._view.compileIcon) return;

      this._view.compileIcon.setAttribute('title', 'idle');

      this._view.compileIcon.classList.remove(`${css.spinningIcon}`);

      this._view.compileIcon.classList.remove(`${css.bouncingIcon}`);
    });
  }
  /**************
   * SUBCOMPONENT
   */


  compilationButton(name = '') {
    const displayed = name || '<no file selected>';
    const disabled = name && this.isSolFileSelected() ? '' : 'disabled';
    return yo`
      <button id="compileBtn" data-id="compilerContainerCompileBtn" class="btn btn-primary btn-block ${disabled} mt-3" title="Compile" onclick="${this.compile.bind(this)}">
        <span>${this._view.compileIcon} Compile ${displayed}</span>
      </button>
    `;
  }

  _disableCompileBtn(shouldDisable) {
    let btn = document.getElementById('compileBtn');
    if (!btn) return;

    if (shouldDisable) {
      btn.classList.add('disabled');
    } else if (this.isSolFileSelected()) {
      btn.classList.remove('disabled');
    }
  } // Load solc compiler version according to pragma in contract file


  _setCompilerVersionFromPragma(filename) {
    if (!this.data.allversions) return;
    this.compileTabLogic.fileManager.readFile(filename).then(data => {
      const pragmaArr = data.match(/(pragma solidity (.+?);)/g);

      if (pragmaArr && pragmaArr.length === 1) {
        const pragmaStr = pragmaArr[0].replace('pragma solidity', '').trim();
        const pragma = pragmaStr.substring(0, pragmaStr.length - 1);
        const releasedVersions = this.data.allversions.filter(obj => !obj.prerelease).map(obj => obj.version);
        const allVersions = this.data.allversions.map(obj => this._retrieveVersion(obj.version));

        const currentCompilerName = this._retrieveVersion(this._view.versionSelector.selectedOptions[0].label); // contains only numbers part, for example '0.4.22'


        const pureVersion = this._retrieveVersion(); // is nightly build newer than the last release


        const isNewestNightly = currentCompilerName.includes('nightly') && semver.gt(pureVersion, releasedVersions[0]); // checking if the selected version is in the pragma range

        const isInRange = semver.satisfies(pureVersion, pragma); // checking if the selected version is from official compilers list(excluding custom versions) and in range or greater

        const isOfficial = allVersions.includes(currentCompilerName);

        if (isOfficial && !isInRange && !isNewestNightly) {
          const compilerToLoad = semver.maxSatisfying(releasedVersions, pragma);
          const compilerPath = this.data.allversions.filter(obj => !obj.prerelease && obj.version === compilerToLoad)[0].path;

          if (this.data.selectedVersion !== compilerPath) {
            this.data.selectedVersion = compilerPath;

            this._updateVersionSelector();
          }
        }
      }
    });
  }

  _retrieveVersion(version) {
    if (!version) version = this._view.versionSelector.value;
    return semver.coerce(version) ? semver.coerce(version).version : '';
  }

  render() {
    this.compileTabLogic.compiler.event.register('compilerLoaded', version => this.setVersionText(version));
    this.fetchAllVersion((allversions, selectedVersion) => {
      this.data.allversions = allversions;
      this.data.selectedVersion = selectedVersion;
      if (this._view.versionSelector) this._updateVersionSelector();
    });
    this._view.warnCompilationSlow = yo`<i title="Compilation Slow" style="visibility:hidden" class="${css.warnCompilationSlow} fas fa-exclamation-triangle" aria-hidden="true"></i>`;
    this._view.compileIcon = yo`<i class="fas fa-sync ${css.icon}" aria-hidden="true"></i>`;
    this._view.autoCompile = yo`<input class="${css.autocompile} custom-control-input" onchange=${this.updateAutoCompile.bind(this)} data-id="compilerContainerAutoCompile" id="autoCompile" type="checkbox" title="Auto compile">`;
    this._view.hideWarningsBox = yo`<input class="${css.autocompile} custom-control-input" onchange=${this.hideWarnings.bind(this)} id="hideWarningsBox" type="checkbox" title="Hide warnings">`;
    if (this.data.autoCompile) this._view.autoCompile.setAttribute('checked', '');
    if (this.data.hideWarnings) this._view.hideWarningsBox.setAttribute('checked', '');
    this._view.optimize = yo`<input onchange=${this.onchangeOptimize.bind(this)} class="custom-control-input" id="optimize" type="checkbox">`;
    if (this.compileTabLogic.optimize) this._view.optimize.setAttribute('checked', '');
    this._view.versionSelector = yo`
      <select onchange="${this.onchangeLoadVersion.bind(this)}" class="custom-select" id="versionSelector" disabled>
        <option disabled selected>${this.data.defaultVersion}</option>
      </select>`;
    this._view.languageSelector = yo`
      <select onchange="${this.onchangeLanguage.bind(this)}" class="custom-select" id="compilierLanguageSelector" title="Available since v0.5.7">
        <option>Solidity</option>
        <option>Yul</option>
      </select>`;
    this._view.version = yo`<span id="version"></span>`;
    this._view.evmVersionSelector = yo`
      <select onchange="${this.onchangeEvmVersion.bind(this)}" class="custom-select" id="evmVersionSelector">
        <option value="default">compiler default</option>
        <option>istanbul</option>
        <option>petersburg</option>
        <option>constantinople</option>
        <option>byzantium</option>
        <option>spuriousDragon</option>
        <option>tangerineWhistle</option>
        <option>homestead</option>
      </select>`;

    if (this.compileTabLogic.evmVersion) {
      let s = this._view.evmVersionSelector;
      let i;

      for (i = 0; i < s.options.length; i++) {
        if (s.options[i].value === this.compileTabLogic.evmVersion) {
          break;
        }
      }

      if (i === s.options.length) {
        // invalid evmVersion from queryParams
        s.selectedIndex = 0; // compiler default

        this.onchangeEvmVersion();
      } else {
        s.selectedIndex = i;
      }
    }

    this._view.compilationButton = this.compilationButton();
    this._view.includeNightlies = yo`
      <input class="mr-2 custom-control-input" id="nightlies" type="checkbox" onchange=${() => this._updateVersionSelector()}>
    `;
    this._view.compileContainer = yo`
      <section>
        <!-- Select Compiler Version -->
        <article>
          <header class="${css.compilerSection} border-bottom">
            <div class="mb-2">
              <label class="${css.compilerLabel} form-check-label" for="versionSelector">
                Compiler
                <button class="far fa-plus-square border-0 p-0 mx-2 btn-sm" onclick="${e => this.promtCompiler(e)}" title="Add a custom compiler with URL"></button>
              </label>
              ${this._view.versionSelector}
            </div>
            <div class="mb-2 ${css.nightlyBuilds} custom-control custom-checkbox">
              ${this._view.includeNightlies}
              <label for="nightlies" class="form-check-label custom-control-label">Include nightly builds</label>
            </div>
            <div class="mb-2">
              <label class="${css.compilerLabel} form-check-label" for="compilierLanguageSelector">Language</label>
              ${this._view.languageSelector}
            </div>
            <div class="mb-2">
              <label class="${css.compilerLabel} form-check-label" for="evmVersionSelector">EVM Version</label>
              ${this._view.evmVersionSelector}
            </div>
            <div class="mt-3">
              <p class="mt-2 ${css.compilerLabel}">Compiler Configuration</p>
              <div class="mt-2 ${css.compilerConfig} custom-control custom-checkbox">
                ${this._view.autoCompile}
                <label class="form-check-label custom-control-label" for="autoCompile">Auto compile</label>
              </div>
              <div class="mt-2 ${css.compilerConfig} custom-control custom-checkbox">
                ${this._view.optimize}
                <label class="form-check-label custom-control-label" for="optimize">Enable optimization</label>
              </div>
              <div class="mt-2 ${css.compilerConfig} custom-control custom-checkbox">
                ${this._view.hideWarningsBox}
                <label class="form-check-label custom-control-label" for="hideWarningsBox">Hide warnings</label>
              </div>
            </div>
            ${this._view.compilationButton}
          </header>
        </article>
        <!-- Config -->
      </section>`;
    return this._view.compileContainer;
  }

  promtCompiler() {
    modalDialogCustom.prompt('Add a custom compiler', 'URL', '', url => this.addCustomCompiler(url));
  }

  addCustomCompiler(url) {
    this.data.selectedVersion = this._view.versionSelector.value;

    this._updateVersionSelector(url);
  }

  updateAutoCompile(event) {
    this.config.set('autoCompile', this._view.autoCompile.checked);
  }

  compile(event) {
    const currentFile = this.config.get('currentFile');
    if (!this.isSolFileSelected()) return;

    this._setCompilerVersionFromPragma(currentFile);

    this.compileTabLogic.runCompiler();
  }

  compileIfAutoCompileOn() {
    if (this.config.get('autoCompile')) {
      this.compile();
    }
  }

  hideWarnings(event) {
    this.config.set('hideWarnings', this._view.hideWarningsBox.checked);
    this.compileIfAutoCompileOn();
  }
  /*
    The following functions are handlers for internal events.
  */


  onchangeOptimize() {
    this.compileTabLogic.setOptimize(!!this._view.optimize.checked);
    this.compileIfAutoCompileOn();
  }

  onchangeLanguage() {
    this.compileTabLogic.setLanguage(this._view.languageSelector.value);
    this.compileIfAutoCompileOn();
  }

  onchangeEvmVersion() {
    let s = this._view.evmVersionSelector;
    let v = s.value;

    if (v === 'default') {
      v = null;
    }

    this.compileTabLogic.setEvmVersion(v);
    this.compileIfAutoCompileOn();
  }

  onchangeLoadVersion() {
    this.data.selectedVersion = this._view.versionSelector.value;

    this._updateVersionSelector();

    this._updateLanguageSelector();
  }
  /*
    The following functions map with the above event handlers.
    They are an external API for modifying the compiler configuration.
  */


  setConfiguration(settings) {
    this.setLanguage(settings.language);
    this.setEvmVersion(settings.evmVersion);
    this.setOptimize(settings.optimize);
    this.setVersion(settings.version);
  }

  setOptimize(enabled) {
    this._view.optimize.checked = enabled;
    this.onchangeOptimize();
  }

  setLanguage(lang) {
    this._view.languageSelector.value = lang;
    this.onchangeLanguage();
  }

  setEvmVersion(version) {
    this._view.evmVersionSelector.value = version || 'default';
    this.onchangeEvmVersion();
  }

  setVersion(version) {
    this._view.versionSelector.value = `soljson-v${version}.js`;
    this.onchangeLoadVersion();
  }

  _shouldBeAdded(version) {
    return !version.includes('nightly') || version.includes('nightly') && this._view.includeNightlies.checked;
  }

  _updateVersionSelector(customUrl = '') {
    // update selectedversion of previous one got filtered out
    if (!this.data.selectedVersion || !this._shouldBeAdded(this.data.selectedVersion)) {
      this.data.selectedVersion = this.data.defaultVersion;
    }

    this._view.versionSelector.innerHTML = '';
    this.data.allversions.forEach(build => {
      const option = build.path === this.data.selectedVersion ? yo`<option value="${build.path}" selected>${build.longVersion}</option>` : yo`<option value="${build.path}">${build.longVersion}</option>`;

      if (this._shouldBeAdded(option.innerText)) {
        this._view.versionSelector.appendChild(option);
      }
    });

    this._view.versionSelector.removeAttribute('disabled');

    this.queryParams.update({
      version: this.data.selectedVersion
    });
    let url;

    if (customUrl !== '') {
      this.data.selectedVersion = customUrl;

      this._view.versionSelector.appendChild(yo`<option value="${customUrl}" selected>custom</option>`);

      url = customUrl;
    } else if (this.data.selectedVersion === 'builtin') {
      let location = window.document.location;
      location = `${location.protocol}//${location.host}/${location.pathname}`;
      if (location.endsWith('index.html')) location = location.substring(0, location.length - 10);
      if (!location.endsWith('/')) location += '/';
      url = location + 'soljson.js';
    } else {
      if (this.data.selectedVersion.indexOf('soljson') !== 0 || helper.checkSpecialChars(this.data.selectedVersion)) {
        return console.log('loading ' + this.data.selectedVersion + ' not allowed');
      }

      url = `${(0, _compilerUtils.urlFromVersion)(this.data.selectedVersion)}`;
    } // Workers cannot load js on "file:"-URLs and we get a
    // "Uncaught RangeError: Maximum call stack size exceeded" error on Chromium,
    // resort to non-worker version in that case.


    if (this.data.selectedVersion !== 'builtin' && (0, _compilerUtils.canUseWorker)(this.data.selectedVersion)) {
      this.compileTabLogic.compiler.loadVersion(true, url);
      this.setVersionText('(loading using worker)');
    } else {
      this.compileTabLogic.compiler.loadVersion(false, url);
      this.setVersionText('(loading)');
    }
  }

  _updateLanguageSelector() {
    // This is the first version when Yul is available
    if (!semver.valid(this._retrieveVersion()) || semver.lt(this._retrieveVersion(), 'v0.5.7+commit.6da8b019.js')) {
      this._view.languageSelector.setAttribute('disabled', '');

      this._view.languageSelector.value = 'Solidity';
      this.compileTabLogic.setLanguage('Solidity');
    } else {
      this._view.languageSelector.removeAttribute('disabled');
    }
  }

  setVersionText(text) {
    if (this._view.version) this._view.version.innerText = text;
  } // fetching both normal and wasm builds and creating a [version, baseUrl] map


  async fetchAllVersion(callback) {
    let allVersions, selectedVersion, allVersionsWasm; // fetch normal builds

    const binRes = await (0, _compilerUtils.promisedMiniXhr)(`${_compilerUtils.baseURLBin}/list.json`); // fetch wasm builds

    const wasmRes = await (0, _compilerUtils.promisedMiniXhr)(`${_compilerUtils.baseURLWasm}/list.json`);

    if (binRes.event.type === 'error' && wasmRes.event.type === 'error') {
      allVersions = [{
        path: 'builtin',
        longVersion: 'latest local version'
      }];
      selectedVersion = 'builtin';
      callback(allVersions, selectedVersion);
    }

    try {
      allVersions = JSON.parse(binRes.json).builds.slice().reverse();
      selectedVersion = this.data.defaultVersion;
      if (this.queryParams.get().version) selectedVersion = this.queryParams.get().version;

      if (wasmRes.event.type !== 'error') {
        allVersionsWasm = JSON.parse(wasmRes.json).builds.slice().reverse();
      }
    } catch (e) {
      addTooltip('Cannot load compiler version list. It might have been blocked by an advertisement blocker. Please try deactivating any of them from this page and reload. Error: ' + e);
    } // replace in allVersions those compiler builds which exist in allVersionsWasm with new once


    if (allVersionsWasm && allVersions) {
      allVersions.forEach((compiler, index) => {
        const wasmIndex = allVersionsWasm.findIndex(wasmCompiler => {
          return wasmCompiler.longVersion === compiler.longVersion;
        });

        if (wasmIndex !== -1) {
          allVersions[index] = allVersionsWasm[wasmIndex];
          _compilerUtils.pathToURL[compiler.path] = _compilerUtils.baseURLWasm;
        } else {
          _compilerUtils.pathToURL[compiler.path] = _compilerUtils.baseURLBin;
        }
      });
    }

    callback(allVersions, selectedVersion);
  }

  scheduleCompilation() {
    if (!this.config.get('autoCompile')) return;
    if (this.data.compileTimeout) window.clearTimeout(this.data.compileTimeout);
    this.data.compileTimeout = window.setTimeout(() => this.compileIfAutoCompileOn(), this.data.timeout);
  }

}

module.exports = CompilerContainer;

/***/ }),

/***/ "./app/tabs/compileTab/contractParser.js":
/*!***********************************************!*\
  !*** ./app/tabs/compileTab/contractParser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var solcTranslate = __webpack_require__(/*! solc/translate */ "../../../node_modules/solc/translate.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var txHelper = remixLib.execution.txHelper;

module.exports = (contractName, contract, compiledSource) => {
  return getDetails(contractName, contract, compiledSource);
};

var getDetails = function (contractName, contract, source) {
  var detail = {};
  detail.name = contractName;
  detail.metadata = contract.metadata;

  if (contract.evm.bytecode.object) {
    detail.bytecode = contract.evm.bytecode.object;
  }

  detail.abi = contract.abi;

  if (contract.evm.bytecode.object) {
    detail.bytecode = contract.evm.bytecode;
    detail.web3Deploy = gethDeploy(contractName.toLowerCase(), contract.abi, contract.evm.bytecode.object);
    detail.metadataHash = retrieveMetadataHash(contract.evm.bytecode.object);

    if (detail.metadataHash) {
      detail.swarmLocation = 'bzzr://' + detail.metadataHash;
    }
  }

  detail.functionHashes = {};

  for (var fun in contract.evm.methodIdentifiers) {
    detail.functionHashes[contract.evm.methodIdentifiers[fun]] = fun;
  }

  detail.gasEstimates = formatGasEstimates(contract.evm.gasEstimates);
  detail.devdoc = contract.devdoc;
  detail.userdoc = contract.userdoc;

  if (contract.evm.deployedBytecode && contract.evm.deployedBytecode.object.length > 0) {
    detail['Runtime Bytecode'] = contract.evm.deployedBytecode;
  }

  if (source && contract.assembly !== null) {
    detail['Assembly'] = solcTranslate.prettyPrintLegacyAssemblyJSON(contract.evm.legacyAssembly, source.content);
  }

  return detail;
};

var retrieveMetadataHash = function (bytecode) {
  var match = /a165627a7a72305820([0-9a-f]{64})0029$/.exec(bytecode);

  if (!match) {
    match = /a265627a7a72305820([0-9a-f]{64})6c6578706572696d656e74616cf50037$/.exec(bytecode);
  }

  if (match) {
    return match[1];
  }
};

var gethDeploy = function (contractName, jsonInterface, bytecode) {
  var code = '';
  var funABI = txHelper.getConstructorInterface(jsonInterface);
  funABI.inputs.forEach(function (inp) {
    code += 'var ' + inp.name + ' = /* var of type ' + inp.type + ' here */ ;\n';
  });
  contractName = contractName.replace(/[:./]/g, '_');
  code += 'var ' + contractName + 'Contract = web3.eth.contract(' + JSON.stringify(jsonInterface).replace('\n', '') + ');' + '\nvar ' + contractName + ' = ' + contractName + 'Contract.new(';
  funABI.inputs.forEach(function (inp) {
    code += '\n   ' + inp.name + ',';
  });
  code += '\n   {' + '\n     from: web3.eth.accounts[0], ' + "\n     data: '0x" + bytecode + "', " + "\n     gas: '4700000'" + '\n   }, function (e, contract){' + '\n    console.log(e, contract);' + "\n    if (typeof contract.address !== 'undefined') {" + "\n         console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash);" + '\n    }' + '\n })';
  return code;
};

var formatGasEstimates = function (data) {
  if (!data) return {};
  if (data.creation === undefined && data.external === undefined && data.internal === undefined) return {};

  var gasToText = function (g) {
    return g === null ? 'unknown' : g;
  };

  var ret = {};
  var fun;

  if ('creation' in data) {
    ret['Creation'] = data.creation;
  }

  if ('external' in data) {
    ret['External'] = {};

    for (fun in data.external) {
      ret['External'][fun] = gasToText(data.external[fun]);
    }
  }

  if ('internal' in data) {
    ret['Internal'] = {};

    for (fun in data.internal) {
      ret['Internal'][fun] = gasToText(data.internal[fun]);
    }
  }

  return ret;
};

/***/ }),

/***/ "./app/tabs/debugger-tab.js":
/*!**********************************!*\
  !*** ./app/tabs/debugger-tab.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tooltip = _interopRequireDefault(__webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js"));

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const css = __webpack_require__(/*! ./styles/debugger-tab-styles */ "./app/tabs/styles/debugger-tab-styles.js");

const DebuggerUI = __webpack_require__(/*! ./debugger/debuggerUI */ "./app/tabs/debugger/debuggerUI.js");

const profile = {
  name: 'debugger',
  displayName: 'Debugger',
  methods: ['debug', 'getTrace'],
  events: [],
  icon: 'assets/img/debuggerLogo.webp',
  description: 'Debug transactions',
  kind: 'debugging',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/debugger.html',
  version: packageJson.version
};

class DebuggerTab extends _engine.ViewPlugin {
  constructor(blockchain) {
    super(profile);
    this.el = null;
    this.blockchain = blockchain;
  }

  render() {
    if (this.el) return this.el;
    this.el = yo`
      <div class="${css.debuggerTabView}" id="debugView">
        <div id="debugger" class="${css.debugger}"></div>
      </div>`;
    this.on('fetchAndCompile', 'compiling', settings => {
      (0, _tooltip.default)(yo`<div><b>Recompiling and debugging with params</b><pre class="text-left">${JSON.stringify(settings, null, '\t')}</pre></div>`);
    });
    this.on('fetchAndCompile', 'compilationFailed', data => {
      (0, _tooltip.default)(yo`<div><b>Compilation failed...</b> continuing <i>without</i> source code debugging.</div>`);
    });
    this.on('fetchAndCompile', 'notFound', contractAddress => {
      (0, _tooltip.default)(yo`<div><b>Contract ${contractAddress} not found in source code repository</b> continuing <i>without</i> source code debugging.</div>`);
    });
    this.on('fetchAndCompile', 'usingLocalCompilation', contractAddress => {
      (0, _tooltip.default)(yo`<div><b>Using compilation result from Solidity module</b></div>`);
    });
    this.on('fetchAndCompile', 'sourceVerificationNotAvailable', () => {
      (0, _tooltip.default)(yo`<div><b>Source verification plugin not activated or not available.</b> continuing <i>without</i> source code debugging.</div>`);
    });
    this.debuggerUI = new DebuggerUI(this, this.el.querySelector('#debugger'), (address, receipt) => {
      const target = address && remixLib.helpers.trace.isContractCreation(address) ? receipt.contractAddress : address;
      return this.call('fetchAndCompile', 'resolve', target || receipt.contractAddress || receipt.to, '.debug', this.blockchain.web3());
    });
    this.call('manager', 'activatePlugin', 'source-verification').catch(e => console.log(e.message)); // this.call('manager', 'activatePlugin', 'udapp')

    return this.el;
  }

  deactivate() {
    this.debuggerUI.deleteHighlights();
    super.deactivate();
  }

  debug(hash) {
    if (this.debuggerUI) this.debuggerUI.debug(hash);
  }

  getTrace(hash) {
    return this.debuggerUI.getTrace(hash);
  }

  debugger() {
    return this.debuggerUI;
  }

}

module.exports = DebuggerTab;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI.js":
/*!*****************************************!*\
  !*** ./app/tabs/debugger/debuggerUI.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var TxBrowser = __webpack_require__(/*! ./debuggerUI/TxBrowser */ "./app/tabs/debugger/debuggerUI/TxBrowser.js");

var StepManagerUI = __webpack_require__(/*! ./debuggerUI/StepManager */ "./app/tabs/debugger/debuggerUI/StepManager.js");

var VmDebugger = __webpack_require__(/*! ./debuggerUI/VmDebugger */ "./app/tabs/debugger/debuggerUI/VmDebugger.js");

var toaster = __webpack_require__(/*! ../../ui/tooltip */ "./app/ui/tooltip.js");

var Debugger = __webpack_require__(/*! @remix-project/remix-debug */ "../../../dist/libs/remix-debug/index.js").TransactionDebugger;

var SourceHighlighter = __webpack_require__(/*! ../../editor/sourceHighlighter */ "./app/editor/sourceHighlighter.js");

var EventManager = __webpack_require__(/*! ../../../lib/events */ "./lib/events.js");

var globalRegistry = __webpack_require__(/*! ../../../global/registry */ "./global/registry.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var init = remixLib.init;

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .statusMessage {
    margin-left: 15px;
  }
`;

class DebuggerUI {
  constructor(debuggerModule, component, fetchContractAndCompile) {
    this.debuggerModule = debuggerModule;
    this.fetchContractAndCompile = fetchContractAndCompile;
    this.event = new EventManager();
    this.isActive = false;
    this.sourceHighlighter = new SourceHighlighter();
    this.startTxBrowser();
    this.stepManager = null;
    this.statusMessage = '';
    this.currentReceipt;
    this.view;
    component.appendChild(this.render());
    this.setEditor();
  }

  setEditor() {
    this.editor = globalRegistry.get('editor').api;
    this.editor.event.register('breakpointCleared', (fileName, row) => {
      if (this.debugger) this.debugger.breakPointManager.remove({
        fileName: fileName,
        row: row
      });
    });
    this.editor.event.register('breakpointAdded', (fileName, row) => {
      if (this.debugger) this.debugger.breakPointManager.add({
        fileName: fileName,
        row: row
      });
    });
    this.editor.event.register('contentChanged', () => {
      if (this.debugger) this.debugger.unload();
    });
  }

  listenToEvents() {
    if (!this.debugger) return;
    this.debugger.event.register('debuggerStatus', async isActive => {
      await this.debuggerModule.call('editor', 'discardHighlight');
      this.isActive = isActive;
    });
    this.debugger.event.register('newSourceLocation', async (lineColumnPos, rawLocation) => {
      const contracts = await this.fetchContractAndCompile(this.currentReceipt.contractAddress || this.currentReceipt.to, this.currentReceipt);

      if (contracts) {
        const path = contracts.getSourceName(rawLocation.file);

        if (path) {
          await this.debuggerModule.call('editor', 'discardHighlight');
          await this.debuggerModule.call('editor', 'highlight', lineColumnPos, path);
        }
      }
    });
    this.debugger.event.register('debuggerUnloaded', () => this.unLoad());
  }

  startTxBrowser() {
    let txBrowser = new TxBrowser();
    this.txBrowser = txBrowser;
    txBrowser.event.register('requestDebug', (blockNumber, txNumber, tx) => {
      if (this.debugger) this.debugger.unload();
      this.startDebugging(blockNumber, txNumber, tx);
    });
    txBrowser.event.register('unloadRequested', this, (blockNumber, txIndex, tx) => {
      if (this.debugger) this.debugger.unload();
    });
  }

  isDebuggerActive() {
    return this.isActive;
  }

  getDebugWeb3() {
    return new Promise((resolve, reject) => {
      this.debuggerModule.blockchain.detectNetwork((error, network) => {
        let web3;

        if (error || !network) {
          web3 = init.web3DebugNode(this.debuggerModule.blockchain.web3());
        } else {
          const webDebugNode = init.web3DebugNode(network.name);
          web3 = !webDebugNode ? this.debuggerModule.blockchain.web3() : webDebugNode;
        }

        init.extendWeb3(web3);
        resolve(web3);
      });
    });
  }

  async startDebugging(blockNumber, txNumber, tx) {
    if (this.debugger) this.unLoad();
    let web3 = await this.getDebugWeb3();
    this.currentReceipt = await web3.eth.getTransactionReceipt(txNumber);
    this.debugger = new Debugger({
      web3,
      offsetToLineColumnConverter: globalRegistry.get('offsettolinecolumnconverter').api,
      compilationResult: async address => {
        try {
          return await this.fetchContractAndCompile(address, this.currentReceipt);
        } catch (e) {
          console.error(e);
        }

        return null;
      }
    });
    this.listenToEvents();
    this.debugger.debug(blockNumber, txNumber, tx, () => {
      this.stepManager = new StepManagerUI(this.debugger.step_manager);
      this.vmDebugger = new VmDebugger(this.debugger.vmDebuggerLogic);
      this.txBrowser.setState({
        blockNumber,
        txNumber,
        debugging: true
      });
      this.renderDebugger();
    }).catch(error => {
      toaster(error);
      this.unLoad();
    });
  }

  getTrace(hash) {
    return new Promise(async (resolve, reject) => {
      const web3 = await this.getDebugWeb3();
      this.currentReceipt = await web3.eth.getTransactionReceipt(hash);
      const debug = new Debugger({
        web3,
        offsetToLineColumnConverter: globalRegistry.get('offsettolinecolumnconverter').api,
        compilationResult: async address => {
          try {
            return await this.fetchContractAndCompile(address, this.currentReceipt);
          } catch (e) {
            console.error(e);
          }

          return null;
        }
      });
      debug.debugger.traceManager.traceRetriever.getTrace(hash, (error, trace) => {
        if (error) return reject(error);
        resolve(trace);
      });
    });
  }

  debug(txHash) {
    this.startDebugging(null, txHash, null);
  }

  render() {
    this.debuggerPanelsView = yo`<div class="px-2"></div>`;
    this.debuggerHeadPanelsView = yo`<div class="px-2"></div>`;
    this.stepManagerView = yo`<div class="px-2"></div>`;
    var view = yo`
      <div>
        <div class="px-2">
          ${this.txBrowser.render()}
          ${this.stepManagerView}
          ${this.debuggerHeadPanelsView}
        </div>
        <div class="${css.statusMessage}">${this.statusMessage}</div>
        ${this.debuggerPanelsView}
      </div>
    `;

    if (!this.view) {
      this.view = view;
    }

    return view;
  }

  async unLoad() {
    yo.update(this.debuggerHeadPanelsView, yo`<div></div>`);
    yo.update(this.debuggerPanelsView, yo`<div></div>`);
    yo.update(this.stepManagerView, yo`<div></div>`);
    if (this.vmDebugger) this.vmDebugger.remove();
    if (this.stepManager) this.stepManager.remove();
    if (this.txBrowser) this.txBrowser.setState({
      debugging: false
    });
    this.vmDebugger = null;
    this.stepManager = null;
    if (this.debugger) delete this.debugger;
    this.event.trigger('traceUnloaded');
  }

  async deleteHighlights() {
    await this.debuggerModule.call('editor', 'discardHighlight');
  }

  renderDebugger() {
    yo.update(this.debuggerHeadPanelsView, this.vmDebugger.renderHead());
    yo.update(this.debuggerPanelsView, this.vmDebugger.render());
    yo.update(this.stepManagerView, this.stepManager.render());
  }

}

module.exports = DebuggerUI;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/ButtonNavigator.js":
/*!*********************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/ButtonNavigator.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventManager = __webpack_require__(/*! ../../../../lib/events */ "./lib/events.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .buttons {
    display: flex;
    flex-wrap: wrap;
  }
  .stepButtons {
    width: 100%;
    display: flex;
    justify-content: center;
  }
  .stepButton {
  }
  .jumpButtons {
    width: 100%;
    display: flex;
    justify-content: center;
  }
  .jumpButton {
  }
  .navigator {
  }
  .navigator:hover {
  }
`;

function ButtonNavigator() {
  this.event = new EventManager();
  this.intoBackDisabled = true;
  this.overBackDisabled = true;
  this.intoForwardDisabled = true;
  this.overForwardDisabled = true;
  this.jumpOutDisabled = true;
  this.jumpNextBreakpointDisabled = true;
  this.jumpPreviousBreakpointDisabled = true;
  this.view;
}

ButtonNavigator.prototype.render = function () {
  var self = this;
  var view = yo`<div class="${css.buttons}">
    <div class="${css.stepButtons} btn-group py-1">
      <button id='overback' class='btn btn-primary btn-sm ${css.navigator} ${css.stepButton} fas fa-reply' title='Step over back' onclick=${function () {
    self.event.trigger('stepOverBack');
  }} disabled=${this.overBackDisabled} ></button>
      <button id='intoback' data-id="buttonNavigatorIntoBack" class='btn btn-primary btn-sm ${css.navigator} ${css.stepButton} fas fa-level-up-alt' title='Step back' onclick=${function () {
    self.event.trigger('stepIntoBack');
  }} disabled=${this.intoBackDisabled} ></button>
      <button id='intoforward' data-id="buttonNavigatorIntoForward" class='btn btn-primary btn-sm ${css.navigator} ${css.stepButton} fas fa-level-down-alt' title='Step into' onclick=${function () {
    self.event.trigger('stepIntoForward');
  }} disabled=${this.intoForwardDisabled} ></button>
      <button id='overforward' class='btn btn-primary btn-sm ${css.navigator} ${css.stepButton} fas fa-share' title='Step over forward'onclick=${function () {
    self.event.trigger('stepOverForward');
  }} disabled=${this.overForwardDisabled} ></button>
    </div>

    <div class="${css.jumpButtons} btn-group py-1">
      <button class='btn btn-primary btn-sm ${css.navigator} ${css.jumpButton} fas fa-step-backward'  id='jumppreviousbreakpoint' data-id="buttonNavigatorJumpPreviousBreakpoint" title='Jump to the previous breakpoint' onclick=${function () {
    self.event.trigger('jumpPreviousBreakpoint');
  }} disabled=${this.jumpPreviousBreakpointDisabled} ></button>
      <button class='btn btn-primary btn-sm ${css.navigator} ${css.jumpButton} fas fa-eject' id='jumpout' title='Jump out' onclick=${function () {
    self.event.trigger('jumpOut');
  }} disabled=${this.jumpOutDisabled} ></button>
      <button class='btn btn-primary btn-sm ${css.navigator} ${css.jumpButton} fas fa-step-forward' id='jumpnextbreakpoint' data-id="buttonNavigatorJumpNextBreakpoint" title='Jump to the next breakpoint' onclick=${function () {
    self.event.trigger('jumpNextBreakpoint');
  }} disabled=${this.jumpNextBreakpointDisabled} ></button>
    </div>
    <div id='reverted' style="display:none">
      <button class='btn btn-danger btn-sm' id='jumptoexception' title='Jump to exception' class='${css.navigator} ${css.button} fas fa-exclamation-triangle' onclick=${function () {
    self.event.trigger('jumpToException');
  }} disabled=${this.jumpOutDisabled} >
      </button>
      <span>State changes made during this call will be reverted.</span>
      <span id='outofgas' style="display:none">This call will run out of gas.</span>
      <span id='parenthasthrown' style="display:none">The parent call will throw an exception</span>
    </div>
  </div>`;

  if (!this.view) {
    this.view = view;
  }

  return view;
};

ButtonNavigator.prototype.reset = function () {
  this.intoBackDisabled = true;
  this.overBackDisabled = true;
  this.intoForwardDisabled = true;
  this.overForwardDisabled = true;
  this.jumpOutDisabled = true;
  this.jumpNextBreakpointDisabled = true;
  this.jumpPreviousBreakpointDisabled = true;
  this.resetWarning('');
};

ButtonNavigator.prototype.stepChanged = function (stepState, jumpOutDisabled) {
  if (stepState === 'invalid') {
    // TODO: probably not necessary, already implicit done in the next steps
    this.reset();
    this.updateAll();
    return;
  }

  this.intoBackDisabled = stepState === 'initial';
  this.overBackDisabled = stepState === 'initial';
  this.jumpPreviousBreakpointDisabled = stepState === 'initial';
  this.jumpNextBreakpointDisabled = stepState === 'end';
  this.intoForwardDisabled = stepState === 'end';
  this.overForwardDisabled = stepState === 'end';
  this.jumpNextBreakpointDisabled = jumpOutDisabled;
  this.updateAll();
};

ButtonNavigator.prototype.updateAll = function () {
  this.updateDisabled('intoback', this.intoBackDisabled);
  this.updateDisabled('overback', this.overBackDisabled);
  this.updateDisabled('overforward', this.overForwardDisabled);
  this.updateDisabled('intoforward', this.intoForwardDisabled);
  this.updateDisabled('jumpout', this.jumpOutDisabled);
  this.updateDisabled('jumptoexception', this.jumpOutDisabled);
  this.updateDisabled('jumpnextbreakpoint', this.jumpNextBreakpointDisabled);
  this.updateDisabled('jumppreviousbreakpoint', this.jumpPreviousBreakpointDisabled);
};

ButtonNavigator.prototype.updateDisabled = function (id, disabled) {
  if (disabled) {
    document.getElementById(id).setAttribute('disabled', true);
  } else {
    document.getElementById(id).removeAttribute('disabled');
  }
};

ButtonNavigator.prototype.resetWarning = function (revertedReason) {
  if (!this.view) return;
  this.view.querySelector('#reverted #outofgas').style.display = revertedReason === 'outofgas' ? 'inline' : 'none';
  this.view.querySelector('#reverted #parenthasthrown').style.display = revertedReason === 'parenthasthrown' ? 'inline' : 'none';
  this.view.querySelector('#reverted').style.display = revertedReason === '' ? 'none' : 'block';
};

module.exports = ButtonNavigator;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/Slider.js":
/*!************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/Slider.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventManager = __webpack_require__(/*! ../../../../lib/events */ "./lib/events.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

class Slider {
  constructor() {
    this.event = new EventManager();
    this.max;
    this.disabled = true;
    this.view;
    this.previousValue = null;
  }

  setSliderLength(length) {
    if (!this.view) return;
    this.view.querySelector('#slider').setAttribute('max', length - 1);
    this.max = length - 1;
    this.disabled = length === 0;

    if (this.disabled) {
      this.view.querySelector('#slider').setAttribute('disabled', true);
    } else {
      this.view.querySelector('#slider').removeAttribute('disabled');
    }

    this.setValue(0);
  }

  onChange(event) {
    if (!this.view) return;
    var value = parseInt(this.view.querySelector('#slider').value);
    if (value === this.previousValue) return;
    this.previousValue = value;
    this.event.trigger('sliderMoved', [value]);
  }

  setValue(value) {
    if (!this.view) return;
    this.view.querySelector('#slider').value = value;
  }

  render() {
    var self = this;
    var view = yo`<div>
        <input id='slider' data-id="slider" class='w-100 my-0' type='range' min=0 max=${this.max} value=0
          onchange=${function () {
      self.onChange();
    }} oninput=${function () {
      self.onChange();
    }} disabled=${this.disabled} />
      </div>`;

    if (!this.view) {
      this.view = view;
    }

    return view;
  }

}

module.exports = Slider;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/StepManager.js":
/*!*****************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/StepManager.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventManager = __webpack_require__(/*! ../../../../lib/events */ "./lib/events.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var ButtonNavigator = __webpack_require__(/*! ./ButtonNavigator */ "./app/tabs/debugger/debuggerUI/ButtonNavigator.js");

var Slider = __webpack_require__(/*! ./Slider */ "./app/tabs/debugger/debuggerUI/Slider.js");

function StepManager(stepManager) {
  this.event = new EventManager();
  this.stepManager = stepManager;
  this.startSlider();
  this.startButtonNavigator();
  this.stepManager.event.register('stepChanged', this.updateStep.bind(this));
}

StepManager.prototype.startSlider = function () {
  this.slider = new Slider();
  this.slider.event.register('sliderMoved', this.stepManager.jumpTo.bind(this.stepManager));
  this.stepManager.event.register('traceLengthChanged', this.slider.setSliderLength.bind(this.slider));
};

StepManager.prototype.startButtonNavigator = function () {
  this.buttonNavigator = new ButtonNavigator();
  this.stepManager.event.register('revertWarning', this.buttonNavigator.resetWarning.bind(this.buttonNavigator));
  this.buttonNavigator.event.register('stepIntoBack', this.stepManager.stepIntoBack.bind(this.stepManager));
  this.buttonNavigator.event.register('stepIntoForward', this.stepManager.stepIntoForward.bind(this.stepManager));
  this.buttonNavigator.event.register('stepOverBack', this.stepManager.stepOverBack.bind(this.stepManager));
  this.buttonNavigator.event.register('stepOverForward', this.stepManager.stepOverForward.bind(this.stepManager));
  this.buttonNavigator.event.register('jumpOut', this.stepManager.jumpOut.bind(this.stepManager));
  this.buttonNavigator.event.register('jumpToException', this.stepManager.jumpToException.bind(this.stepManager));
  this.buttonNavigator.event.register('jumpNextBreakpoint', this.stepManager.jumpNextBreakpoint.bind(this.stepManager));
  this.buttonNavigator.event.register('jumpPreviousBreakpoint', this.stepManager.jumpPreviousBreakpoint.bind(this.stepManager));
};

StepManager.prototype.updateStep = function (step, stepState, jumpOutDisabled) {
  if (!this.slider) return;
  this.slider.setValue(step);
  this.buttonNavigator.stepChanged(stepState, jumpOutDisabled);
  this.event.trigger('stepChanged', [step]);
};

StepManager.prototype.remove = function () {
  // used to stop listenning on event. bad and should be "refactored"
  this.slider.view = null;
  this.slider = null;
  this.buttonNavigator.view = null;
  this.buttonNavigator = null;
};

StepManager.prototype.render = function () {
  return yo`
    <div class="py-1">
      ${this.slider.render()}
      ${this.buttonNavigator.render()}
    </div>`;
};

module.exports = StepManager;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/TxBrowser.js":
/*!***************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/TxBrowser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventManager = __webpack_require__(/*! ../../../../lib/events */ "./lib/events.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .container {
    display: flex;
    flex-direction: column;
  }
  .txContainer {
    display: flex;
    flex-direction: column;
  }
  .txinput {
    width: inherit;
    font-size: small;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .txbutton {
    width: inherit;
  }
  .txbutton:hover {
  }
  .vmargin {
    margin-top: 10px;
    margin-bottom: 10px;
  }
`;

function TxBrowser() {
  this.event = new EventManager();
  this.state = {
    txNumber: undefined,
    debugging: false
  };
  this.view;
}

TxBrowser.prototype.submit = function () {
  if (this.state.debugging) {
    this.unload();
  } else {
    this.event.trigger('requestDebug', [undefined, this.state.txNumber]);
  }

  yo.update(this.view, this.render());
};

TxBrowser.prototype.updateTxN = function (ev) {
  this.state.txNumber = ev.target.value;

  if (this.view) {
    yo.update(this.view, this.render());
  }
};

TxBrowser.prototype.load = function (txHash, tx) {
  this.state.txNumber = txHash;
};

TxBrowser.prototype.unload = function () {
  this.event.trigger('unloadRequested');
};

TxBrowser.prototype.setState = function (state) {
  this.state = { ...this.state,
    ...state
  };

  if (this.view) {
    yo.update(this.view, this.render());
  }
};

TxBrowser.prototype.render = function () {
  var self = this;
  this.state.txNumberInput = yo`
    <input
      value="${this.state.txNumber || ''}"
      class="form-control m-0 ${css.txinput}"
      id='txinput'
      onkeyup=${function () {
    self.updateTxN(arguments[0]);
  }}
      type='text'
      oninput=${this.txInputChanged.bind(this)}
      placeholder=${'Transaction hash, should start with 0x'}
      data-id="debuggerTransactionInput"
    />
  `;
  let txButton = yo`
    <button
      class='btn btn-primary btn-sm ${css.txbutton}'
      id='load'
      title='${this.state.debugging ? 'Stop' : 'Start'} debugging'
      onclick=${function () {
    self.submit();
  }}
      data-id="debuggerTransactionStartButton"
    >
      ${this.state.debugging ? 'Stop' : 'Start'} debugging
    </button>
  `;
  var view = yo`
    <div class="${css.container}">
      <div class="${css.txContainer}">
        <div class=" py-1 d-flex justify-content-center w-100 input-group">
          ${this.state.txNumberInput}
        </div>
        <div class="d-flex justify-content-center w-100 btn-group py-1">
          ${txButton}
        </div>
      </div>
      <span id='error'></span>
    </div>
  `;

  if (this.state.debugging) {
    view.querySelectorAll('input').forEach(element => {
      element.setAttribute('disabled', '');
    });
  }

  if (!this.state.txNumber) {
    view.querySelector("button[id='load']").setAttribute('disabled', '');
  } else if (!this.state.debugging) {
    this.state.txNumberInput.removeAttribute('disabled');
  }

  if (!this.view) {
    this.view = view;
  }

  return view;
};

TxBrowser.prototype.txInputChanged = function (event) {
  // todo check validation of txnumber in the input element, use
  // required
  // oninvalid="setCustomValidity('Please provide a valid transaction number, must start with 0x and have length of 22')"
  // pattern="^0[x,X]+[0-9a-fA-F]{22}"
  // this.state.txNumberInput.setCustomValidity('')
  this.state.txNumber = event.target.value;
  yo.update(this.view, this.render());
};

module.exports = TxBrowser;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/VmDebugger.js":
/*!****************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/VmDebugger.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var CodeListView = __webpack_require__(/*! ./vmDebugger/CodeListView */ "./app/tabs/debugger/debuggerUI/vmDebugger/CodeListView.js");

var CalldataPanel = __webpack_require__(/*! ./vmDebugger/CalldataPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/CalldataPanel.js");

var MemoryPanel = __webpack_require__(/*! ./vmDebugger/MemoryPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/MemoryPanel.js");

var CallstackPanel = __webpack_require__(/*! ./vmDebugger/CallstackPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/CallstackPanel.js");

var FunctionPanel = __webpack_require__(/*! ./vmDebugger/FunctionPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/FunctionPanel.js");

var StackPanel = __webpack_require__(/*! ./vmDebugger/StackPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/StackPanel.js");

var StoragePanel = __webpack_require__(/*! ./vmDebugger/StoragePanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/StoragePanel.js");

var StepDetail = __webpack_require__(/*! ./vmDebugger/StepDetail */ "./app/tabs/debugger/debuggerUI/vmDebugger/StepDetail.js");

var SolidityState = __webpack_require__(/*! ./vmDebugger/SolidityState */ "./app/tabs/debugger/debuggerUI/vmDebugger/SolidityState.js");

var SolidityLocals = __webpack_require__(/*! ./vmDebugger/SolidityLocals */ "./app/tabs/debugger/debuggerUI/vmDebugger/SolidityLocals.js");

var FullStoragesChangesPanel = __webpack_require__(/*! ./vmDebugger/FullStoragesChanges */ "./app/tabs/debugger/debuggerUI/vmDebugger/FullStoragesChanges.js");

var DropdownPanel = __webpack_require__(/*! ./vmDebugger/DropdownPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js");

function VmDebugger(vmDebuggerLogic) {
  var self = this;
  this.view;
  this.vmDebuggerLogic = vmDebuggerLogic;
  this.asmCode = new CodeListView();
  this.vmDebuggerLogic.event.register('codeManagerChanged', this.asmCode.changed.bind(this.asmCode));
  this.vmDebuggerLogic.event.register('traceUnloaded', this.asmCode.reset.bind(this.asmCode));
  this.calldataPanel = new CalldataPanel();
  this.vmDebuggerLogic.event.register('traceManagerCallDataUpdate', this.calldataPanel.update.bind(this.calldataPanel));
  this.memoryPanel = new MemoryPanel();
  this.vmDebuggerLogic.event.register('traceManagerMemoryUpdate', this.memoryPanel.update.bind(this.memoryPanel));
  this.callstackPanel = new CallstackPanel();
  this.vmDebuggerLogic.event.register('traceManagerCallStackUpdate', this.callstackPanel.update.bind(this.callstackPanel));
  this.stackPanel = new StackPanel();
  this.vmDebuggerLogic.event.register('traceManagerStackUpdate', this.stackPanel.update.bind(this.stackPanel));
  this.functionPanel = new FunctionPanel();
  this.vmDebuggerLogic.event.register('functionsStackUpdate', stack => {
    if (stack === null) return;
    let functions = [];

    for (let func of stack) {
      functions.push(func.functionDefinition.attributes.name + '(' + func.inputs.join(', ') + ')');
    }

    this.functionPanel.update(functions);
  });
  this.storagePanel = new StoragePanel();
  this.vmDebuggerLogic.event.register('traceManagerStorageUpdate', this.storagePanel.update.bind(this.storagePanel));
  this.stepDetail = new StepDetail();
  this.vmDebuggerLogic.event.register('traceUnloaded', this.stepDetail.reset.bind(this.stepDetail));
  this.vmDebuggerLogic.event.register('newTraceLoaded', this.stepDetail.reset.bind(this.stepDetail));
  this.vmDebuggerLogic.event.register('traceCurrentStepUpdate', function (error, step) {
    self.stepDetail.updateField('execution step', error ? '-' : step);
  });
  this.vmDebuggerLogic.event.register('traceMemExpandUpdate', function (error, addmem) {
    self.stepDetail.updateField('add memory', error ? '-' : addmem);
  });
  this.vmDebuggerLogic.event.register('traceStepCostUpdate', function (error, gas) {
    self.stepDetail.updateField('gas', error ? '-' : gas);
  });
  this.vmDebuggerLogic.event.register('traceCurrentCalledAddressAtUpdate', function (error, address) {
    self.stepDetail.updateField('loaded address', error ? '-' : address);
  });
  this.vmDebuggerLogic.event.register('traceRemainingGasUpdate', function (error, remainingGas) {
    self.stepDetail.updateField('remaining gas', error ? '-' : remainingGas);
  });
  this.vmDebuggerLogic.event.register('indexUpdate', function (index) {
    self.stepDetail.updateField('vm trace step', index);
  });
  this.solidityState = new SolidityState();
  this.vmDebuggerLogic.event.register('solidityState', this.solidityState.update.bind(this.solidityState));
  this.vmDebuggerLogic.event.register('solidityStateMessage', this.solidityState.setMessage.bind(this.solidityState));
  this.vmDebuggerLogic.event.register('solidityStateUpdating', this.solidityState.setUpdating.bind(this.solidityState));
  this.solidityLocals = new SolidityLocals();
  this.vmDebuggerLogic.event.register('solidityLocals', this.solidityLocals.update.bind(this.solidityLocals));
  this.vmDebuggerLogic.event.register('solidityLocalsMessage', this.solidityLocals.setMessage.bind(this.solidityLocals));
  this.vmDebuggerLogic.event.register('solidityLocalsUpdating', this.solidityLocals.setUpdating.bind(this.solidityLocals));
  this.returnValuesPanel = new DropdownPanel('Return Value', {
    json: true
  });
  this.returnValuesPanel.data = {};
  this.vmDebuggerLogic.event.register('traceReturnValueUpdate', this.returnValuesPanel.update.bind(this.returnValuesPanel));
  this.fullStoragesChangesPanel = new FullStoragesChangesPanel();
  this.addresses = [];
  this.vmDebuggerLogic.event.register('traceAddressesUpdate', function (_addresses) {
    self.fullStoragesChangesPanel.update({});
  });
  this.vmDebuggerLogic.event.register('traceStorageUpdate', this.fullStoragesChangesPanel.update.bind(this.fullStoragesChangesPanel));
  this.vmDebuggerLogic.event.register('newTrace', () => {
    if (!self.view) return;
    self.asmCode.basicPanel.show();
    self.stackPanel.basicPanel.show();
    self.functionPanel.basicPanel.show();
    self.storagePanel.basicPanel.show();
    self.memoryPanel.basicPanel.show();
    self.stepDetail.basicPanel.show();
    self.calldataPanel.basicPanel.show();
    self.callstackPanel.basicPanel.show();
  });
  this.vmDebuggerLogic.event.register('newCallTree', () => {
    if (!self.view) return;
    self.functionPanel.basicPanel.show();
    self.solidityLocals.basicPanel.show();
    self.solidityState.basicPanel.show();
    self.solidityPanel.hidden = false;
  });
  this.vmDebuggerLogic.start();
}

VmDebugger.prototype.renderHead = function () {
  this.solidityPanel = yo`
    <div class="w-100" hidden>
      ${this.functionPanel.render()}
      ${this.solidityLocals.render()}
      ${this.solidityState.render()}
    </div>
  `;
  const headView = yo`
    <div id="vmheadView" class="mt-1 px-0">
      <div class="d-flex flex-column">
        ${this.solidityPanel}
        <div class="w-100">${this.asmCode.render()}</div>
        <div class="w-100">${this.stepDetail.render()}</div>
      </div>
    </div>
  `;

  if (!this.headView) {
    this.headView = headView;
  }

  return headView;
};

VmDebugger.prototype.remove = function () {
  // used to stop listenning on event. bad and should be "refactored"
  this.view = null;
};

VmDebugger.prototype.render = function () {
  const view = yo`
    <div id="vmdebugger" class="px-2">
      <div>
        ${this.stackPanel.render()}
        ${this.memoryPanel.render()}
        ${this.storagePanel.render()}
        ${this.callstackPanel.render()}
        ${this.calldataPanel.render()}
        ${this.returnValuesPanel.render()}
        ${this.fullStoragesChangesPanel.render()}
      </div>
    </div>
  `;

  if (!this.view) {
    this.view = view;
  }

  return view;
};

module.exports = VmDebugger;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/styles/basicStyles.js":
/*!************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/styles/basicStyles.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  truncate: {
    'white-space': 'nowrap',
    'overflow': 'hidden',
    'text-overflow': 'ellipsis',
    'margin-right': '5px'
  },
  font: {
    'font-family': 'arial,sans-serif'
  },
  statusMessage: {
    'margin-left': '15px'
  },
  address: {
    'font-style': 'italic'
  },
  instructionsList: {
    'width': '52%',
    'overflow-y': 'scroll',
    'max-height': '250px',
    'margin': '0',
    'margin-left': '10px',
    'padding': '2px'
  },
  transactionInfo: {
    'margin-top': '5px'
  },
  panel: {
    container: {
      'border': '1px solid',
      'width': '70%'
    },
    tableContainer: {
      'height': '50%',
      'overflow-y': 'auto'
    },
    table: {
      'padding': '5px'
    },
    title: {
      'padding': '5px',
      'font-style': 'italic'
    }
  },
  hidden: {
    'display': 'none'
  },
  display: {
    'display': 'block'
  },
  inline: {
    'display': 'inline-block'
  },
  vmargin: {
    'margin-top': '10px',
    'margin-bottom': '10px'
  },
  button: {
    'border-color': 'transparent',
    'border-radius': '3px',
    'border': '.3px solid hsla(0, 0%, 40%, 1)',
    'cursor': 'pointer',
    'min-height': '25px',
    'max-height': '25px',
    'padding': '3px',
    'min-width': '100px',
    'font-size': '12px',
    'overflow': 'hidden',
    'word-break': 'normal',
    'background-color': 'hsla(0, 0%, 40%, .2)',
    'color': 'hsla(0, 0%, 40%, 1)',
    'margin': '3px',
    'text-decoration': 'none'
  }
};

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/CalldataPanel.js":
/*!******************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/CalldataPanel.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DropdownPanel = __webpack_require__(/*! ./DropdownPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

function CalldataPanel() {
  this.basicPanel = new DropdownPanel('Call Data', {
    json: true
  });
}

CalldataPanel.prototype.update = function (calldata) {
  this.basicPanel.update(calldata);
};

CalldataPanel.prototype.render = function () {
  return yo`<div id='calldatapanel' >${this.basicPanel.render()}</div>`;
};

module.exports = CalldataPanel;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/CallstackPanel.js":
/*!*******************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/CallstackPanel.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DropdownPanel = __webpack_require__(/*! ./DropdownPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

function CallstackPanel() {
  this.basicPanel = new DropdownPanel('Call Stack', {
    json: true
  });
}

CallstackPanel.prototype.update = function (calldata) {
  this.basicPanel.update(calldata);
};

CallstackPanel.prototype.render = function () {
  return yo`<div id='callstackpanel' >${this.basicPanel.render()}</div>`;
};

module.exports = CallstackPanel;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/CodeListView.js":
/*!*****************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/CodeListView.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var style = __webpack_require__(/*! ../styles/basicStyles */ "./app/tabs/debugger/debuggerUI/styles/basicStyles.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var DropdownPanel = __webpack_require__(/*! ./DropdownPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js");

var EventManager = __webpack_require__(/*! ../../../../../lib/events */ "./lib/events.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .instructions {
    overflow-y: scroll;
    max-height: 130px;
  }
`;

function CodeListView() {
  this.event = new EventManager();
  this.code;
  this.address;
  this.itemSelected;
  this.basicPanel = new DropdownPanel('Instructions', {
    json: false,
    displayContentOnly: true
  });
  this.basicPanel.event.register('hide', () => {
    this.event.trigger('hide', []);
  });
  this.basicPanel.event.register('show', () => {
    this.event.trigger('show', []);
  });
}

CodeListView.prototype.render = function () {
  this.view = yo`<div id='asmcodes' >${this.basicPanel.render({
    height: style.instructionsList.height
  })}</div>`;
  return this.view;
};

CodeListView.prototype.indexChanged = function (index) {
  if (index < 0) return;

  if (this.itemSelected) {
    this.itemSelected.removeAttribute('selected');
    this.itemSelected.removeAttribute('style');

    if (this.itemSelected.firstChild) {
      this.itemSelected.firstChild.removeAttribute('style');
    }
  }

  let codeView = this.view.querySelector('#asmitems');
  this.itemSelected = codeView.children[index];
  this.itemSelected.style.setProperty('border-color', 'var(--primary)');
  this.itemSelected.style.setProperty('border-style', 'solid');
  this.itemSelected.setAttribute('selected', 'selected');
  codeView.scrollTop = this.itemSelected.offsetTop - parseInt(codeView.offsetTop);
};

CodeListView.prototype.reset = function () {
  this.changed([], '', -1);
};

CodeListView.prototype.changed = function (code, address, index) {
  if (this.address === address) {
    return this.indexChanged(index);
  }

  this.code = code;
  this.address = address;
  this.basicPanel.setContent(this.renderAssemblyItems());
  this.indexChanged(index);
};

CodeListView.prototype.renderAssemblyItems = function () {
  if (this.code) {
    var codeView = this.code.map(function (item, i) {
      return yo`<div class="px-1" key=${i} value=${i}><span>${item}</span></div>`;
    });
    return yo`<div class="pl-2 my-1 small ${css.instructions}" id='asmitems' ref='itemsList'>
      ${codeView}
    </div>`;
  }
};

module.exports = CodeListView;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js":
/*!******************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const copyToClipboard = __webpack_require__(/*! ../../../../ui/copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

const EventManager = __webpack_require__(/*! ../../../../../lib/events */ "./lib/events.js");

const TreeView = __webpack_require__(/*! ../../../../ui/TreeView */ "./app/ui/TreeView.js"); // TODO setup a direct reference to the UI components


const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const css = csjs`
  .title {
    display: flex;
    align-items: center;
  }
  .name {
    font-weight: bold;
  }
  .nameDetail {
    font-weight: bold;
    margin-left: 3px;
  }
  .icon {
    margin-right: 5%;
  }
  .eyeButton {
    margin: 3px;
  }
  .dropdownpanel {
    width: 100%;
    word-break: break-word;
  }
  .dropdownrawcontent {
    padding: 2px;
    word-break: break-word;
  }
  .message {
    padding: 2px;
    word-break: break-word;
  }
  .refresh {
    display: none;
    margin-left: 4px;
    margin-top: 4px; 
    animation: spin 2s linear infinite;
  }
`;

function DropdownPanel(_name, _opts) {
  this.event = new EventManager();

  if (!_opts) {
    _opts = {};
  }

  this.name = _name;
  this.header = '';
  this.json = _opts.json;
  this.displayContentOnly = _opts.displayContentOnly;

  if (this.json) {
    this.treeView = new TreeView(_opts);
  }

  this.view;
}

DropdownPanel.prototype.setMessage = function (message) {
  if (!this.view) return;
  this.view.querySelector('.dropdownpanel .dropdownrawcontent').style.display = 'none';
  this.view.querySelector('.dropdownpanel .dropdowncontent').style.display = 'none';
  this.view.querySelector('.dropdownpanel > i').style.display = 'none';
  this.message(message);
};

DropdownPanel.prototype.setLoading = function () {
  if (!this.view) return;
  this.view.querySelector('.dropdownpanel .dropdownrawcontent').style.display = 'none';
  this.view.querySelector('.dropdownpanel .dropdowncontent').style.display = 'none';
  this.view.querySelector('.dropdownpanel > i').style.display = 'inline-block';
  this.message('');
};

DropdownPanel.prototype.setUpdating = function () {
  if (!this.view) return;
};

DropdownPanel.prototype.update = function (_data, _header) {
  if (!this.view) return;
  this.view.querySelector('.dropdownpanel > i').style.display = 'none';
  this.view.querySelector('.dropdownpanel .dropdowncontent').style.display = 'block';
  this.view.querySelector('.dropdownpanel .dropdownrawcontent').innerText = JSON.stringify(_data, null, '\t');

  if (!this.displayContentOnly) {
    this.view.querySelector('.title i.fa-copy').style.display = 'block';
    this.view.querySelector('.title span').innerText = _header || ' ';
  }

  this.message('');

  if (this.json) {
    this.treeView.update(_data);
  }
};

DropdownPanel.prototype.setContent = function (node) {
  if (!this.view) return;
  yo.update(this.view, this.render(null, node));
};

DropdownPanel.prototype.copyClipboard = function () {
  const content = this.view.querySelector('.dropdownpanel .dropdownrawcontent');
  return content.innerText ? content.innerText : content.textContent;
};

DropdownPanel.prototype.render = function (overridestyle, node) {
  var content = yo`<div>Empty</div>`;

  if (this.json) {
    content = this.treeView.render({});
  }

  overridestyle === undefined ? {} : overridestyle;
  var self = this;
  var contentNode = yo`
    <div class='dropdownpanel ${css.dropdownpanel}' style='display:none'>
      <i class="${css.refresh} fas fa-sync" aria-hidden="true"></i>
      <div class='dropdowncontent'>${node || content}</div>
      <div class='dropdownrawcontent' style='display:none'></div>
      <div class='message' style='display:none'></div>
    </div>`;
  var title = !self.displayContentOnly ? yo`<div class="${css.title} py-0 px-1 title">
      <div class="${css.icon} fas fa-caret-right" onclick=${function () {
    self.toggle();
  }} ></div>
      <div class="${css.name}" onclick=${function () {
    self.toggle();
  }} >${this.name}</div><span class="${css.nameDetail}" onclick=${function () {
    self.toggle();
  }} ></span>
      ${copyToClipboard(() => this.copyClipboard())}
    </div>` : yo`<div></div>`;
  var view = yo`
    <div class="border rounded px-1 mt-1 bg-light">
    <style>
      @-moz-keyframes spin {
        to { -moz-transform: rotate(359deg); }
      }
      @-webkit-keyframes spin {
        to { -webkit-transform: rotate(359deg); }
      }
      @keyframes spin {
        to {transform:rotate(359deg);}
      }
    </style>
    ${title}
    ${contentNode}
    </div>`;

  if (!this.view) {
    this.view = view;
  }

  if (self.displayContentOnly) contentNode.style.display = 'block';
  return view;
};

DropdownPanel.prototype.toggle = function () {
  var el = this.view.querySelector('.dropdownpanel');
  var caret = this.view.querySelector('.title').firstElementChild;

  if (el.style.display === '') {
    el.style.display = 'none';
    caret.className = `${css.icon} fas fa-caret-right`;
    this.event.trigger('hide', []);
  } else {
    el.style.display = '';
    caret.className = `${css.icon} fas fa-caret-down`;
    this.event.trigger('show', []);
  }
};

DropdownPanel.prototype.hide = function () {
  if (!(this.view && !this.displayContentOnly)) return;
  var caret = this.view.querySelector('.title').firstElementChild;
  var el = this.view.querySelector('.dropdownpanel');
  el.style.display = 'none';
  caret.className = `${css.icon} fas fa-caret-right`;
  this.event.trigger('hide', []);
};

DropdownPanel.prototype.show = function () {
  if (!(this.view && !this.displayContentOnly)) return;
  var caret = this.view.querySelector('.title').firstElementChild;
  var el = this.view.querySelector('.dropdownpanel');
  el.style.display = '';
  caret.className = `${css.icon} fas fa-caret-down`;
  this.event.trigger('show', []);
};

DropdownPanel.prototype.message = function (message) {
  if (!this.view) return;
  var mes = this.view.querySelector('.dropdownpanel .message');
  mes.innerText = message;
  mes.style.display = message === '' ? 'none' : 'block';
};

module.exports = DropdownPanel;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/FullStoragesChanges.js":
/*!************************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/FullStoragesChanges.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DropdownPanel = __webpack_require__(/*! ./DropdownPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

function FullStoragesChanges() {
  this.view;
  this.basicPanel = new DropdownPanel('Full Storages Changes', {
    json: true
  });
}

FullStoragesChanges.prototype.update = function (storageData) {
  this.basicPanel.update(storageData);
};

FullStoragesChanges.prototype.render = function () {
  var view = yo`<div id='fullstorageschangespanel' >${this.basicPanel.render()}</div>`;

  if (!this.view) {
    this.view = view;
  }

  return view;
};

module.exports = FullStoragesChanges;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/FunctionPanel.js":
/*!******************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/FunctionPanel.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DropdownPanel = __webpack_require__(/*! ./DropdownPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

function FunctionPanel() {
  this.basicPanel = new DropdownPanel('Function Stack', {
    json: true,
    displayContentOnly: false
  });
}

FunctionPanel.prototype.update = function (calldata) {
  this.basicPanel.update(calldata);
};

FunctionPanel.prototype.render = function () {
  return yo`<div id="FunctionPanel">${this.basicPanel.render()}</div>`;
};

module.exports = FunctionPanel;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/MemoryPanel.js":
/*!****************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/MemoryPanel.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DropdownPanel = __webpack_require__(/*! ./DropdownPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

function MemoryPanel() {
  this.basicPanel = new DropdownPanel('Memory', {
    json: true,
    css: {
      'font-family': 'monospace'
    }
  });
}

MemoryPanel.prototype.update = function (calldata) {
  this.basicPanel.update(calldata);
};

MemoryPanel.prototype.render = function () {
  return yo`<div id="memorypanel">${this.basicPanel.render()}</div>`;
};

module.exports = MemoryPanel;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/SolidityLocals.js":
/*!*******************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/SolidityLocals.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventManager = __webpack_require__(/*! ../../../../../lib/events */ "./lib/events.js");

var DropdownPanel = __webpack_require__(/*! ./DropdownPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js");

var solidityTypeFormatter = __webpack_require__(/*! ./utils/SolidityTypeFormatter */ "./app/tabs/debugger/debuggerUI/vmDebugger/utils/SolidityTypeFormatter.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

class SolidityLocals {
  constructor(_parent, _traceManager, _internalTreeCall) {
    this.event = new EventManager();
    this.basicPanel = new DropdownPanel('Solidity Locals', {
      json: true,
      formatSelf: solidityTypeFormatter.formatSelf,
      extractData: solidityTypeFormatter.extractData
    });
    this.view;
  }

  update(data) {
    this.basicPanel.update(data);
  }

  setMessage(message) {
    this.basicPanel.setMessage(message);
  }

  setUpdating() {
    this.basicPanel.setUpdating();
  }

  render() {
    this.view = yo`<div id='soliditylocals' data-id="solidityLocals">${this.basicPanel.render()}</div>`;
    return this.view;
  }

}

module.exports = SolidityLocals;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/SolidityState.js":
/*!******************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/SolidityState.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DropdownPanel = __webpack_require__(/*! ./DropdownPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js");

var solidityTypeFormatter = __webpack_require__(/*! ./utils/SolidityTypeFormatter */ "./app/tabs/debugger/debuggerUI/vmDebugger/utils/SolidityTypeFormatter.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

function SolidityState() {
  this.basicPanel = new DropdownPanel('Solidity State', {
    json: true,
    // TODO: used by TreeView ui
    formatSelf: solidityTypeFormatter.formatSelf,
    extractData: solidityTypeFormatter.extractData
  });
  this.view;
}

SolidityState.prototype.update = function (data) {
  this.basicPanel.update(data);
};

SolidityState.prototype.setMessage = function (message) {
  this.basicPanel.setMessage(message);
};

SolidityState.prototype.setUpdating = function () {
  this.basicPanel.setUpdating();
};

SolidityState.prototype.render = function () {
  if (this.view) return;
  this.view = yo`
    <div id='soliditystate' >
      ${this.basicPanel.render()}
    </div>`;
  return this.view;
};

module.exports = SolidityState;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/StackPanel.js":
/*!***************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/StackPanel.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DropdownPanel = __webpack_require__(/*! ./DropdownPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

function StackPanel() {
  this.basicPanel = new DropdownPanel('Stack', {
    json: true,
    displayContentOnly: false
  });
}

StackPanel.prototype.update = function (calldata) {
  this.basicPanel.update(calldata);
};

StackPanel.prototype.render = function () {
  return yo`<div id="stackpanel">${this.basicPanel.render()}</div>`;
};

module.exports = StackPanel;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/StepDetail.js":
/*!***************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/StepDetail.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var DropdownPanel = __webpack_require__(/*! ./DropdownPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js");

function StepDetail() {
  this.basicPanel = new DropdownPanel('Step details', {
    json: true,
    displayContentOnly: false
  });
  this.detail = {
    'vm trace step': '-',
    'execution step': '-',
    'add memory': '',
    'gas': '',
    'remaining gas': '-',
    'loaded address': '-'
  };
}

StepDetail.prototype.reset = function () {
  this.detail = {
    'vm trace step': '-',
    'execution step': '-',
    'add memory': '',
    'gas': '',
    'remaining gas': '-',
    'loaded address': '-'
  };
  this.basicPanel.update(this.detail);
};

StepDetail.prototype.updateField = function (key, value) {
  this.detail[key] = value;
  this.basicPanel.update(this.detail);
};

StepDetail.prototype.render = function () {
  return yo`<div id='stepdetail' data-id="stepdetail">${this.basicPanel.render()}</div>`;
};

module.exports = StepDetail;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/StoragePanel.js":
/*!*****************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/StoragePanel.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DropdownPanel = __webpack_require__(/*! ./DropdownPanel */ "./app/tabs/debugger/debuggerUI/vmDebugger/DropdownPanel.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

function StoragePanel(_parent, _traceManager) {
  this.basicPanel = new DropdownPanel('Storage', {
    json: true
  });
}

StoragePanel.prototype.update = function (storage, header) {
  this.basicPanel.update(storage, header);
};

StoragePanel.prototype.render = function () {
  return yo`<div id='storagepanel' >${this.basicPanel.render()}</div>`;
};

module.exports = StoragePanel;

/***/ }),

/***/ "./app/tabs/debugger/debuggerUI/vmDebugger/utils/SolidityTypeFormatter.js":
/*!********************************************************************************!*\
  !*** ./app/tabs/debugger/debuggerUI/vmDebugger/utils/SolidityTypeFormatter.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var BN = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js").BN;

module.exports = {
  formatSelf: formatSelf,
  extractData: extractData
};

function formatSelf(key, data) {
  const style = fontColor(data);
  const keyStyle = data.isProperty ? 'color: var(--info)' : '';

  if (data.type === 'string') {
    data.self = JSON.stringify(data.self);
  }

  return yo`<label class="mb-0" style='${keyStyle};white-space:pre-wrap;'> ${' ' + key}:<label class="mb-0" style=${style}>${' ' + data.self}</label><label style='font-style:italic'> ${data.isProperty || !data.type ? '' : ' ' + data.type}</label></label>`;
}

function extractData(item, parent, key) {
  var ret = {};

  if (item.isProperty) {
    return item;
  }

  if (item.type.lastIndexOf(']') === item.type.length - 1) {
    ret.children = (item.value || []).map(function (item, index) {
      return {
        key: index,
        value: item
      };
    });
    ret.children.unshift({
      key: 'length',
      value: {
        self: new BN(item.length.replace('0x', ''), 16).toString(10),
        type: 'uint',
        isProperty: true
      }
    });
    ret.isArray = true;
    ret.self = parent.isArray ? '' : item.type;
  } else if (item.type.indexOf('struct') === 0) {
    ret.children = Object.keys(item.value || {}).map(function (key) {
      return {
        key: key,
        value: item.value[key]
      };
    });
    ret.self = item.type;
    ret.isStruct = true;
  } else if (item.type.indexOf('mapping') === 0) {
    ret.children = Object.keys(item.value || {}).map(function (key) {
      return {
        key: key,
        value: item.value[key]
      };
    });
    ret.isMapping = true;
    ret.self = item.type;
  } else {
    ret.children = null;
    ret.self = item.value;
    ret.type = item.type;
  }

  return ret;
}

function fontColor(data) {
  let color = 'var(--primary)';

  if (data.isArray || data.isStruct || data.isMapping) {
    color = 'var(--info)';
  } else if (data.type.indexOf('uint') === 0 || data.type.indexOf('int') === 0 || data.type.indexOf('bool') === 0 || data.type.indexOf('enum') === 0) {
    color = 'var(--green)';
  } else if (data.type === 'string') {
    color = 'var(--teal)';
  } else if (data.self == 0x0) {
    // eslint-disable-line
    color = 'var(--gray)';
  }

  return 'color:' + color;
}

/***/ }),

/***/ "./app/tabs/network-module.js":
/*!************************************!*\
  !*** ./app/tabs/network-module.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NetworkModule = exports.profile = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const profile = {
  name: 'network',
  description: 'Manage the network (mainnet, ropsten, goerli...) and the provider (web3, vm, injected)',
  methods: ['getNetworkProvider', 'getEndpoint', 'detectNetwork', 'addNetwork', 'removeNetwork'],
  version: packageJson.version,
  kind: 'network'
}; // Network API has :
// - events: ['providerChanged']
// - methods: ['getNetworkProvider', 'getEndpoint', 'detectNetwork', 'addNetwork', 'removeNetwork']

exports.profile = profile;

class NetworkModule extends _engine.Plugin {
  constructor(blockchain) {
    super(profile);
    this.blockchain = blockchain; // TODO: See with remix-lib to make sementic coherent

    this.blockchain.event.register('contextChanged', provider => {
      this.emit('providerChanged', provider);
    });
    /*
    // Events that could be implemented later
    executionContext.event.register('removeProvider', (provider) => {
      this.events.emit('networkRemoved', provider)
    })
    executionContext.event.register('addProvider', (provider) => {
      this.events.emit('networkAdded', provider)
    })
    executionContext.event.register('web3EndpointChanged', (provider) => {
      this.events.emit('web3EndpointChanged', provider)
    })
    */
  }
  /** Return the current network provider (web3, vm, injected) */


  getNetworkProvider() {
    return this.blockchain.getProvider();
  }
  /** Return the current network */


  detectNetwork() {
    return new Promise((resolve, reject) => {
      this.blockchain.detectNetwork((error, network) => {
        error ? reject(error) : resolve(network);
      });
    });
  }
  /** Return the url only if network provider is 'web3' */


  getEndpoint() {
    const provider = this.blockchain.getProvider();

    if (provider !== 'web3') {
      throw new Error('no endpoint: current provider is either injected or vm');
    }

    return this.blockchain.web3().currentProvider.host;
  }
  /** Add a custom network to the list of available networks */


  addNetwork(customNetwork) {
    this.blockchain.addProvider(customNetwork);
  }
  /** Remove a network to the list of availble networks */


  removeNetwork(name) {
    this.blockchain.removeProvider(name);
  }

}

exports.NetworkModule = NetworkModule;

/***/ }),

/***/ "./app/tabs/runTab/contractDropdown.js":
/*!*********************************************!*\
  !*** ./app/tabs/runTab/contractDropdown.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _publishToStorage = _interopRequireDefault(__webpack_require__(/*! ../../../publishToStorage */ "./publishToStorage.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = __webpack_require__(/*! ../styles/run-tab-styles */ "./app/tabs/styles/run-tab-styles.js");

var modalDialogCustom = __webpack_require__(/*! ../../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var EventManager = remixLib.EventManager;

var confirmDialog = __webpack_require__(/*! ../../ui/confirmDialog */ "./app/ui/confirmDialog.js");

var modalDialog = __webpack_require__(/*! ../../ui/modaldialog */ "./app/ui/modaldialog.js");

var MultiParamManager = __webpack_require__(/*! ../../ui/multiParamManager */ "./app/ui/multiParamManager.js");

class ContractDropdownUI {
  constructor(blockchain, dropdownLogic, logCallback, runView) {
    this.blockchain = blockchain;
    this.dropdownLogic = dropdownLogic;
    this.logCallback = logCallback;
    this.runView = runView;
    this.event = new EventManager();
    this.listenToEvents();
    this.ipfsCheckedState = false;
    this.exEnvironment = blockchain.getProvider();
    this.listenToContextChange();
  }

  listenToEvents() {
    this.dropdownLogic.event.register('newlyCompiled', (success, data, source, compiler, compilerFullName, file) => {
      if (!document.querySelector(`.${css.contractNames.classNames[0]}`)) return;
      var contractNames = document.querySelector(`.${css.contractNames.classNames[0]}`);
      contractNames.innerHTML = '';

      if (success) {
        this.selectContractNames.removeAttribute('disabled');
        this.dropdownLogic.getCompiledContracts(compiler, compilerFullName).forEach(contract => {
          contractNames.appendChild(yo`<option value="${contract.name}" compiler="${compilerFullName}">${contract.name} - ${file}</option>`);
        });
      } else {
        this.selectContractNames.setAttribute('disabled', true);
      }

      this.setInputParamsPlaceHolder();

      if (success) {
        this.compFails.style.display = 'none';
      } else {
        this.compFails.style.display = 'block';
      }
    });
  }

  listenToContextChange() {
    this.blockchain.event.register('contextChanged', () => {
      this.blockchain.updateNetwork((err, {
        name
      } = {}) => {
        if (err) {
          console.log(`can't detect network`);
          return;
        }

        this.exEnvironment = this.blockchain.getProvider();
        this.networkName = name;
        const savedConfig = window.localStorage.getItem(`ipfs/${this.exEnvironment}/${this.networkName}`); // check if an already selected option exist else use default workflow

        if (savedConfig !== null) {
          this.setCheckedState(savedConfig);
        } else {
          this.setCheckedState(this.networkName === 'Main');
        }
      });
    });
  }

  setCheckedState(value) {
    value = value === 'true' ? true : value === 'false' ? false : value;
    this.ipfsCheckedState = value;
    if (this.ipfsCheckbox) this.ipfsCheckbox.checked = value;
  }

  toggleCheckedState() {
    if (this.exEnvironment === 'vm') this.networkName = 'VM';
    this.ipfsCheckedState = !this.ipfsCheckedState;
    window.localStorage.setItem(`ipfs/${this.exEnvironment}/${this.networkName}`, this.ipfsCheckedState);
  }

  render() {
    this.compFails = yo`<i title="No contract compiled yet or compilation failed. Please check the compile tab for more information." class="m-2 ml-3 fas fa-times-circle ${css.errorIcon}" ></i>`;
    var info = yo`<i class="fas fa-info ${css.infoDeployAction}" aria-hidden="true" title="*.sol files allows deploying and accessing contracts. *.abi files only allows accessing contracts."></i>`;
    this.atAddress = yo`<button class="${css.atAddress} btn btn-sm btn-info" disabled id="runAndDeployAtAdressButton" onclick=${this.loadFromAddress.bind(this)}>At Address</button>`;
    this.atAddressButtonInput = yo`<input class="${css.input} ${css.ataddressinput} ataddressinput form-control" placeholder="Load contract from Address" title="address of contract" oninput=${this.atAddressChanged.bind(this)} />`;
    this.selectContractNames = yo`<select class="${css.contractNames} custom-select" disabled></select>`;
    if (this.exEnvironment === 'vm') this.networkName = 'VM';
    const savedConfig = window.localStorage.getItem(`ipfs/${this.exEnvironment}/${this.networkName}`);
    this.ipfsCheckedState = savedConfig === 'true' ? true : false; // eslint-disable-line

    this.ipfsCheckbox = yo`
      <input
        id="deployAndRunPublishToIPFS"
        data-id="contractDropdownIpfsCheckbox"
        class="form-check-input custom-control-input"
        type="checkbox"
        onchange=${() => this.toggleCheckedState()}
      >
    `;
    if (this.ipfsCheckedState) this.ipfsCheckbox.checked = true;
    this.deployCheckBox = yo`
      <div class="d-flex py-1 align-items-center custom-control custom-checkbox">
        ${this.ipfsCheckbox}
        <label
          for="deployAndRunPublishToIPFS"
          data-id="contractDropdownIpfsCheckboxLabel"
          class="m-0 form-check-label custom-control-label ${css.checkboxAlign}"
          title="Publishing the source code and ABI to IPFS facilitates source code verification and will greatly foster contract adoption (auditing, debugging, calling it, etc...)"
        >
          Publish to IPFS
        </label>
      </div>
      `;
    this.createPanel = yo`<div class="${css.deployDropdown}"></div>`;
    this.orLabel = yo`<div class="${css.orLabel} mt-2">or</div>`;
    let el = yo`
      <div class="${css.container}" data-id="contractDropdownContainer">
        <label class="${css.settingsLabel}">Contract</label>
        <div class="${css.subcontainer}">
          ${this.selectContractNames} ${this.compFails} ${info}
        </div>
        <div>
          ${this.createPanel}
          ${this.orLabel}
          <div class="${css.button} ${css.atAddressSect}">
            ${this.atAddress}
            ${this.atAddressButtonInput}
          </div>
        </div>
      </div>
    `;
    this.selectContractNames.addEventListener('change', this.setInputParamsPlaceHolder.bind(this));
    this.setInputParamsPlaceHolder();

    if (!this.el) {
      this.el = el;
    }

    return el;
  }

  atAddressChanged(event) {
    if (!this.atAddressButtonInput.value) {
      this.atAddress.setAttribute('disabled', 'true');
    } else {
      this.atAddress.removeAttribute('disabled');
    }
  }

  changeCurrentFile(currentFile) {
    if (!document.querySelector(`.${css.contractNames}`)) return;
    var contractNames = document.querySelector(`.${css.contractNames.classNames[0]}`);

    if (/.(.abi)$/.exec(currentFile)) {
      this.createPanel.style.display = 'none';
      this.orLabel.style.display = 'none';
      this.compFails.style.display = 'none';
      contractNames.appendChild(yo`<option>(abi)</option>`);
      this.selectContractNames.setAttribute('disabled', true);
    } else if (/.(.sol)$/.exec(currentFile)) {
      this.createPanel.style.display = 'block';
      this.orLabel.style.display = 'block';
    }
  }

  setInputParamsPlaceHolder() {
    this.createPanel.innerHTML = '';

    if (this.selectContractNames.selectedIndex < 0 || this.selectContractNames.children.length <= 0) {
      this.createPanel.innerHTML = 'No compiled contracts';
      return;
    }

    const selectedContract = this.getSelectedContract();

    const clickCallback = async (valArray, inputsValues) => {
      var selectedContract = this.getSelectedContract();
      this.createInstance(selectedContract, inputsValues);
    };

    const createConstructorInstance = new MultiParamManager(0, selectedContract.getConstructorInterface(), clickCallback, selectedContract.getConstructorInputs(), 'Deploy', selectedContract.bytecodeObject, true);
    this.createPanel.appendChild(createConstructorInstance.render());
    this.createPanel.appendChild(this.deployCheckBox);
  }

  getSelectedContract() {
    var contract = this.selectContractNames.children[this.selectContractNames.selectedIndex];
    var contractName = contract.getAttribute('value');
    var compilerAtributeName = contract.getAttribute('compiler');
    return this.dropdownLogic.getSelectedContract(contractName, compilerAtributeName);
  }

  async createInstance(selectedContract, args) {
    if (selectedContract.bytecodeObject.length === 0) {
      return modalDialogCustom.alert('This contract may be abstract, not implement an abstract parent\'s methods completely or not invoke an inherited contract\'s constructor correctly.');
    }

    var continueCb = (error, continueTxExecution, cancelCb) => {
      if (error) {
        var msg = typeof error !== 'string' ? error.message : error;
        modalDialog('Gas estimation failed', yo`<div>Gas estimation errored with the following message (see below).
        The transaction execution will likely fail. Do you want to force sending? <br>
        ${msg}
        </div>`, {
          label: 'Send Transaction',
          fn: () => {
            continueTxExecution();
          }
        }, {
          label: 'Cancel Transaction',
          fn: () => {
            cancelCb();
          }
        });
      } else {
        continueTxExecution();
      }
    };

    var promptCb = (okCb, cancelCb) => {
      modalDialogCustom.promptPassphrase('Passphrase requested', 'Personal mode is enabled. Please provide passphrase of account', '', okCb, cancelCb);
    };

    var statusCb = msg => {
      return this.logCallback(msg);
    };

    var finalCb = (error, contractObject, address) => {
      this.event.trigger('clearInstance');

      if (error) {
        return this.logCallback(error);
      }

      this.event.trigger('newContractInstanceAdded', [contractObject, address, contractObject.name]);

      if (this.ipfsCheckedState) {
        (0, _publishToStorage.default)('ipfs', this.runView.fileProvider, this.runView.fileManager, selectedContract);
      }
    };

    let contractMetadata;

    try {
      contractMetadata = await this.runView.call('compilerMetadata', 'deployMetadataOf', selectedContract.name);
    } catch (error) {
      return statusCb(`creation of ${selectedContract.name} errored: ` + error);
    }

    const compilerContracts = this.dropdownLogic.getCompilerContracts();
    const confirmationCb = this.getConfirmationCb(modalDialog, confirmDialog);

    if (selectedContract.isOverSizeLimit()) {
      return modalDialog('Contract code size over limit', yo`<div>Contract creation initialization returns data with length of more than 24576 bytes. The deployment will likely fails. <br>
      More info: <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-170.md" target="_blank">eip-170</a>
      </div>`, {
        label: 'Force Send',
        fn: () => {
          this.deployContract(selectedContract, args, contractMetadata, compilerContracts, {
            continueCb,
            promptCb,
            statusCb,
            finalCb
          }, confirmationCb);
        }
      }, {
        label: 'Cancel',
        fn: () => {
          this.logCallback(`creation of ${selectedContract.name} canceled by user.`);
        }
      });
    }

    this.deployContract(selectedContract, args, contractMetadata, compilerContracts, {
      continueCb,
      promptCb,
      statusCb,
      finalCb
    }, confirmationCb);
  }

  deployContract(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb) {
    const {
      statusCb
    } = callbacks;

    if (!contractMetadata || contractMetadata && contractMetadata.autoDeployLib) {
      return this.blockchain.deployContractAndLibraries(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb);
    }

    if (Object.keys(selectedContract.bytecodeLinkReferences).length) statusCb(`linking ${JSON.stringify(selectedContract.bytecodeLinkReferences, null, '\t')} using ${JSON.stringify(contractMetadata.linkReferences, null, '\t')}`);
    this.blockchain.deployContractWithLibrary(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb);
  }

  getConfirmationCb(modalDialog, confirmDialog) {
    // this code is the same as in recorder.js. TODO need to be refactored out
    const confirmationCb = (network, tx, gasEstimation, continueTxExecution, cancelCb) => {
      if (network.name !== 'Main') {
        return continueTxExecution(null);
      }

      const amount = this.blockchain.fromWei(tx.value, true, 'ether');
      const content = confirmDialog(tx, amount, gasEstimation, null, this.blockchain.determineGasFees(tx), this.blockchain.determineGasPrice.bind(this.blockchain));
      modalDialog('Confirm transaction', content, {
        label: 'Confirm',
        fn: () => {
          this.blockchain.config.setUnpersistedProperty('doNotShowTransactionConfirmationAgain', content.querySelector('input#confirmsetting').checked); // TODO: check if this is check is still valid given the refactor

          if (!content.gasPriceStatus) {
            cancelCb('Given gas price is not correct');
          } else {
            var gasPrice = this.blockchain.toWei(content.querySelector('#gasprice').value, 'gwei');
            continueTxExecution(gasPrice);
          }
        }
      }, {
        label: 'Cancel',
        fn: () => {
          return cancelCb('Transaction canceled by user.');
        }
      });
    };

    return confirmationCb;
  }

  loadFromAddress() {
    this.event.trigger('clearInstance');
    var address = this.atAddressButtonInput.value;
    this.dropdownLogic.loadContractFromAddress(address, cb => {
      modalDialogCustom.confirm(null, 'Do you really want to interact with ' + address + ' using the current ABI definition?', cb);
    }, (error, loadType, abi) => {
      if (error) {
        return modalDialogCustom.alert(error);
      }

      if (loadType === 'abi') {
        return this.event.trigger('newContractABIAdded', [abi, address]);
      }

      var selectedContract = this.getSelectedContract();
      this.event.trigger('newContractInstanceAdded', [selectedContract.object, address, this.selectContractNames.value]);
    });
  }

}

module.exports = ContractDropdownUI;

/***/ }),

/***/ "./app/tabs/runTab/model/dropdownlogic.js":
/*!************************************************!*\
  !*** ./app/tabs/runTab/model/dropdownlogic.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var txHelper = remixLib.execution.txHelper;

var CompilerAbstract = __webpack_require__(/*! ../../../compiler/compiler-abstract */ "./app/compiler/compiler-abstract.js");

var EventManager = remixLib.EventManager;

class DropdownLogic {
  constructor(compilersArtefacts, config, editor, runView) {
    this.compilersArtefacts = compilersArtefacts;
    this.config = config;
    this.editor = editor;
    this.runView = runView;
    this.event = new EventManager();
    this.listenToCompilationEvents();
  } // TODO: can be moved up; the event in contractDropdown will have to refactored a method instead


  listenToCompilationEvents() {
    let broadcastCompilationResult = (file, source, languageVersion, data) => {
      // TODO check whether the tab is configured
      let compiler = new CompilerAbstract(languageVersion, data, source);
      this.compilersArtefacts[languageVersion] = compiler;
      this.compilersArtefacts['__last'] = compiler;
      this.event.trigger('newlyCompiled', [true, data, source, compiler, languageVersion, file]);
    };

    this.runView.on('solidity', 'compilationFinished', (file, source, languageVersion, data) => broadcastCompilationResult(file, source, languageVersion, data));
    this.runView.on('vyper', 'compilationFinished', (file, source, languageVersion, data) => broadcastCompilationResult(file, source, languageVersion, data));
    this.runView.on('lexon', 'compilationFinished', (file, source, languageVersion, data) => broadcastCompilationResult(file, source, languageVersion, data));
    this.runView.on('yulp', 'compilationFinished', (file, source, languageVersion, data) => broadcastCompilationResult(file, source, languageVersion, data));
  }

  loadContractFromAddress(address, confirmCb, cb) {
    if (!ethJSUtil.isValidAddress(address)) {
      return cb('Invalid address.');
    }

    if (/[a-f]/.test(address) && /[A-F]/.test(address) && !ethJSUtil.isValidChecksumAddress(address)) {
      return cb('Invalid checksum address.');
    }

    if (/.(.abi)$/.exec(this.config.get('currentFile'))) {
      confirmCb(() => {
        var abi;

        try {
          abi = JSON.parse(this.editor.currentContent());
        } catch (e) {
          return cb('Failed to parse the current file as JSON ABI.');
        }

        cb(null, 'abi', abi);
      });
    } else {
      cb(null, 'instance');
    }
  }

  getCompiledContracts(compiler, compilerFullName) {
    var contracts = [];
    compiler.visitContracts(contract => {
      contracts.push(contract);
    });
    return contracts;
  }

  getSelectedContract(contractName, compilerAtributeName) {
    if (!contractName) return null;
    var compiler = this.compilersArtefacts[compilerAtributeName];
    if (!compiler) return null;
    var contract = compiler.getContract(contractName);
    return {
      name: contractName,
      contract: contract,
      compiler: compiler,
      abi: contract.object.abi,
      bytecodeObject: contract.object.evm.bytecode.object,
      bytecodeLinkReferences: contract.object.evm.bytecode.linkReferences,
      object: contract.object,
      deployedBytecode: contract.object.evm.deployedBytecode,
      getConstructorInterface: () => {
        return txHelper.getConstructorInterface(contract.object.abi);
      },
      getConstructorInputs: () => {
        var constructorInteface = txHelper.getConstructorInterface(contract.object.abi);
        return txHelper.inputParametersDeclarationToString(constructorInteface.inputs);
      },
      isOverSizeLimit: () => {
        var deployedBytecode = contract.object.evm.deployedBytecode;
        return deployedBytecode && deployedBytecode.object.length / 2 > 24576;
      },
      metadata: contract.object.metadata
    };
  }

  getCompilerContracts() {
    return this.compilersArtefacts['__last'].getData().contracts;
  }

}

module.exports = DropdownLogic;

/***/ }),

/***/ "./app/tabs/runTab/model/recorder.js":
/*!*******************************************!*\
  !*** ./app/tabs/runTab/model/recorder.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

var ethutil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var EventManager = remixLib.EventManager;
var format = remixLib.execution.txFormat;
var txHelper = remixLib.execution.txHelper;

var helper = __webpack_require__(/*! ../../../../lib/helper.js */ "./lib/helper.js");
/**
  * Record transaction as long as the user create them.
  *
  *
  */


class Recorder {
  constructor(blockchain, fileManager, config) {
    var self = this;
    self.event = new EventManager();
    self.blockchain = blockchain;
    self.data = {
      _listen: true,
      _replay: false,
      journal: [],
      _createdContracts: {},
      _createdContractsReverse: {},
      _usedAccounts: {},
      _abis: {},
      _contractABIReferences: {},
      _linkReferences: {}
    };
    this.fileManager = fileManager;
    this.config = config;
    this.blockchain.event.register('initiatingTransaction', (timestamp, tx, payLoad) => {
      if (tx.useCall) return;
      var {
        from,
        to,
        value
      } = tx; // convert to and from to tokens

      if (this.data._listen) {
        var record = {
          value,
          parameters: payLoad.funArgs
        };

        if (!to) {
          var abi = payLoad.contractABI;
          var keccak = ethutil.bufferToHex(ethutil.keccak(abi));
          record.abi = keccak;
          record.contractName = payLoad.contractName;
          record.bytecode = payLoad.contractBytecode;
          record.linkReferences = payLoad.linkReferences;

          if (record.linkReferences && Object.keys(record.linkReferences).length) {
            for (var file in record.linkReferences) {
              for (var lib in record.linkReferences[file]) {
                self.data._linkReferences[lib] = '<address>';
              }
            }
          }

          self.data._abis[keccak] = abi;
          this.data._contractABIReferences[timestamp] = keccak;
        } else {
          var creationTimestamp = this.data._createdContracts[to];
          record.to = `created{${creationTimestamp}}`;
          record.abi = this.data._contractABIReferences[creationTimestamp];
        }

        record.name = payLoad.funAbi.name;
        record.inputs = txHelper.serializeInputs(payLoad.funAbi);
        record.type = payLoad.funAbi.type;

        for (var p in record.parameters) {
          var thisarg = record.parameters[p];
          var thistimestamp = this.data._createdContracts[thisarg];
          if (thistimestamp) record.parameters[p] = `created{${thistimestamp}}`;
        }

        this.blockchain.getAccounts((error, accounts) => {
          if (error) return console.log(error);
          record.from = `account{${accounts.indexOf(from)}}`;
          self.data._usedAccounts[record.from] = from;
          self.append(timestamp, record);
        });
      }
    });
    this.blockchain.event.register('transactionExecuted', (error, from, to, data, call, txResult, timestamp, _payload, rawAddress) => {
      if (error) return console.log(error);
      if (call) return;
      if (!rawAddress) return; // not a contract creation

      const stringAddress = this.addressToString(rawAddress);
      const address = ethutil.toChecksumAddress(stringAddress); // save back created addresses for the convertion from tokens to real adresses

      this.data._createdContracts[address] = timestamp;
      this.data._createdContractsReverse[timestamp] = address;
    });
    this.blockchain.event.register('contextChanged', this.clearAll.bind(this));
    this.event.register('newTxRecorded', count => {
      this.event.trigger('recorderCountChange', [count]);
    });
    this.event.register('cleared', () => {
      this.event.trigger('recorderCountChange', [0]);
    });
  }
  /**
    * stop/start saving txs. If not listenning, is basically in replay mode
    *
    * @param {Bool} listen
    */


  setListen(listen) {
    this.data._listen = listen;
    this.data._replay = !listen;
  }

  extractTimestamp(value) {
    var stamp = /created{(.*)}/g.exec(value);

    if (stamp) {
      return stamp[1];
    }

    return null;
  }
  /**
    * convert back from/to from tokens to real addresses
    *
    * @param {Object} record
    * @param {Object} accounts
    * @param {Object} options
    *
    */


  resolveAddress(record, accounts, options) {
    if (record.to) {
      var stamp = this.extractTimestamp(record.to);

      if (stamp) {
        record.to = this.data._createdContractsReverse[stamp];
      }
    }

    record.from = accounts[record.from]; // @TODO: writing browser test

    return record;
  }
  /**
    * save the given @arg record
    *
    * @param {Number/String} timestamp
    * @param {Object} record
    *
    */


  append(timestamp, record) {
    var self = this;
    self.data.journal.push({
      timestamp,
      record
    });
    self.event.trigger('newTxRecorded', [self.data.journal.length]);
  }
  /**
    * basically return the records + associate values (like abis / accounts)
    *
    */


  getAll() {
    var self = this;
    var records = [].concat(self.data.journal);
    return {
      accounts: self.data._usedAccounts,
      linkReferences: self.data._linkReferences,
      transactions: records.sort((A, B) => {
        var stampA = A.timestamp;
        var stampB = B.timestamp;
        return stampA - stampB;
      }),
      abis: self.data._abis
    };
  }
  /**
    * delete the seen transactions
    *
    */


  clearAll() {
    var self = this;
    self.data._listen = true;
    self.data._replay = false;
    self.data.journal = [];
    self.data._createdContracts = {};
    self.data._createdContractsReverse = {};
    self.data._usedAccounts = {};
    self.data._abis = {};
    self.data._contractABIReferences = {};
    self.data._linkReferences = {};
    self.event.trigger('cleared', []);
  }
  /**
    * run the list of records
    *
    * @param {Object} accounts
    * @param {Object} options
    * @param {Object} abis
    * @param {Function} newContractFn
    *
    */


  run(records, accounts, options, abis, linkReferences, confirmationCb, continueCb, promptCb, alertCb, logCallBack, newContractFn) {
    var self = this;
    self.setListen(false);
    logCallBack(`Running ${records.length} transaction(s) ...`);
    async.eachOfSeries(records, function (tx, index, cb) {
      var record = self.resolveAddress(tx.record, accounts, options);
      var abi = abis[tx.record.abi];

      if (!abi) {
        return alertCb('cannot find ABI for ' + tx.record.abi + '.  Execution stopped at ' + index);
      }
      /* Resolve Library */


      if (record.linkReferences && Object.keys(record.linkReferences).length) {
        for (var k in linkReferences) {
          var link = linkReferences[k];
          var timestamp = self.extractTimestamp(link);

          if (timestamp && self.data._createdContractsReverse[timestamp]) {
            link = self.data._createdContractsReverse[timestamp];
          }

          tx.record.bytecode = format.linkLibraryStandardFromlinkReferences(k, link.replace('0x', ''), tx.record.bytecode, tx.record.linkReferences);
        }
      }
      /* Encode params */


      var fnABI;

      if (tx.record.type === 'constructor') {
        fnABI = txHelper.getConstructorInterface(abi);
      } else if (tx.record.type === 'fallback') {
        fnABI = txHelper.getFallbackInterface(abi);
      } else if (tx.record.type === 'receive') {
        fnABI = txHelper.getReceiveInterface(abi);
      } else {
        fnABI = txHelper.getFunction(abi, record.name + record.inputs);
      }

      if (!fnABI) {
        alertCb('cannot resolve abi of ' + JSON.stringify(record, null, '\t') + '. Execution stopped at ' + index);
        return cb('cannot resolve abi');
      }

      if (tx.record.parameters) {
        /* check if we have some params to resolve */
        try {
          tx.record.parameters.forEach((value, index) => {
            var isString = true;

            if (typeof value !== 'string') {
              isString = false;
              value = JSON.stringify(value);
            }

            for (var timestamp in self.data._createdContractsReverse) {
              value = value.replace(new RegExp('created\\{' + timestamp + '\\}', 'g'), self.data._createdContractsReverse[timestamp]);
            }

            if (!isString) value = JSON.parse(value);
            tx.record.parameters[index] = value;
          });
        } catch (e) {
          return alertCb('cannot resolve input parameters ' + JSON.stringify(tx.record.parameters) + '. Execution stopped at ' + index);
        }
      }

      var data = format.encodeData(fnABI, tx.record.parameters, tx.record.bytecode);

      if (data.error) {
        alertCb(data.error + '. Record:' + JSON.stringify(record, null, '\t') + '. Execution stopped at ' + index);
        return cb(data.error);
      }

      logCallBack(`(${index}) ${JSON.stringify(record, null, '\t')}`);
      logCallBack(`(${index}) data: ${data.data}`);
      record.data = {
        dataHex: data.data,
        funArgs: tx.record.parameters,
        funAbi: fnABI,
        contractBytecode: tx.record.bytecode,
        contractName: tx.record.contractName,
        timestamp: tx.timestamp
      };
      self.blockchain.runTx(record, confirmationCb, continueCb, promptCb, function (err, txResult, rawAddress) {
        if (err) {
          console.error(err);
          return logCallBack(err + '. Execution failed at ' + index);
        }

        if (rawAddress) {
          const stringAddress = self.addressToString(rawAddress);
          const address = ethutil.toChecksumAddress(stringAddress); // save back created addresses for the convertion from tokens to real adresses

          self.data._createdContracts[address] = tx.timestamp;
          self.data._createdContractsReverse[tx.timestamp] = address;
          newContractFn(abi, address, record.contractName);
        }

        cb(err);
      });
    }, () => {
      self.setListen(true);
      self.clearAll();
    });
  }

  addressToString(address) {
    if (!address) return null;

    if (typeof address !== 'string') {
      address = address.toString('hex');
    }

    if (address.indexOf('0x') === -1) {
      address = '0x' + address;
    }

    return address;
  }

  runScenario(continueCb, promptCb, alertCb, confirmationCb, logCallBack, cb) {
    var currentFile = this.config.get('currentFile');
    this.fileManager.fileProviderOf(currentFile).get(currentFile, (error, json) => {
      if (error) {
        return cb('Invalid Scenario File ' + error);
      }

      if (!currentFile.match('.json$')) {
        return cb('A scenario file is required. Please make sure a scenario file is currently displayed in the editor. The file must be of type JSON. Use the "Save Transactions" Button to generate a new Scenario File.');
      }

      try {
        var obj = JSON.parse(json);
        var txArray = obj.transactions || [];
        var accounts = obj.accounts || [];
        var options = obj.options || {};
        var abis = obj.abis || {};
        var linkReferences = obj.linkReferences || {};
      } catch (e) {
        return cb('Invalid Scenario File, please try again');
      }

      if (!txArray.length) {
        return;
      }

      this.run(txArray, accounts, options, abis, linkReferences, confirmationCb, continueCb, promptCb, alertCb, logCallBack, (abi, address, contractName) => {
        cb(null, abi, address, contractName);
      });
    });
  }

  saveScenario(promptCb, cb) {
    var txJSON = JSON.stringify(this.getAll(), null, 2);
    var path = this.fileManager.currentPath();
    promptCb(path, input => {
      var fileProvider = this.fileManager.fileProviderOf(path);
      if (!fileProvider) return;
      var newFile = path + '/' + input;
      helper.createNonClashingName(newFile, fileProvider, (error, newFile) => {
        if (error) return cb('Failed to create file. ' + newFile + ' ' + error);
        if (!fileProvider.set(newFile, txJSON)) return cb('Failed to create file ' + newFile);
        this.fileManager.open(newFile);
      });
    });
  }

}

module.exports = Recorder;

/***/ }),

/***/ "./app/tabs/runTab/recorder.js":
/*!*************************************!*\
  !*** ./app/tabs/runTab/recorder.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var EventManager = remixLib.EventManager;

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = __webpack_require__(/*! ../styles/run-tab-styles */ "./app/tabs/styles/run-tab-styles.js");

var modalDialogCustom = __webpack_require__(/*! ../../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var modalDialog = __webpack_require__(/*! ../../ui/modaldialog */ "./app/ui/modaldialog.js");

var confirmDialog = __webpack_require__(/*! ../../ui/confirmDialog */ "./app/ui/confirmDialog.js");

class RecorderUI {
  constructor(blockchain, recorder, logCallBack, config) {
    this.blockchain = blockchain;
    this.recorder = recorder;
    this.logCallBack = logCallBack;
    this.config = config;
    this.event = new EventManager();
  }

  render() {
    var css2 = csjs`
      .container {}
      .runTxs {}
      .recorder {}
    `;
    this.runButton = yo`<i class="fas fa-play runtransaction ${css2.runTxs} ${css.icon}"  title="Run Transactions" aria-hidden="true"></i>`;
    this.recordButton = yo`
      <i class="fas fa-save savetransaction ${css2.recorder} ${css.icon}"
        onclick=${this.triggerRecordButton.bind(this)} title="Save Transactions" aria-hidden="true">
      </i>`;
    this.runButton.onclick = this.runScenario.bind(this);
  }

  runScenario() {
    var continueCb = (error, continueTxExecution, cancelCb) => {
      if (error) {
        var msg = typeof error !== 'string' ? error.message : error;
        modalDialog('Gas estimation failed', yo`<div>Gas estimation errored with the following message (see below).
        The transaction execution will likely fail. Do you want to force sending? <br>
        ${msg}
        </div>`, {
          label: 'Send Transaction',
          fn: () => {
            continueTxExecution();
          }
        }, {
          label: 'Cancel Transaction',
          fn: () => {
            cancelCb();
          }
        });
      } else {
        continueTxExecution();
      }
    };

    var promptCb = (okCb, cancelCb) => {
      modalDialogCustom.promptPassphrase('Passphrase requested', 'Personal mode is enabled. Please provide passphrase of account', '', okCb, cancelCb);
    };

    var alertCb = msg => {
      modalDialogCustom.alert(msg);
    };

    const confirmationCb = this.getConfirmationCb(modalDialog, confirmDialog); // TODO: there is still a UI dependency to remove here, it's still too coupled at this point to remove easily

    this.recorder.runScenario(continueCb, promptCb, alertCb, confirmationCb, this.logCallBack, (error, abi, address, contractName) => {
      if (error) {
        return modalDialogCustom.alert(error);
      }

      this.event.trigger('newScenario', [abi, address, contractName]);
    });
  }

  getConfirmationCb(modalDialog, confirmDialog) {
    // this code is the same as in contractDropdown.js. TODO need to be refactored out
    const confirmationCb = (network, tx, gasEstimation, continueTxExecution, cancelCb) => {
      if (network.name !== 'Main') {
        return continueTxExecution(null);
      }

      const amount = this.blockchain.fromWei(tx.value, true, 'ether');
      const content = confirmDialog(tx, amount, gasEstimation, null, this.blockchain.determineGasFees(tx), this.blockchain.determineGasPrice.bind(this.blockchain));
      modalDialog('Confirm transaction', content, {
        label: 'Confirm',
        fn: () => {
          this.config.setUnpersistedProperty('doNotShowTransactionConfirmationAgain', content.querySelector('input#confirmsetting').checked); // TODO: check if this is check is still valid given the refactor

          if (!content.gasPriceStatus) {
            cancelCb('Given gas price is not correct');
          } else {
            var gasPrice = this.blockchain.toWei(content.querySelector('#gasprice').value, 'gwei');
            continueTxExecution(gasPrice);
          }
        }
      }, {
        label: 'Cancel',
        fn: () => {
          return cancelCb('Transaction canceled by user.');
        }
      });
    };

    return confirmationCb;
  }

  triggerRecordButton() {
    this.recorder.saveScenario((path, cb) => {
      modalDialogCustom.prompt('Save transactions as scenario', 'Transactions will be saved in a file under ' + path, 'scenario.json', cb);
    }, error => {
      if (error) return modalDialogCustom.alert(error);
    });
  }

}

module.exports = RecorderUI;

/***/ }),

/***/ "./app/tabs/runTab/settings.js":
/*!*************************************!*\
  !*** ./app/tabs/runTab/settings.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const EventManager = remixLib.EventManager;

const css = __webpack_require__(/*! ../styles/run-tab-styles */ "./app/tabs/styles/run-tab-styles.js");

const copyToClipboard = __webpack_require__(/*! ../../ui/copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

const modalDialogCustom = __webpack_require__(/*! ../../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

const addTooltip = __webpack_require__(/*! ../../ui/tooltip */ "./app/ui/tooltip.js");

const helper = __webpack_require__(/*! ../../../lib/helper.js */ "./lib/helper.js");

const globalRegistry = __webpack_require__(/*! ../../../global/registry */ "./global/registry.js");

class SettingsUI {
  constructor(blockchain, networkModule) {
    this.blockchain = blockchain;
    this.event = new EventManager();
    this._components = {};
    this.blockchain.event.register('transactionExecuted', (error, from, to, data, lookupOnly, txResult) => {
      if (error) return;
      if (!lookupOnly) this.el.querySelector('#value').value = '0';
      this.updateAccountBalances();
    });
    this._components = {
      registry: globalRegistry,
      networkModule: networkModule
    };
    this._components.registry = globalRegistry;
    this._deps = {
      config: this._components.registry.get('config').api
    };

    this._deps.config.events.on('settings/personal-mode_changed', this.onPersonalChange.bind(this));

    setInterval(() => {
      this.updateAccountBalances();
    }, 10 * 1000);
    this.accountListCallId = 0;
    this.loadedAccounts = {};
  }

  updateAccountBalances() {
    if (!this.el) return;
    var accounts = $(this.el.querySelector('#txorigin')).children('option');
    accounts.each((index, account) => {
      this.blockchain.getBalanceInEther(account.value, (err, balance) => {
        if (err) return;
        account.innerText = helper.shortenAddress(account.value, balance);
      });
    });
  }

  render() {
    this.netUI = yo`<span class="${css.network} badge badge-secondary"></span>`;
    var environmentEl = yo`
      <div class="${css.crow}">
        <label id="selectExEnv" class="${css.settingsLabel}">
          Environment
        </label>
        <div class="${css.environment}">
          <select id="selectExEnvOptions" data-id="settingsSelectEnvOptions" onchange=${() => {
      this.updateNetwork();
    }} class="form-control ${css.select} custom-select">
            <option id="vm-mode"
              title="Execution environment does not connect to any node, everything is local and in memory only."
              value="vm" name="executionContext"> JavaScript VM
            </option>
            <option id="injected-mode"
              title="Execution environment has been provided by Metamask or similar provider."
              value="injected" name="executionContext"> Injected Web3
            </option>
            <option id="web3-mode" data-id="settingsWeb3Mode"
              title="Execution environment connects to node at localhost (or via IPC if available), transactions will be sent to the network and can cause loss of money or worse!
              If this page is served via https and you access your node via http, it might not work. In this case, try cloning the repository and serving it via http."
              value="web3" name="executionContext"> Web3 Provider
            </option>
          </select>
          <a href="https://remix-ide.readthedocs.io/en/latest/run.html#run-setup" target="_blank"><i class="${css.infoDeployAction} ml-2 fas fa-info" title="check out docs to setup Environment"></i></a>
        </div>
      </div>
    `;
    const networkEl = yo`
    <div class="${css.crow}">
        <div class="${css.settingsLabel}">
        </div>
        <div class="${css.environment}" data-id="settingsNetworkEnv">
          ${this.netUI}
        </div>
      </div>
    `;
    const accountEl = yo`
      <div class="${css.crow}">
        <label class="${css.settingsLabel}">
          Account
          <span id="remixRunPlusWraper" title="Create a new account" onload=${this.updatePlusButton.bind(this)}>
            <i id="remixRunPlus" class="fas fa-plus-circle ${css.icon}" aria-hidden="true" onclick=${this.newAccount.bind(this)}"></i>
          </span>
        </label>
        <div class="${css.account}">
          <select data-id="runTabSelectAccount" name="txorigin" class="form-control ${css.select} custom-select pr-4" id="txorigin"></select>
          <div style="margin-left: -5px;">${copyToClipboard(() => document.querySelector('#runTabView #txorigin').value)}</div>
          <i id="remixRunSignMsg" data-id="settingsRemixRunSignMsg" class="mx-1 fas fa-edit ${css.icon}" aria-hidden="true" onclick=${this.signMessage.bind(this)} title="Sign a message using this account key"></i>
        </div>
      </div>
    `;
    const gasPriceEl = yo`
      <div class="${css.crow}">
        <label class="${css.settingsLabel}">Gas limit</label>
        <input type="number" class="form-control ${css.gasNval} ${css.col2}" id="gasLimit" value="3000000">
      </div>
    `;
    const valueEl = yo`
      <div class="${css.crow}">
        <label class="${css.settingsLabel}">Value</label>
        <div class="${css.gasValueContainer}">
          <input type="text" class="form-control ${css.gasNval} ${css.col2}" id="value" value="0" title="Enter the value and choose the unit">
          <select name="unit" class="form-control p-1 ${css.gasNvalUnit} ${css.col2_2} custom-select" id="unit">
            <option data-unit="wei">wei</option>
            <option data-unit="gwei">gwei</option>
            <option data-unit="finney">finney</option>
            <option data-unit="ether">ether</option>
          </select>
        </div>
      </div>
    `;
    const el = yo`
      <div class="${css.settings}">
        ${environmentEl}
        ${networkEl}
        ${accountEl}
        ${gasPriceEl}
        ${valueEl}
      </div>
    `;
    var selectExEnv = environmentEl.querySelector('#selectExEnvOptions');
    this.setDropdown(selectExEnv);
    this.blockchain.event.register('contextChanged', (context, silent) => {
      this.setFinalContext();
    });
    setInterval(() => {
      this.updateNetwork();
    }, 5000);
    this.el = el;
    this.fillAccountsList();
    return el;
  }

  setDropdown(selectExEnv) {
    this.selectExEnv = selectExEnv;
    this.blockchain.event.register('addProvider', network => {
      selectExEnv.appendChild(yo`<option
        title="Manually added environment: ${network.url}"
        value="${network.name}"
        name="executionContext"
      >
        ${network.name}
      </option>`);
      addTooltip(`${network.name} [${network.url}] added`);
    });
    this.blockchain.event.register('removeProvider', name => {
      var env = selectExEnv.querySelector(`option[value="${name}"]`);

      if (env) {
        selectExEnv.removeChild(env);
        addTooltip(`${name} removed`);
      }
    });
    selectExEnv.addEventListener('change', event => {
      let context = selectExEnv.options[selectExEnv.selectedIndex].value;
      this.blockchain.changeExecutionContext(context, () => {
        modalDialogCustom.prompt('External node request', this.web3ProviderDialogBody(), 'http://127.0.0.1:8545', target => {
          this.blockchain.setProviderFromEndpoint(target, context, alertMsg => {
            if (alertMsg) addTooltip(alertMsg);
            this.setFinalContext();
          });
        }, this.setFinalContext.bind(this));
      }, alertMsg => {
        addTooltip(alertMsg);
      }, this.setFinalContext.bind(this));
    });
    selectExEnv.value = this.blockchain.getProvider();
  }

  web3ProviderDialogBody() {
    const thePath = '<path/to/local/folder/for/test/chain>';
    return yo`
      <div class="">
        Note: To use Geth & https://remix.ethereum.org, configure it to allow requests from Remix:(see <a href="https://geth.ethereum.org/docs/rpc/server" target="_blank">Geth Docs on rpc server</a>)
        <div class="border p-1">geth --rpc --rpccorsdomain https://remix.ethereum.org</div>
        <br>
        To run Remix & a local Geth test node, use this command: (see <a href="https://geth.ethereum.org/getting-started/dev-mode" target="_blank">Geth Docs on Dev mode</a>)
        <div class="border p-1">geth --rpc --rpccorsdomain="${window.origin}" --rpcapi web3,eth,debug,personal,net --vmdebug --datadir ${thePath} --dev console</div>
        <br>
        <br> 
        <b>WARNING:</b> It is not safe to use the --rpccorsdomain flag with a wildcard: <b>--rpccorsdomain *</b>
        <br>
        <br>For more info: <a href="https://remix-ide.readthedocs.io/en/latest/run.html#more-about-web3-provider" target="_blank">Remix Docs on Web3 Provider</a>
        <br>
        <br> 
        Web3 Provider Endpoint
      </div>
    `;
  }

  setFinalContext() {
    // set the final context. Cause it is possible that this is not the one we've originaly selected
    this.selectExEnv.value = this.blockchain.getProvider();
    this.event.trigger('clearInstance', []);
    this.updateNetwork();
    this.updatePlusButton();
  }

  updatePlusButton() {
    // enable/disable + button
    let plusBtn = document.getElementById('remixRunPlus');
    let plusTitle = document.getElementById('remixRunPlusWraper');

    switch (this.selectExEnv.value) {
      case 'injected':
        {
          plusBtn.classList.add(css.disableMouseEvents);
          plusTitle.title = "Unfortunately it's not possible to create an account using injected web3. Please create the account directly from your provider (i.e metamask or other of the same type).";
        }
        break;

      case 'vm':
        {
          plusBtn.classList.remove(css.disableMouseEvents);
          plusTitle.title = 'Create a new account';
        }
        break;

      case 'web3':
        {
          this.onPersonalChange();
        }
        break;

      default:
    }
  }

  onPersonalChange() {
    let plusBtn = document.getElementById('remixRunPlus');
    let plusTitle = document.getElementById('remixRunPlusWraper');

    if (!this._deps.config.get('settings/personal-mode')) {
      plusBtn.classList.add(css.disableMouseEvents);
      plusTitle.title = 'Creating an account is possible only in Personal mode. Please go to Settings to enable it.';
    } else {
      plusBtn.classList.remove(css.disableMouseEvents);
      plusTitle.title = 'Create a new account';
    }
  }

  newAccount() {
    this.blockchain.newAccount('', cb => {
      modalDialogCustom.promptPassphraseCreation((error, passphrase) => {
        if (error) {
          return modalDialogCustom.alert(error);
        }

        cb(passphrase);
      }, () => {});
    }, (error, address) => {
      if (error) {
        return addTooltip('Cannot create an account: ' + error);
      }

      addTooltip(`account ${address} created`);
    });
  }

  signMessage() {
    this.blockchain.getAccounts((err, accounts) => {
      if (err) {
        return addTooltip(`Cannot get account list: ${err}`);
      }

      var signMessageDialog = {
        'title': 'Sign a message',
        'text': 'Enter a message to sign',
        'inputvalue': 'Message to sign'
      };
      var $txOrigin = this.el.querySelector('#txorigin');

      if (!$txOrigin.selectedOptions[0] && (this.blockchain.isInjectedWeb3() || this.blockchain.isWeb3Provider())) {
        return addTooltip(`Account list is empty, please make sure the current provider is properly connected to remix`);
      }

      var account = $txOrigin.selectedOptions[0].value;

      var promptCb = passphrase => {
        const modal = modalDialogCustom.promptMulti(signMessageDialog, message => {
          this.blockchain.signMessage(message, account, passphrase, (err, msgHash, signedData) => {
            if (err) {
              return addTooltip(err);
            }

            modal.hide();
            modalDialogCustom.alert(yo`
              <div>
                <b>hash:</b><br>
                <span id="remixRunSignMsgHash" data-id="settingsRemixRunSignMsgHash">${msgHash}</span>
                <br><b>signature:</b><br>
                <span id="remixRunSignMsgSignature" data-id="settingsRemixRunSignMsgSignature">${signedData}</span>
              </div>
            `);
          });
        }, false);
      };

      if (this.blockchain.isWeb3Provider()) {
        return modalDialogCustom.promptPassphrase('Passphrase to sign a message', 'Enter your passphrase for this account to sign the message', '', promptCb, false);
      }

      promptCb();
    });
  }

  updateNetwork() {
    this.blockchain.updateNetwork((err, {
      id,
      name
    } = {}) => {
      if (err) {
        this.netUI.innerHTML = 'can\'t detect network ';
        return;
      }

      let network = this._components.networkModule.getNetworkProvider.bind(this._components.networkModule);

      this.netUI.innerHTML = network() !== 'vm' ? `${name} (${id || '-'}) network` : '';
    });
    this.fillAccountsList();
  } // TODO: unclear what's the goal of accountListCallId, feels like it can be simplified


  fillAccountsList() {
    this.accountListCallId++;
    var callid = this.accountListCallId;
    var txOrigin = this.el.querySelector('#txorigin');
    this.blockchain.getAccounts((err, accounts) => {
      if (this.accountListCallId > callid) return;
      this.accountListCallId++;

      if (err) {
        addTooltip(`Cannot get account list: ${err}`);
      }

      for (var loadedaddress in this.loadedAccounts) {
        if (accounts.indexOf(loadedaddress) === -1) {
          txOrigin.removeChild(txOrigin.querySelector('option[value="' + loadedaddress + '"]'));
          delete this.loadedAccounts[loadedaddress];
        }
      }

      for (var i in accounts) {
        var address = accounts[i];

        if (!this.loadedAccounts[address]) {
          txOrigin.appendChild(yo`<option value="${address}" >${address}</option>`);
          this.loadedAccounts[address] = 1;
        }
      }

      txOrigin.setAttribute('value', accounts[0]);
    });
  }

}

module.exports = SettingsUI;

/***/ }),

/***/ "./app/tabs/settings-tab.js":
/*!**********************************!*\
  !*** ./app/tabs/settings-tab.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

const tooltip = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

const copyToClipboard = __webpack_require__(/*! ../ui/copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

const EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

const css = __webpack_require__(/*! ./styles/settings-tab-styles */ "./app/tabs/styles/settings-tab-styles.js");

const profile = {
  name: 'settings',
  displayName: 'Settings',
  methods: ['getGithubAccessToken'],
  events: [],
  icon: 'assets/img/settings.webp',
  description: 'Remix-IDE settings',
  kind: 'settings',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/settings.html',
  version: packageJson.version,
  permission: true
};
module.exports = class SettingsTab extends _engine.ViewPlugin {
  constructor(config, editor, appManager) {
    super(profile);
    this.config = config;
    this.editor = editor;
    this.appManager = appManager;
    this._components = {};
    this._deps = {
      themeModule: globalRegistry.get('themeModule').api
    };
    this._view = {
      /* eslint-disable */
      el: null,
      optionVM: null,
      personal: null,
      warnPersonalMode: null,
      generateContractMetadata: null,
      config: {
        general: null,
        themes: null
      }
    };
    /* eslint-enable */

    this.event = new EventManager();
  }

  createThemeCheckies() {
    let themes = this._deps.themeModule.getThemes();

    const onswitchTheme = (event, name) => {
      this._deps.themeModule.switchTheme(name);
    };

    if (themes) {
      return yo`<div class="card-text themes-container">
        ${themes.map(aTheme => {
        let el = yo`<div class="${css.frow} form-check ${css.crow}">
          <input type="radio" onchange=${event => {
          onswitchTheme(event, aTheme.name);
        }} class="align-middle form-check-input" name="theme" id="${aTheme.name}" data-id="settingsTabTheme${aTheme.name}"  >
          <label class="form-check-label" for="${aTheme.name}">${aTheme.name} (${aTheme.quality})</label>
        </div>`;
        if (this._deps.themeModule.active === aTheme.name) el.querySelector('input').setAttribute('checked', 'checked');
        return el;
      })}
      </div>`;
    }
  }

  render() {
    const self = this;
    if (self._view.el) return self._view.el; // Gist settings

    const token = this.config.get('settings/gist-access-token');
    const gistAccessToken = yo`<input id="gistaccesstoken" data-id="settingsTabGistAccessToken" type="password" class="form-control border form-control-sm mb-2 ${css.inline}" placeholder="Token">`;
    if (token) gistAccessToken.value = token;

    const removeToken = () => {
      self.config.set('settings/gist-access-token', '');
      gistAccessToken.value = '';
      tooltip('Access token removed');
    };

    const saveToken = () => {
      this.config.set('settings/gist-access-token', gistAccessToken.value);
      tooltip('Access token saved');
    };

    const gistAddToken = yo`<input class="btn btn-sm btn-primary" id="savegisttoken" data-id="settingsTabSaveGistToken" onclick=${() => saveToken()} value="Save" type="button">`;
    const gistRemoveToken = yo`<i class="mx-1 fas fa-trash-alt" id="removegisttoken" data-id="settingsTabRemoveGistToken" title="Delete Github access token" onclick=${() => removeToken()}" type="button"></i>`;
    this._view.gistToken = yo`<div class="text-secondary mb-0 h6">${gistAccessToken}${gistAddToken}${copyToClipboard(() => gistAccessToken.value)}${gistRemoveToken}</div>`;
    this._view.optionVM = yo`<input onchange=${onchangeOption} class="align-middle form-check-input" id="alwaysUseVM" data-id="settingsTabAlwaysUseVM" type="checkbox">`;
    if (this.config.get('settings/always-use-vm') === undefined) this.config.set('settings/always-use-vm', true);
    if (this.config.get('settings/always-use-vm')) this._view.optionVM.setAttribute('checked', '');
    this._view.personal = yo`<input onchange=${onchangePersonal} id="personal" type="checkbox" class="align-middle form-check-input">`;
    if (this.config.get('settings/personal-mode')) this._view.personal.setAttribute('checked', '');
    this._view.generateContractMetadata = yo`<input onchange=${onchangeGenerateContractMetadata} id="generatecontractmetadata" data-id="settingsTabGenerateContractMetadata" type="checkbox" class="form-check-input">`;
    if (this.config.get('settings/generate-contract-metadata')) this._view.generateContractMetadata.setAttribute('checked', '');
    this._view.pluginInput = yo`<textarea rows="4" cols="70" id="plugininput" type="text" class="${css.pluginTextArea}" ></textarea>`;
    this._view.themes = this._deps.themeModule.getThemes();
    this._view.themesCheckBoxes = this.createThemeCheckies();
    this._view.config.homePage = yo`

    <div class="${css.info} card">
      <div class="card-body">
      <h6 class="${css.title} card-title">Have a question?</h6>
      <button class="btn btn-primary sm-1" data-id="settingsTabGitterChannelButton" onclick="${() => {
      window.open('https://gitter.im/ethereum/remix');
    }}">Gitter Channel</button>
      </div>
    </div>`;
    const warnText = `Transaction sent over Web3 will use the web3.personal API - be sure the endpoint is opened before enabling it.
    This mode allows to provide the passphrase in the Remix interface without having to unlock the account.
    Although this is very convenient, you should completely trust the backend you are connected to (Geth, Parity, ...).
    Remix never persist any passphrase.`.split('\n').map(s => s.trim()).join(' ');
    this._view.warnPersonalMode = yo`<i class="${css.icon} fas fa-exclamation-triangle text-warning" aria-hidden="true"></i>`;
    this._view.config.general = yo`
      <div class="${css.info} card">
        <div class="card-body">
          <h6 class="${css.title} card-title">General settings</h6>
          <div class="form-check ${css.frow}">
            <div>${this._view.generateContractMetadata}</div>
            <label class="form-check-label align-middle" for="generatecontractmetadata">Generate contract metadata. Generate a JSON file in the contract folder. Allows to specify library addresses the contract depends on. If nothing is specified, Remix deploys libraries automatically.</label>
          </div>
          <div class="form-check ${css.frow}">
            <div>${this._view.optionVM}</div>
            <label class="form-check-label align-middle" for="alwaysUseVM">Always use Ethereum VM at Load</label>
          </div>
          <div class="form-check ${css.frow}">
            <div><input id="editorWrap" class="form-check-input align-middle" type="checkbox" onchange=${function () {
      this.editor.resize(this.checked);
    }}></div>
            <label class="form-check-label align-middle" for="editorWrap">Text Wrap</label>
          </div>
          <div class="form-check ${css.frow}">
            <div>${this._view.personal}></div>
            <label class="form-check-label align-middle" for="personal"> ${this._view.warnPersonalMode} Enable Personal Mode for web3 provider. ${warnText}></label>
          </div>
        </div>
      </div>
      `;
    this._view.gistToken = yo`
      <div class="${css.info} card">
        <div class="card-body">
          <h6 class="${css.title} card-title">Github Access Token</h6>
          <p class="">Manage the access token used to publish to Gist and retrieve Github contents.</p>
          <p class="">Go to github token page (link below) to create a new token and save it in Remix. Make sure this token has only 'create gist' permission.</p>
          <p class="${css.crowNoFlex}"><a target="_blank" href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></p>
          <div class="${css.crowNoFlex}">${this._view.gistToken}</div>
        </div>
      </div>`;
    this._view.config.themes = yo`
      <div class="${css.info} card">
        <div class="card-body">
          <h6 class="${css.title} card-title">Themes</h6>
            ${this._view.themesCheckBoxes}
        </div>
      </div>`;
    this._view.el = yo`
      <div class="${css.settingsTabView}" id="settingsView" data-id="settingsTabSettingsView">
        ${this._view.config.homePage}
        ${this._view.config.general}
        ${this._view.gistToken}
        ${this._view.config.themes}
      </div>`;

    function onchangeGenerateContractMetadata(event) {
      self.config.set('settings/generate-contract-metadata', !self.config.get('settings/generate-contract-metadata'));
    }

    function onchangeOption(event) {
      self.config.set('settings/always-use-vm', !self.config.get('settings/always-use-vm'));
    }

    function onchangePersonal(event) {
      self.config.set('settings/personal-mode', !self.config.get('settings/personal-mode'));
    }

    this._deps.themeModule.switchTheme();

    return this._view.el;
  }

  getGithubAccessToken() {
    return this.config.get('settings/gist-access-token');
  }

};

/***/ }),

/***/ "./app/tabs/staticanalysis/staticAnalysisView.js":
/*!*******************************************************!*\
  !*** ./app/tabs/staticanalysis/staticAnalysisView.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var StaticAnalysisRunner = __webpack_require__(/*! @remix-project/remix-analyzer */ "../../../dist/libs/remix-analyzer/index.js").CodeAnalysis;

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var utils = remixLib.util;

var css = __webpack_require__(/*! ./styles/staticAnalysisView-styles */ "./app/tabs/staticanalysis/styles/staticAnalysisView-styles.js");

var Renderer = __webpack_require__(/*! ../../ui/renderer */ "./app/ui/renderer.js");

const SourceHighlighter = __webpack_require__(/*! ../../editor/sourceHighlighter */ "./app/editor/sourceHighlighter.js");

var EventManager = __webpack_require__(/*! ../../../lib/events */ "./lib/events.js");

function staticAnalysisView(localRegistry, analysisModule) {
  var self = this;
  this.event = new EventManager();
  this.view = null;
  this.runner = new StaticAnalysisRunner();
  this.modulesView = this.renderModules();
  this.lastCompilationResult = null;
  this.lastCompilationSource = null;
  this.currentFile = 'No file compiled';
  this.sourceHighlighter = new SourceHighlighter();
  this.analysisModule = analysisModule;
  self._components = {
    renderer: new Renderer()
  };
  self._components.registry = localRegistry; // dependencies

  self._deps = {
    offsetToLineColumnConverter: self._components.registry.get('offsettolinecolumnconverter').api
  };
  analysisModule.on('solidity', 'compilationFinished', (file, source, languageVersion, data) => {
    self.lastCompilationResult = null;
    self.lastCompilationSource = null;
    if (languageVersion.indexOf('soljson') !== 0) return;
    self.lastCompilationResult = data;
    self.lastCompilationSource = source;
    self.currentFile = file;
    self.correctRunBtnDisabled();

    if (self.view && self.view.querySelector('#autorunstaticanalysis').checked) {
      self.run();
    }
  });
}

staticAnalysisView.prototype.render = function () {
  this.runBtn = yo`<button class="btn btn-sm w-25 btn-primary" onclick="${() => {
    this.run();
  }}" >Run</button>`;
  const view = yo`
    <div class="${css.analysis}">
      <div class="my-2 d-flex flex-column align-items-left">
        <div class="${css.top} d-flex justify-content-between">
          <div class="pl-2 ${css.label}" for="checkAllEntries">
            <input id="checkAllEntries"
              type="checkbox"
              onclick="${event => {
    this.checkAll(event);
  }}"
              style="vertical-align:bottom"
              checked="true"
            >
            <label class="text-nowrap pl-2 mb-0" for="checkAllEntries">
              Select all
            </label>
          </div>
          <div class="${css.label}" for="autorunstaticanalysis">
            <input id="autorunstaticanalysis"
              type="checkbox"
              style="vertical-align:bottom"
              checked="true"
            >
            <label class="text-nowrap pl-2 mb-0" for="autorunstaticanalysis">
              Autorun
            </label>
          </div>
          ${this.runBtn}
        </div>
      </div>
      <div id="staticanalysismodules" class="list-group list-group-flush">
        ${this.modulesView}
      </div>
      <div class="mt-2 p-2 d-flex border-top flex-column">
        <span>last results for:</span>
        <span class="text-break break-word word-break font-weight-bold" id="staticAnalysisCurrentFile">${this.currentFile}</span>
      </div>
      <div class="${css.result} my-1" id='staticanalysisresult'></div>
    </div>
  `;

  if (!this.view) {
    this.view = view;
  }

  this.correctRunBtnDisabled();
  return view;
};

staticAnalysisView.prototype.selectedModules = function () {
  if (!this.view) {
    return [];
  }

  const selected = this.view.querySelectorAll('[name="staticanalysismodule"]:checked');
  var toRun = [];

  for (var i = 0; i < selected.length; i++) {
    toRun.push(selected[i].attributes['index'].value);
  }

  return toRun;
};

staticAnalysisView.prototype.run = function () {
  if (!this.view) {
    return;
  }

  const highlightLocation = async (location, fileName) => {
    await this.analysisModule.call('editor', 'discardHighlight');
    await this.analysisModule.call('editor', 'highlight', location, fileName);
  };

  const selected = this.selectedModules();
  const warningContainer = $('#staticanalysisresult');
  warningContainer.empty();
  this.view.querySelector('#staticAnalysisCurrentFile').innerText = this.currentFile;
  var self = this;

  if (this.lastCompilationResult && selected.length) {
    this.runBtn.removeAttribute('disabled');
    let warningCount = 0;
    this.runner.run(this.lastCompilationResult, selected, results => {
      const groupedModules = utils.groupBy(preProcessModules(this.runner.modules()), 'categoryId');
      results.map((result, j) => {
        let moduleName;
        Object.keys(groupedModules).map(key => {
          groupedModules[key].forEach(el => {
            if (el.name === result.name) {
              moduleName = groupedModules[key][0].categoryDisplayName;
              return;
            }
          });
        });
        let alreadyExistedEl = this.view.querySelector(`[id="staticAnalysisModule${moduleName}"]`);

        if (!alreadyExistedEl) {
          warningContainer.append(`
            <div class="mb-4" name="staticAnalysisModules" id="staticAnalysisModule${moduleName}">
              <span class="text-dark h6">${moduleName}</span>
            </div>
          `);
        }

        result.report.map((item, i) => {
          let location = '';
          let locationString = 'not available';
          let column = 0;
          let row = 0;
          let fileName = this.currentFile;

          if (item.location) {
            var split = item.location.split(':');
            var file = split[2];
            location = {
              start: parseInt(split[0]),
              length: parseInt(split[1])
            };
            location = self._deps.offsetToLineColumnConverter.offsetToLineColumn(location, parseInt(file), self.lastCompilationSource.sources, self.lastCompilationResult.sources);
            row = location.start.line;
            column = location.start.column;
            locationString = row + 1 + ':' + column + ':';
            fileName = Object.keys(self.lastCompilationResult.contracts)[file];
          }

          warningCount++;
          const msg = yo`
            <span class="d-flex flex-column">
              <span class="h6 font-weight-bold">${result.name}</span>
              ${item.warning}
              ${item.more ? yo`<span><a href="${item.more}" target="_blank">more</a></span>` : yo`<span></span>`}
              <span class="" title="Position in ${fileName}">Pos: ${locationString}</span>
            </span>`;

          self._components.renderer.error(msg, this.view.querySelector(`[id="staticAnalysisModule${moduleName}"]`), {
            click: () => highlightLocation(location, fileName),
            type: 'warning',
            useSpan: true,
            errFile: fileName,
            errLine: row,
            errCol: column
          });
        });
      }); // hide empty staticAnalysisModules sections

      this.view.querySelectorAll('[name="staticAnalysisModules"]').forEach(section => {
        if (!section.getElementsByClassName('alert-warning').length) section.hidden = true;
      });
      self.event.trigger('staticAnaysisWarning', [warningCount]);
    });
  } else {
    this.runBtn.setAttribute('disabled', 'disabled');

    if (selected.length) {
      warningContainer.html('No compiled AST available');
    }

    self.event.trigger('staticAnaysisWarning', [-1]);
  }
};

staticAnalysisView.prototype.checkModule = function (event) {
  const selected = this.view.querySelectorAll('[name="staticanalysismodule"]:checked');
  const checkAll = this.view.querySelector('[id="checkAllEntries"]');
  this.correctRunBtnDisabled();

  if (event.target.checked) {
    checkAll.checked = true;
  } else if (!selected.length) {
    checkAll.checked = false;
  }
};

staticAnalysisView.prototype.correctRunBtnDisabled = function () {
  const selected = this.view.querySelectorAll('[name="staticanalysismodule"]:checked');

  if (this.lastCompilationResult && selected.length !== 0) {
    this.runBtn.removeAttribute('disabled');
  } else {
    this.runBtn.setAttribute('disabled', 'disabled');
  }
};

staticAnalysisView.prototype.checkAll = function (event) {
  if (!this.view) {
    return;
  } // checks/unchecks all


  const checkBoxes = this.view.querySelectorAll('[name="staticanalysismodule"]');
  checkBoxes.forEach(checkbox => {
    checkbox.checked = event.target.checked;
  });
  this.correctRunBtnDisabled();
};

staticAnalysisView.prototype.handleCollapse = function (e) {
  const downs = e.toElement.parentElement.getElementsByClassName('fas fa-angle-double-right');
  const iEls = document.getElementsByTagName('i');

  for (var i = 0; i < iEls.length; i++) {
    iEls[i].hidden = false;
  }

  downs[0].hidden = true;
};

staticAnalysisView.prototype.renderModules = function () {
  const groupedModules = utils.groupBy(preProcessModules(this.runner.modules()), 'categoryId');
  const moduleEntries = Object.keys(groupedModules).map((categoryId, i) => {
    const category = groupedModules[categoryId];
    const entriesDom = category.map((item, i) => {
      return yo`
        <div class="form-check">
          <input id="staticanalysismodule_${categoryId}_${i}"
            type="checkbox"
            class="form-check-input staticAnalysisItem"
            name="staticanalysismodule"
            index=${item._index}
            checked="true"
            style="vertical-align:bottom"
            onclick="${event => this.checkModule(event)}"
          >
          <label for="staticanalysismodule_${categoryId}_${i}" class="form-check-label mb-1">
            <p class="mb-0 font-weight-bold text-capitalize">${item.name}</p>
            ${item.description}
          </label>
        </div>
      `;
    });
    return yo`
      <div class="${css.block}">
        <input type="radio" name="accordion" class="w-100 d-none card" id="heading${categoryId}" onclick=${e => this.handleCollapse(e)}"/>
        <label for="heading${categoryId}" style="cursor: pointer;" class="pl-3 card-header h6 d-flex justify-content-between font-weight-bold border-left px-1 py-2 w-100">
          ${category[0].categoryDisplayName}
          <div>
            <i class="fas fa-angle-double-right"></i>
          </div>
        </label>
        <div class="w-100 d-block px-2 my-1 ${css.entries}">
          ${entriesDom}
        </div>
      </div>
    `;
  }); // collaps first module

  moduleEntries[0].getElementsByTagName('input')[0].checked = true;
  moduleEntries[0].getElementsByTagName('i')[0].hidden = true;
  return yo`
    <div class="accordion" id="accordionModules">
      ${moduleEntries}
    </div>`;
};

module.exports = staticAnalysisView;
/**
 * @dev Process & categorize static analysis modules to show them on UI
 * @param arr list of static analysis modules received from remix-analyzer module
 */

function preProcessModules(arr) {
  return arr.map((Item, i) => {
    const itemObj = new Item();
    itemObj['_index'] = i;
    itemObj.categoryDisplayName = itemObj.category.displayName;
    itemObj.categoryId = itemObj.category.id;
    return itemObj;
  });
}

/***/ }),

/***/ "./app/tabs/staticanalysis/styles/staticAnalysisView-styles.js":
/*!*********************************************************************!*\
  !*** ./app/tabs/staticanalysis/styles/staticAnalysisView-styles.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .analysis {
    display: flex;
    flex-direction: column;
  }
  .result {
    margin-top: 1%;
    max-height: 300px;
    word-break: break-word;
  }
  .buttons  {
    margin: 1rem 0;
  }
  .label {
    display: flex;
    align-items: center;
  }
  .label {
    display: flex;
    align-items: center;
    user-select: none;
  }
  .block input[type='radio']:checked ~ .entries{
    height: auto;
    transition: .5s ease-in;
  }
  .entries{
    height: 0;
    overflow: hidden;
    transition: .5s ease-out;
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/tabs/styles/compile-tab-styles.js":
/*!***********************************************!*\
  !*** ./app/tabs/styles/compile-tab-styles.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const css = csjs`
  .title {
    font-size: 1.1em;
    font-weight: bold;
    margin-bottom: 1em;
  }
  .panicError {
    color: red;
    font-size: 20px;
  }
  .crow {
    display: flex;
    overflow: auto;
    clear: both;
    padding: .2em;
  }
  .checkboxText {
    font-weight: normal;
  }
  .crow label {
    cursor:pointer;
  }
  .crowNoFlex {
    overflow: auto;
    clear: both;
  }
  .info {
    padding: 10px;
    word-break: break-word;
  }
  .contract {
    display: block;
    margin: 3% 0;
  }
  .nightlyBuilds {
    display: flex;
    flex-direction: row;
    align-items: center;
  }
  .autocompileContainer {
    display: flex;
    align-items: center;
  }
  .hideWarningsContainer {
    display: flex;
    align-items: center;
  }
  .autocompile {}
  .autocompileTitle {
    font-weight: bold;
    margin: 1% 0;
  }
  .autocompileText {
    margin: 1% 0;
    font-size: 12px;
    overflow: hidden;
    word-break: normal;
    line-height: initial;
  }
  .warnCompilationSlow {
    margin-left: 1%;
  }
  .compilerConfig {
    display: flex;
    align-items: center;
  }
  .compilerConfig label {
    margin: 0;
  }
  .compilerSection {
    padding: 12px 24px 16px;
  }
  .compilerLabel {
    margin-bottom: 2px;
    font-size: 11px;
    line-height: 12px;
    text-transform: uppercase;
  }
  .copyButton {
    padding: 6px;
    font-weight: bold;
    font-size: 11px;
    line-height: 15px;
  }
  .name {
    display: flex;
  }
  .size {
    display: flex;
  }
  .checkboxes {
    display: flex;
    width: 100%;
    justify-content: space-between;
    flex-wrap: wrap;
  }
  .compileButton {
    width: 100%;
    margin: 15px 0 10px 0;
    font-size: 12px;
  }
  .container {
    margin: 0;
    margin-bottom: 2%;
  }
  .optimizeContainer {
    display: flex;
  }
  .noContractAlert {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .contractHelperButtons {
    margin-top: 6px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    float: right;
  }
  .copyToClipboard {
    font-size: 1rem;
  }
  .copyIcon {
    margin-right: 5px;
  }
  .log {
    display: flex;
    flex-direction: column;
    margin-bottom: 5%;
    overflow: visible;
  }
  .key {
    margin-right: 5px;
    text-transform: uppercase;
    width: 100%;
  }
  .value {
    display: flex;
    width: 100%;
    margin-top: 1.5%;
  }
  .questionMark {
    margin-left: 2%;
    cursor: pointer;
  }
  .questionMark:hover {
  }
  .detailsJSON {
    padding: 8px 0;
    border: none;
  }
  .icon {
    margin-right: 0.3em;
  }
  .errorBlobs {
    padding-left: 5px;
    padding-right: 5px;
    word-break: break-word;
  }
  .storageLogo {
    width: 20px;
    height: 20px;
  }
  .spinningIcon {
    display: inline-block;
    position: relative;
    animation: spin 2s infinite linear;
    -moz-animation: spin 2s infinite linear;
    -o-animation: spin 2s infinite linear;
    -webkit-animation: spin 2s infinite linear;
  }
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  @-webkit-keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  @-moz-keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  @-o-keyframes spin {
     0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  @-ms-keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .bouncingIcon {
    display: inline-block;
    position: relative;
    -moz-animation: bounce 2s infinite linear;
    -o-animation: bounce 2s infinite linear;
    -webkit-animation: bounce 2s infinite linear;
    animation: bounce 2s infinite linear;
  } 

  @-webkit-keyframes bounce {
      0% { top: 0; }
      50% { top: -0.2em; }
      70% { top: -0.3em; }
      100% { top: 0; }
  }
  @-moz-keyframes bounce {
      0% { top: 0; }
      50% { top: -0.2em; }
      70% { top: -0.3em; }
      100% { top: 0; }
  }
  @-o-keyframes bounce {
      0% { top: 0; }
      50% { top: -0.2em; }
      70% { top: -0.3em; }
      100% { top: 0; }
  }
  @-ms-keyframes bounce {
      0% { top: 0; }
      50% { top: -0.2em; }
      70% { top: -0.3em; }
      100% { top: 0; }
  }
  @keyframes bounce {
      0% { top: 0; }
      50% { top: -0.2em; }
      70% { top: -0.3em; }
      100% { top: 0; }
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/tabs/styles/debugger-tab-styles.js":
/*!************************************************!*\
  !*** ./app/tabs/styles/debugger-tab-styles.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const css = csjs`
  .debuggerTabView {
    padding: 2%;
  }
  .debugger {
    margin-bottom: 1%;
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/tabs/styles/run-tab-styles.js":
/*!*******************************************!*\
  !*** ./app/tabs/styles/run-tab-styles.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .runTabView {
    display: flex;
    flex-direction: column;
  }
  .runTabView::-webkit-scrollbar {
    display: none;
  }
  .settings {
    padding: 0 24px 16px;
  }
  .crow {
    display: block;
    margin-top: 8px;
  }
  .col1 {
    width: 30%;
    float: left;
    align-self: center;
  }
  .settingsLabel {
    font-size: 11px;
    margin-bottom: 4px;
    text-transform: uppercase;
  }
  .environment {
    display: flex;
    align-items: center;
    position: relative;
    width: 100%;
  }
  .environment a {
    margin-left: 7px;
  }
  .account {
    display: flex;
    align-items: center;
  }
  .account i {
    margin-left: 12px;
  }
  .col2 {
    border-radius: 3px;
  }
  .col2_1 {
    width: 164px;
    min-width: 164px;
  }
  .col2_2 {
  }
  .select {
    font-weight: normal;
    width: 100%;
  }
  .instanceContainer {
    display: flex;
    flex-direction: column;
    margin-bottom: 2%;
    border: none;
    text-align: center;
    padding: 0 14px 16px;
  }
  .pendingTxsContainer  {
    display: flex;
    flex-direction: column;
    margin-top: 2%;
    border: none;
    text-align: center;
  }
  .container {
    padding: 0 24px 16px;
  }
  .recorderDescription {
    margin: 0 15px 15px 0;
   }
  .contractNames {
    width: 100%;
    border: 1px solid
  }
  .subcontainer {
    display: flex;
    flex-direction: row;
    align-items: center;
    margin-bottom: 8px;
  }
  .subcontainer i {
    width: 16px;
    display: flex;
    justify-content: center;
    margin-left: 1px;
  }
  .button button{
    flex: none;
  }
  .button {
    display: flex;
    align-items: center;
    margin-top: 13px;
  }
  .transaction {
  }
  .atAddress {
    margin: 0;
    min-width: 100px;
    width: 100px;
    height: 100%;
    word-break: inherit;
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
    border-right: 0;
  }
  .atAddressSect {
    margin-top: 8px;
    height: 32px;
  }
  .atAddressSect input {
    height: 32px;
    border-top-left-radius: 0 !important;
    border-bottom-left-radius: 0 !important;
  }
  .ataddressinput {
    padding: .25rem;
  }
  .create {
  }
  .input {
    font-size: 10px !important;
  }
  .noInstancesText {
    font-style: italic;
    text-align: left;
    padding-left: 15px;
  }
  .pendingTxsText {
    font-style: italic;
    display: flex;
    justify-content: space-evenly;
    align-items: center;
    flex-wrap: wrap;
  }
  .item {
    margin-right: 1em;
    display: flex;
    align-items: center;
  }
  .pendingContainer {
    display: flex;
    align-items: baseline;
  }
  .pending {
    height: 25px;
    text-align: center;
    padding-left: 10px;
    border-radius: 3px;
    margin-left: 5px;
  }
  .disableMouseEvents {
    pointer-events: none;
  }
  .icon {
    cursor: pointer;
    font-size: 12px;
    cursor: pointer;
    margin-left: 5px;
  }
  .icon:hover {
    font-size: 12px;
    color: var(--warning);
  }
  .errorIcon {
    color: var(--warning);
    margin-left: 15px;
  }
  .failDesc {
    color: var(--warning);
    padding-left: 10px;
    display: inline;
  }
  .network {
    margin-left: 8px;
    pointer-events: none;
  }
  .networkItem {
    margin-right: 5px;
  }
  .transactionActions {
    display: flex;
    justify-content: space-evenly;
    width: 145px;
  }
  .orLabel {
    text-align: center;
    text-transform: uppercase;
  }
  .infoDeployAction {
    margin-left: 1px;
    font-size: 13px;
    color: var(--info);
  }
  .gasValueContainer {
    flex-direction: row;
    display: flex;
  }
  .gasNval {
    width: 55%;
    font-size: 0.8rem;
  }
  .gasNvalUnit {
    width: 41%;
    margin-left: 10px;
    font-size: 0.8rem;
  }
  .deployDropdown {
    text-align: center;
    text-transform: uppercase;
  }
  .checkboxAlign {
    padding-top: 2px;
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/tabs/styles/settings-tab-styles.js":
/*!************************************************!*\
  !*** ./app/tabs/styles/settings-tab-styles.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const css = csjs`
  .settingsTabView {
    padding: 2%;
  }
  .info {
    margin-bottom: .6rem;
    word-break: break-word;
    font-size: .8rem;
  }
  .info h7 {
    margin-bottom: .5rem;
  }
  .frow {
    margin-bottom: .5rem;
  }
  .crow label {
    cursor:pointer;
  }
  .crowNoFlex {
    overflow: auto;
    clear: both;
  }
  .attention {
    margin-bottom: 1em;
    padding: .5em;
    font-weight: bold;
  }
  .heading {
    margin-bottom: 0;
  }
  .explaination {
    margin-top: 3px;
    margin-bottom: 3px;
  }
  input {
    width: inherit;
  }
  input[type=radio] {
    margin-top: 2px;
  }
  .pluginTextArea {
    font-family: unset;
  }

  .removePlugin {
    cursor: pointer;
  }
  .icon {
    margin-right: .5em;
  }
  .aPlugin {
    display: inline-block;
    padding-left: 10px;
    padding-top: 4px;
    padding-bottom: 6px;
    max-width: 100px;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
    vertical-align: middle;
  }
  .removePlugin{
    padding-left: 7px;
    padding-right: 7px;
    margin-left: 10px;
  }
  .inline {
    display: inline;
    width: 32%;
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/tabs/styles/test-tab-styles.js":
/*!********************************************!*\
  !*** ./app/tabs/styles/test-tab-styles.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .testTabView {}
  .infoBox  {
    margin: 5%;
  }
  .tests {}
  .testList {
    line-height: 2em;
    display: flex;
    flex-direction: column;
    margin: 5%;
    max-height: 300px;
    overflow-y: auto;

  }
  .container {
    margin: 2%;
    padding-bottom: 5%;
    max-height: 300px;
    overflow-y: auto;
  }
  .summaryTitle {
    font-weight: bold;
  }
  .testPass {
  }
  .testLog {
    margin-bottom: 1%;
    border-radius: 4px;
    padding: 1% 1% 1% 5%;
  }
  .testFailure {
  }
  .testFailureSummary {
  }
  .title {
    font-size: 1.1em;
    font-weight: bold;
    margin-bottom: 1em;
  }
  .label {
    display: flex;
    align-items: center;
    white-space: nowrap;
  }
  .labelOnBtn {
    border: hidden;
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/tabs/test-tab.js":
/*!******************************!*\
  !*** ./app/tabs/test-tab.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var _compilerUtils = __webpack_require__(/*! ../compiler/compiler-utils */ "./app/compiler/compiler-utils.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

var tooltip = __webpack_require__(/*! ../ui/tooltip */ "./app/ui/tooltip.js");

var css = __webpack_require__(/*! ./styles/test-tab-styles */ "./app/tabs/styles/test-tab-styles.js");

var remixTests = __webpack_require__(/*! @remix-project/remix-tests */ "../../../dist/libs/remix-tests/src/index.js");

const TestTabLogic = __webpack_require__(/*! ./testTab/testTab */ "./app/tabs/testTab/testTab.js");

const profile = {
  name: 'solidityUnitTesting',
  displayName: 'Solidity unit testing',
  methods: ['testFromPath', 'testFromSource'],
  events: [],
  icon: 'assets/img/unitTesting.webp',
  description: 'Fast tool to generate unit tests for your contracts',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/unittesting.html'
};
module.exports = class TestTab extends _engine.ViewPlugin {
  constructor(fileManager, filePanel, compileTab, appManager, renderer) {
    super(profile);
    this.compileTab = compileTab;
    this._view = {
      el: null
    };
    this.fileManager = fileManager;
    this.filePanel = filePanel;
    this.data = {};
    this.appManager = appManager;
    this.renderer = renderer;
    this.hasBeenStopped = false;
    this.runningTestsNumber = 0;
    this.readyTestsNumber = 0;
    this.areTestsRunning = false;
    this.defaultPath = 'browser/tests';
    appManager.event.on('activate', name => {
      if (name === 'solidity') this.updateRunAction();
    });
    appManager.event.on('deactivate', name => {
      if (name === 'solidity') this.updateRunAction();
    });
  }

  onActivationInternal() {
    this.testTabLogic = new TestTabLogic(this.fileManager);
    this.listenToEvents();
  }

  listenToEvents() {
    this.filePanel.event.register('newTestFileCreated', file => {
      var testList = this.view.querySelector("[class^='testList']");
      var test = this.createSingleTest(file);
      testList.appendChild(test);
      this.data.allTests.push(file);
      this.data.selectedTests.push(file);
    });
    this.fileManager.events.on('noFileSelected', () => {});
    this.fileManager.events.on('currentFileChanged', (file, provider) => this.updateForNewCurrent(file));
  }

  updateForNewCurrent(file) {
    this.updateGenerateFileAction(file);
    if (!this.areTestsRunning) this.updateRunAction(file);
    this.testTabLogic.getTests((error, tests) => {
      if (error) return tooltip(error);
      this.data.allTests = tests;
      this.data.selectedTests = [...this.data.allTests];
      this.updateTestFileList(tests);
      if (!this.testsOutput) return;
    });
  }

  createSingleTest(testFile) {
    return yo`
      <div class="d-flex align-items-center py-1">
        <input class="singleTest" id="singleTest${testFile}" onchange=${e => this.toggleCheckbox(e.target.checked, testFile)} type="checkbox" checked="true">
        <label class="singleTestLabel text-nowrap pl-2 mb-0" for="singleTest${testFile}">${testFile}</label>
      </div>
    `;
  }

  listTests() {
    if (!this.data.allTests) return [];
    return this.data.allTests.map(testFile => this.createSingleTest(testFile));
  }

  toggleCheckbox(eChecked, test) {
    if (!this.data.selectedTests) {
      this.data.selectedTests = this._view.el.querySelectorAll('.singleTest:checked');
    }

    let selectedTests = this.data.selectedTests;
    selectedTests = eChecked ? [...selectedTests, test] : selectedTests.filter(el => el !== test);
    this.data.selectedTests = selectedTests;

    let checkAll = this._view.el.querySelector('[id="checkAllTests"]');

    const runBtn = document.getElementById('runTestsTabRunAction');

    if (eChecked) {
      checkAll.checked = true;
      const stopBtnInnerText = document.getElementById('runTestsTabStopAction').innerText;

      if ((this.readyTestsNumber === this.runningTestsNumber || this.hasBeenStopped) && stopBtnInnerText.trim() === 'Stop') {
        runBtn.removeAttribute('disabled');
        runBtn.setAttribute('title', 'Run tests');
      }
    } else if (!selectedTests.length) {
      checkAll.checked = false;
      runBtn.setAttribute('disabled', 'disabled');
      runBtn.setAttribute('title', 'No test file selected');
    }
  }

  checkAll(event) {
    const checkBoxes = this._view.el.querySelectorAll('.singleTest');

    const checkboxesLabels = this._view.el.querySelectorAll('.singleTestLabel'); // checks/unchecks all


    for (let i = 0; i < checkBoxes.length; i++) {
      checkBoxes[i].checked = event.target.checked;
      this.toggleCheckbox(event.target.checked, checkboxesLabels[i].innerText);
    }
  }

  testCallback(result) {
    this.testsOutput.hidden = false;

    if (result.type === 'contract') {
      this.testSuite = result.value;

      if (this.testSuites) {
        this.testSuites.push(this.testSuite);
      } else {
        this.testSuites = [this.testSuite];
      }

      this.rawFileName = result.filename;
      this.runningTestFileName = this.cleanFileName(this.rawFileName, this.testSuite);
      this.outputHeader = yo`
        <div id="${this.runningTestFileName}" data-id="testTabSolidityUnitTestsOutputheader" class="pt-1">
          <span class="font-weight-bold">${this.testSuite} (${this.rawFileName})</span>
        </div>
      `;
      this.testsOutput.appendChild(this.outputHeader);
    } else if (result.type === 'testPass') {
      this.testsOutput.appendChild(yo`
        <div id="${this.runningTestFileName}" data-id="testTabSolidityUnitTestsOutputheader" class="${css.testPass} ${css.testLog} text-success border-0">
           ${result.value}
        </div>
      `);
    } else if (result.type === 'testFailure') {
      this.testsOutput.appendChild(yo`
        <div class="${css.testFailure} ${css.testLog} d-flex flex-column text-danger border-0" id="UTContext${result.context}">
          <span>  ${result.value}</span>
          <span>"${result.errMsg}"</span>
        </div>
      `);
    }
  }

  resultsCallback(_err, result, cb) {
    // total stats for the test
    // result.passingNum
    // result.failureNum
    // result.timePassed
    cb();
  }

  cleanFileName(fileName, testSuite) {
    return fileName ? fileName.replace(/\//g, '_').replace(/\./g, '_') + testSuite : fileName;
  }

  setHeader(status) {
    if (status) {
      const label = yo`
        <div
          class="alert-success d-inline-block mb-1 mr-1 p-1 passed_${this.runningTestFileName}"
          title="All contract tests passed"
        >
          PASS
        </div>
      `;
      this.outputHeader && yo.update(this.outputHeader, yo`
        <div id="${this.runningTestFileName}" data-id="testTabSolidityUnitTestsOutputheader" class="pt-1">
          ${label} <span class="font-weight-bold">${this.testSuite} (${this.rawFileName})</span>
        </div>
      `);
    } else {
      const label = yo`
        <div
          class="alert-danger d-inline-block mb-1 mr-1 p-1 failed_${this.runningTestFileName}"
          title="At least one contract test failed"
        >
          FAIL
        </div>
      `;
      this.outputHeader && yo.update(this.outputHeader, yo`
        <div id="${this.runningTestFileName}"  data-id="testTabSolidityUnitTestsOutputheader" class="pt-1">
          ${label} <span class="font-weight-bold">${this.testSuite} (${this.rawFileName})</span>
        </div>
      `);
    }
  }

  updateFinalResult(_errors, result, filename) {
    ++this.readyTestsNumber;
    this.testsOutput.hidden = false;

    if (!result && (_errors || _errors.errors || Array.isArray(_errors) && (_errors[0].message || _errors[0].formattedMessage))) {
      this.testCallback({
        type: 'contract',
        filename
      });
      this.setHeader(false);
    }

    if (_errors && _errors.errors) {
      _errors.errors.forEach(err => this.renderer.error(err.formattedMessage || err.message, this.testsOutput, {
        type: err.severity
      }));
    } else if (_errors && Array.isArray(_errors) && (_errors[0].message || _errors[0].formattedMessage)) {
      _errors.forEach(err => this.renderer.error(err.formattedMessage || err.message, this.testsOutput, {
        type: err.severity
      }));
    } else if (_errors && !_errors.errors && !Array.isArray(_errors)) {
      // To track error like this: https://github.com/ethereum/remix/pull/1438
      this.renderer.error(_errors.formattedMessage || _errors.message, this.testsOutput, {
        type: 'error'
      });
    }

    yo.update(this.resultStatistics, this.createResultLabel());

    if (result) {
      const totalTime = parseFloat(result.totalTime).toFixed(2);

      if (result.totalPassing > 0 && result.totalFailing > 0) {
        this.testsOutput.appendChild(yo`
          <div class="d-flex alert-secondary mb-3 p-3 flex-column">
            <span class="font-weight-bold">Result for ${filename}</span>
            <span class="text-success">Passing: ${result.totalPassing}</span>
            <span class="text-danger">Failing: ${result.totalFailing}</span>
            <span>Total time: ${totalTime}s</span>
          </div>
        `);
      } else if (result.totalPassing > 0 && result.totalFailing <= 0) {
        this.testsOutput.appendChild(yo`
          <div class="d-flex alert-secondary mb-3 p-3 flex-column">
            <span class="font-weight-bold">Result for ${filename}</span>
            <span class="text-success">Passing: ${result.totalPassing}</span>
            <span>Total time: ${totalTime}s</span>
          </div>
        `);
      } else if (result.totalPassing <= 0 && result.totalFailing > 0) {
        this.testsOutput.appendChild(yo`
          <div class="d-flex alert-secondary mb-3 p-3 flex-column">
            <span class="font-weight-bold">Result for ${filename}</span>
            <span class="text-danger">Failing: ${result.totalFailing}</span>
            <span>Total time: ${totalTime}s</span>
          </div>
        `);
      } // fix for displaying right label for multiple tests (testsuites) in a single file


      this.testSuites.forEach(testSuite => {
        this.testSuite = testSuite;
        this.runningTestFileName = this.cleanFileName(filename, this.testSuite);
        this.outputHeader = document.querySelector(`#${this.runningTestFileName}`);
        this.setHeader(true);
      });
      result.errors.forEach((error, index) => {
        this.testSuite = error.context;
        this.runningTestFileName = this.cleanFileName(filename, error.context);
        this.outputHeader = document.querySelector(`#${this.runningTestFileName}`);
        const isFailingLabel = document.querySelector(`.failed_${this.runningTestFileName}`);
        if (!isFailingLabel) this.setHeader(false);
      });
      this.testsOutput.appendChild(yo`
        <div>
          <p class="text-info mb-2 border-top m-0"></p>
        </div>
      `);
    }

    if (this.hasBeenStopped && this.readyTestsNumber !== this.runningTestsNumber) {
      // if all tests has been through before stopping no need to print this.
      this.testsExecutionStopped.hidden = false;
    }

    if (_errors) this.testsExecutionStoppedError.hidden = false;

    if (_errors || this.hasBeenStopped || this.readyTestsNumber === this.runningTestsNumber) {
      // All tests are ready or the operation has been canceled or there was a compilation error in one of the test files.
      const stopBtn = document.getElementById('runTestsTabStopAction');
      stopBtn.setAttribute('disabled', 'disabled');
      const stopBtnLabel = document.getElementById('runTestsTabStopActionLabel');
      stopBtnLabel.innerText = 'Stop';

      if (this.data.selectedTests.length !== 0) {
        const runBtn = document.getElementById('runTestsTabRunAction');
        runBtn.removeAttribute('disabled');
      }

      this.areTestsRunning = false;
    }
  }

  async testFromPath(path) {
    const fileContent = await this.fileManager.readFile(path);
    return this.testFromSource(fileContent, path);
  }
  /*
    Test is not associated with the UI
  */


  testFromSource(content, path = 'browser/unit_test.sol') {
    return new Promise((resolve, reject) => {
      let runningTest = {};
      runningTest[path] = {
        content
      };
      const {
        currentVersion,
        evmVersion,
        optimize
      } = this.compileTab.getCurrentCompilerConfig();
      const currentCompilerUrl = (0, _compilerUtils.urlFromVersion)(currentVersion);
      const compilerConfig = {
        currentCompilerUrl,
        evmVersion,
        optimize,
        usingWorker: (0, _compilerUtils.canUseWorker)(currentVersion)
      };
      remixTests.runTestSources(runningTest, compilerConfig, () => {}, () => {}, (error, result) => {
        if (error) return reject(error);
        resolve(result);
      }, (url, cb) => {
        return this.compileTab.compileTabLogic.importFileCb(url, cb);
      });
    });
  }

  runTest(testFilePath, callback) {
    if (this.hasBeenStopped) {
      this.updateFinalResult();
      return;
    }

    this.resultStatistics.hidden = false;
    this.fileManager.readFile(testFilePath).then(content => {
      const runningTest = {};
      runningTest[testFilePath] = {
        content
      };
      const {
        currentVersion,
        evmVersion,
        optimize
      } = this.compileTab.getCurrentCompilerConfig();
      const currentCompilerUrl = (0, _compilerUtils.urlFromVersion)(currentVersion);
      const compilerConfig = {
        currentCompilerUrl,
        evmVersion,
        optimize,
        usingWorker: (0, _compilerUtils.canUseWorker)(currentVersion)
      };
      remixTests.runTestSources(runningTest, compilerConfig, result => this.testCallback(result), (_err, result, cb) => this.resultsCallback(_err, result, cb), (error, result) => {
        this.updateFinalResult(error, result, testFilePath);
        callback(error);
      }, (url, cb) => {
        return this.compileTab.compileTabLogic.importFileCb(url, cb);
      });
    }).catch(error => {
      if (error) return;
    });
  }

  updateCurrentPath(e) {
    const newValue = e.target.value === '' ? this.defaultPath : e.target.value;
    this.testTabLogic.setCurrentPath(newValue);
    this.updateRunAction();
    this.updateForNewCurrent();
  }

  runTests() {
    this.areTestsRunning = true;
    this.hasBeenStopped = false;
    this.readyTestsNumber = 0;
    this.runningTestsNumber = this.data.selectedTests.length;
    yo.update(this.resultStatistics, this.createResultLabel());
    const stopBtn = document.getElementById('runTestsTabStopAction');
    stopBtn.removeAttribute('disabled');
    const runBtn = document.getElementById('runTestsTabRunAction');
    runBtn.setAttribute('disabled', 'disabled');
    this.call('editor', 'clearAnnotations');
    this.testsOutput.innerHTML = '';
    this.testsOutput.hidden = true;
    this.testsExecutionStopped.hidden = true;
    this.testsExecutionStoppedError.hidden = true;
    const tests = this.data.selectedTests;
    if (!tests) return;
    this.resultStatistics.hidden = tests.length === 0;
    async.eachOfSeries(tests, (value, key, callback) => {
      if (this.hasBeenStopped) return;
      this.runTest(value, callback);
    });
  }

  stopTests() {
    this.hasBeenStopped = true;
    const stopBtnLabel = document.getElementById('runTestsTabStopActionLabel');
    stopBtnLabel.innerText = 'Stopping';
    const stopBtn = document.getElementById('runTestsTabStopAction');
    stopBtn.setAttribute('disabled', 'disabled');
    const runBtn = document.getElementById('runTestsTabRunAction');
    runBtn.setAttribute('disabled', 'disabled');
  }

  updateGenerateFileAction(currentFile) {
    let el = yo`
      <button
        class="btn border w-50"
        data-id="testTabGenerateTestFile"
        title="Generate sample test file."
        onclick="${this.testTabLogic.generateTestFile.bind(this.testTabLogic)}"
      >
        Generate
      </button>
    `;

    if (!this.generateFileActionElement) {
      this.generateFileActionElement = el;
    } else {
      yo.update(this.generateFileActionElement, el);
    }

    return this.generateFileActionElement;
  }

  updateRunAction(currentFile) {
    let el = yo`
      <button id="runTestsTabRunAction" title="Run tests" data-id="testTabRunTestsTabRunAction" class="w-50 btn btn-primary" onclick="${() => this.runTests()}">
        <span class="fas fa-play ml-2"></span>
        <label class="${css.labelOnBtn} btn btn-primary p-1 ml-2 m-0">Run</label>
      </button>
    `;
    const isSolidityActive = this.appManager.isActive('solidity');

    if (!isSolidityActive || !this.listTests().length) {
      el.setAttribute('disabled', 'disabled');

      if (!currentFile || currentFile && currentFile.split('.').pop().toLowerCase() !== 'sol') {
        el.setAttribute('title', 'No solidity file selected');
      } else {
        el.setAttribute('title', 'The "Solidity Plugin" should be activated'); // @todo(#2747)  we can activate the plugin here
      }
    }

    if (!this.runActionElement) {
      this.runActionElement = el;
    } else {
      yo.update(this.runActionElement, el);
    }

    return this.runActionElement;
  }

  updateStopAction() {
    return yo`
      <button id="runTestsTabStopAction" data-id="testTabRunTestsTabStopAction" class="w-50 pl-2 ml-2 btn btn-secondary" disabled="disabled" title="Stop running tests" onclick=${() => this.stopTests()}">
        <span class="fas fa-stop ml-2"></span>
        <label class="${css.labelOnBtn} btn btn-secondary p-1 ml-2 m-0" id="runTestsTabStopActionLabel">Stop</label>
      </button>
    `;
  }

  updateTestFileList(tests) {
    const testsMessage = tests && tests.length ? this.listTests() : 'No test file available';
    let el = yo`<div class="${css.testList} py-2 mt-0 border-bottom">${testsMessage}</div>`;

    if (!this.testFilesListElement) {
      this.testFilesListElement = el;
    } else {
      yo.update(this.testFilesListElement, el);
    }

    this.updateRunAction();
    return this.testFilesListElement;
  }

  selectAll() {
    return yo`
      <div class="d-flex align-items-center mx-3 pb-2 mt-2 border-bottom">
        <input id="checkAllTests"
          type="checkbox"
          data-id="testTabCheckAllTests"
          onclick="${event => {
      this.checkAll(event);
    }}"
          checked="true"
        >
        <label class="text-nowrap pl-2 mb-0" for="checkAllTests"> Select all </label>
      </div>
    `;
  }

  infoButton() {
    return yo`
      <a class="btn border text-decoration-none pr-0 d-flex w-50 ml-2" title="Check out documentation." target="__blank" href="https://remix-ide.readthedocs.io/en/latest/unittesting.html#generate-test-file">
        <label class="btn p-1 ml-2 m-0">How to use...</label>
      </a>
    `;
  }

  createResultLabel() {
    if (!this.data.selectedTests) return yo`<span></span>`;
    const ready = this.readyTestsNumber ? `${this.readyTestsNumber}` : '0';
    return yo`<span class='text-info h6'>Progress: ${ready} finished (of ${this.runningTestsNumber})</span>`;
  }

  updateDirList() {
    for (var o of this.uiPathList.querySelectorAll('option')) o.remove();

    this.uiPathList.appendChild(yo`<option>browser</option>`);
    if (this.testTabLogic.isRemixDActive()) this.uiPathList.appendChild(yo`<option>localhost</option>`);
    if (!this._view.el) return;
    this.testTabLogic.dirList(this.inputPath.value).then(options => {
      options.forEach(path => this.uiPathList.appendChild(yo`<option>${path}</option>`));
    });
  }

  render() {
    this.onActivationInternal();
    this.testsOutput = yo`<div class="mx-3 mb-2 pb-4 border-top border-primary" hidden='true' id="solidityUnittestsOutput" data-id="testTabSolidityUnitTestsOutput"></a>`;
    this.testsExecutionStopped = yo`<label class="text-warning h6" data-id="testTabTestsExecutionStopped">The test execution has been stopped</label>`;
    this.testsExecutionStoppedError = yo`<label class="text-danger h6" data-id="testTabTestsExecutionStoppedError">The test execution has been stopped because of error(s) in your test file</label>`;
    this.uiPathList = yo`<datalist id="utPathList"></datalist>`;
    this.inputPath = yo`<input
      placeholder=${this.defaultPath}
      list="utPathList"
      class="custom-select"
      id="utPath"
      data-id="uiPathInput"
      name="utPath"
      style="background-image: var(--primary);"
      onkeydown=${e => {
      if (e.keyCode === 191) this.updateDirList();
    }}
      onchange=${e => this.updateCurrentPath(e)}/>`;
    const availablePaths = yo`
      <div>
          ${this.inputPath}
          ${this.uiPathList}
      </div>
    `;
    this.updateDirList();
    this.testsExecutionStopped.hidden = true;
    this.testsExecutionStoppedError.hidden = true;
    this.resultStatistics = this.createResultLabel();
    this.resultStatistics.hidden = true;
    const el = yo`
      <div class="${css.testTabView} px-2" id="testView">
        <div class="${css.infoBox}">
          <p class="text-lg"> Test your smart contract in Solidity.</p>
          <p> Select directory to load and generate test files.</p>
          <label>Test directory:</label>
          ${availablePaths}
        </div>
        <div class="${css.tests}">          
          <div class="d-flex p-2">
           ${this.updateGenerateFileAction()}
           ${this.infoButton()}
          </div>
          <div class="d-flex p-2">
            ${this.updateRunAction()}
            ${this.updateStopAction()}
          </div>
          ${this.selectAll()}
          ${this.updateTestFileList()}
          <div class="align-items-start flex-column mt-2 mx-3 mb-0">
            ${this.resultStatistics}
            ${this.testsExecutionStopped}
            ${this.testsExecutionStoppedError}
          </div>
          ${this.testsOutput}
        </div>
      </div>
    `;
    this._view.el = el;
    this.testTabLogic.setCurrentPath(this.defaultPath);
    this.updateForNewCurrent(this.fileManager.currentFile());
    return el;
  }

};

/***/ }),

/***/ "./app/tabs/testTab/testTab.js":
/*!*************************************!*\
  !*** ./app/tabs/testTab/testTab.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const helper = __webpack_require__(/*! ../../../lib/helper.js */ "./lib/helper.js");

const modalDialogCustom = __webpack_require__(/*! ../../ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

const remixPath = __webpack_require__(/*! path */ "../../../node_modules/path-browserify/index.js");

class TestTabLogic {
  constructor(fileManager) {
    this.fileManager = fileManager;
    this.currentPath = 'browser/tests';
  }

  setCurrentPath(path) {
    if (path.indexOf('/') === 0) return;
    this.currentPath = path;
    const fileProvider = this.fileManager.fileProviderOf(path.split('/')[0]);
    fileProvider.exists(path, (e, res) => {
      if (!res) fileProvider.createDir(path);
    });
  }

  generateTestFile() {
    let fileName = this.fileManager.currentFile();
    const hasCurrent = !!fileName && this.fileManager.currentFile().split('.').pop().toLowerCase() === 'sol';
    if (!hasCurrent) fileName = this.currentPath + '/newFile.sol';
    const fileProvider = this.fileManager.fileProviderOf(this.currentPath);
    if (!fileProvider) return;
    const splittedFileName = fileName.split('/');
    let fileNameToImport = !hasCurrent ? fileName : this.currentPath + '/' + splittedFileName[splittedFileName.length - 1];
    helper.createNonClashingNameWithPrefix(fileNameToImport, fileProvider, '_test', (error, newFile) => {
      if (error) return modalDialogCustom.alert('Failed to create file. ' + newFile + ' ' + error);
      if (!fileProvider.set(newFile, this.generateTestContractSample(hasCurrent, fileName))) return modalDialogCustom.alert('Failed to create test file ' + newFile);
      this.fileManager.open(newFile);
      this.fileManager.syncEditor(newFile);
    });
  }

  dirList(path) {
    return this.fileManager.dirList(path);
  }

  isRemixDActive() {
    return this.fileManager.isRemixDActive();
  }

  async getTests(cb) {
    if (!this.currentPath) return cb(null, []);
    const provider = this.fileManager.fileProviderOf(this.currentPath);
    if (!provider) return cb(null, []);
    const tests = [];
    let files;

    try {
      files = await this.fileManager.readdir(this.currentPath);
    } catch (e) {
      cb(e.message);
    }

    for (var file in files) {
      if (/.(_test.sol)$/.exec(file)) tests.push(provider.type + '/' + file);
    }

    cb(null, tests, this.currentPath);
  } // @todo(#2758): If currently selected file is compiled and compilation result is available,
  // 'contractName' should be <compiledContractName> + '_testSuite'


  generateTestContractSample(hasCurrent, fileToImport, contractName = 'testSuite') {
    let relative = remixPath.relative(this.currentPath, remixPath.dirname(fileToImport));
    if (relative === '') relative = '.';
    const comment = hasCurrent ? `import "${relative}/${remixPath.basename(fileToImport)}";` : '// Import here the file to test.';
    return `pragma solidity >=0.4.22 <0.7.0;
import "remix_tests.sol"; // this import is automatically injected by Remix.
${comment}

// File name has to end with '_test.sol', this file can contain more than one testSuite contracts
contract ${contractName} {

    /// 'beforeAll' runs before all other tests
    /// More special functions are: 'beforeEach', 'beforeAll', 'afterEach' & 'afterAll'
    function beforeAll() public {
        // Here should instantiate tested contract
        Assert.equal(uint(1), uint(1), "1 should be equal to 1");
    }

    function checkSuccess() public {
        // Use 'Assert' to test the contract, 
        // See documentation: https://remix-ide.readthedocs.io/en/latest/assert_library.html
        Assert.equal(uint(2), uint(2), "2 should be equal to 2");
        Assert.notEqual(uint(2), uint(3), "2 should not be equal to 3");
    }

    function checkSuccess2() public pure returns (bool) {
        // Use the return value (true or false) to test the contract
        return true;
    }
    
    function checkFailure() public {
        Assert.equal(uint(1), uint(2), "1 is not equal to 2");
    }
}
`;
  }

}

module.exports = TestTabLogic;

/***/ }),

/***/ "./app/tabs/theme-module.js":
/*!**********************************!*\
  !*** ./app/tabs/theme-module.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThemeModule = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var _events = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var _queryParams = _interopRequireDefault(__webpack_require__(/*! ../../lib/query-params */ "./lib/query-params.js"));

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

var _yoYo = _interopRequireDefault(__webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const themes = [{
  name: 'Dark',
  quality: 'dark',
  url: 'https://res.cloudinary.com/dvtmp0niu/raw/upload/v1584965247/remix-dark_tmkdla.css'
}, {
  name: 'Light',
  quality: 'light',
  url: 'https://res.cloudinary.com/remix/raw/upload/v1594059208/remix-themes/remix-light_csxus2.css'
}, {
  name: 'Cerulean',
  quality: 'light',
  url: 'https://bootswatch.com/4/cerulean/bootstrap.min.css'
}, {
  name: 'Flatly',
  quality: 'light',
  url: 'https://bootswatch.com/4/flatly/bootstrap.min.css'
}, {
  name: 'Lumen',
  quality: 'light',
  url: 'https://bootswatch.com/4/lumen/bootstrap.min.css'
}, {
  name: 'Minty',
  quality: 'light',
  url: 'https://bootswatch.com/4/minty/bootstrap.min.css'
}, {
  name: 'Pulse',
  quality: 'light',
  url: 'https://bootswatch.com/4/pulse/bootstrap.min.css'
}, {
  name: 'Sandstone',
  quality: 'light',
  url: 'https://bootswatch.com/4/sandstone/bootstrap.min.css'
}, {
  name: 'Spacelab',
  quality: 'light',
  url: 'https://bootswatch.com/4/spacelab/bootstrap.min.css'
}, {
  name: 'Yeti',
  quality: 'light',
  url: 'https://bootswatch.com/4/yeti/bootstrap.min.css'
}, {
  name: 'Cyborg',
  quality: 'dark',
  url: 'https://bootswatch.com/4/cyborg/bootstrap.min.css'
}, {
  name: 'Darkly',
  quality: 'dark',
  url: 'https://stackpath.bootstrapcdn.com/bootswatch/4.3.1/darkly/bootstrap.min.css'
}, {
  name: 'Superhero',
  quality: 'dark',
  url: 'https://stackpath.bootstrapcdn.com/bootswatch/4.3.1/superhero/bootstrap.min.css'
}];
const profile = {
  name: 'theme',
  events: ['themeChanged'],
  methods: ['switchTheme', 'getThemes', 'currentTheme'],
  version: packageJson.version,
  kind: 'theme'
};

class ThemeModule extends _engine.Plugin {
  constructor(registry) {
    super(profile);
    this.events = new _events.EventEmitter();
    this._deps = {
      config: registry.get('config').api
    };
    this.themes = themes.reduce((acc, theme) => ({ ...acc,
      [theme.name]: theme
    }), {});
    const theme = new _queryParams.default().get().theme;
    this.active = theme || this._deps.config.get('settings/theme') || 'Dark';
    this.forced = theme !== undefined;
  }
  /** Return the active theme */


  currentTheme() {
    return this.themes[this.active];
  }
  /** Returns all themes as an array */


  getThemes() {
    return Object.keys(this.themes).map(key => this.themes[key]);
  }
  /**
   * Init the theme
   */


  initTheme(callback) {
    if (this.active) {
      const nextTheme = this.themes[this.active]; // Theme

      document.documentElement.style.setProperty('--theme', nextTheme.quality);
      const theme = (0, _yoYo.default)`<link rel="stylesheet" href="${nextTheme.url}" id="theme-link"/>`;
      theme.addEventListener('load', () => {
        if (callback) callback();
      });
      document.head.insertBefore(theme, document.head.firstChild);
    }
  }
  /**
   * Change the current theme
   * @param {string} [themeName] - The name of the theme
   */


  switchTheme(themeName) {
    if (themeName && !Object.keys(this.themes).includes(themeName)) {
      throw new Error(`Theme ${themeName} doesn't exist`);
    }

    const next = themeName || this.active; // Name

    const nextTheme = this.themes[next]; // Theme

    if (!this.forced) this._deps.config.set('settings/theme', next);
    document.getElementById('theme-link').setAttribute('href', nextTheme.url);
    document.documentElement.style.setProperty('--theme', nextTheme.quality);
    if (themeName) this.active = themeName; // TODO: Only keep `this.emit` (issue#2210)

    this.emit('themeChanged', nextTheme);
    this.events.emit('themeChanged', nextTheme);
  }
  /**
   * fixes the invertion for images since this should be adjusted when we switch between dark/light qualified themes
   * @param {element} [image] - the dom element which invert should be fixed to increase visibility
   */


  fixInvert(image) {
    const invert = this.currentTheme().quality === 'dark' ? 1 : 0;

    if (image) {
      image.style.filter = `invert(${invert})`;
    }
  }

}

exports.ThemeModule = ThemeModule;

/***/ }),

/***/ "./app/tabs/web3-provider.js":
/*!***********************************!*\
  !*** ./app/tabs/web3-provider.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Web3ProviderModule = exports.profile = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const profile = {
  name: 'web3Provider',
  displayName: 'Global Web3 Provider',
  description: 'Represent the current web3 provider used by the app at global scope',
  methods: ['sendAsync'],
  version: packageJson.version,
  kind: 'provider'
};
exports.profile = profile;

class Web3ProviderModule extends _engine.Plugin {
  constructor(blockchain) {
    super(profile);
    this.blockchain = blockchain;
  }
  /*
    that is used by plugins to call the current ethereum provider.
    Should be taken carefully and probably not be release as it is now.
  */


  sendAsync(payload) {
    return new Promise((resolve, reject) => {
      this.blockchain.web3().currentProvider.sendAsync(payload, (error, message) => {
        if (error) return reject(error);
        resolve(message);
      });
    });
  }

}

exports.Web3ProviderModule = Web3ProviderModule;

/***/ }),

/***/ "./app/udapp/index.js":
/*!****************************!*\
  !*** ./app/udapp/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _runTab = __webpack_require__(/*! ./run-tab */ "./app/udapp/run-tab.js");

Object.keys(_runTab).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _runTab[key];
    }
  });
});

var _makeUdapp = __webpack_require__(/*! ./make-udapp */ "./app/udapp/make-udapp.js");

Object.keys(_makeUdapp).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _makeUdapp[key];
    }
  });
});

/***/ }),

/***/ "./app/udapp/make-udapp.js":
/*!*********************************!*\
  !*** ./app/udapp/make-udapp.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeUdapp = makeUdapp;

var registry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var EventsDecoder = remixLib.execution.EventsDecoder;

var TransactionReceiptResolver = __webpack_require__(/*! ../../lib/transactionReceiptResolver */ "./lib/transactionReceiptResolver.js");

const transactionDetailsLinks = {
  'Main': 'https://www.etherscan.io/tx/',
  'Rinkeby': 'https://rinkeby.etherscan.io/tx/',
  'Ropsten': 'https://ropsten.etherscan.io/tx/',
  'Kovan': 'https://kovan.etherscan.io/tx/',
  'Goerli': 'https://goerli.etherscan.io/tx/'
};

function txDetailsLink(network, hash) {
  if (transactionDetailsLinks[network]) {
    return transactionDetailsLinks[network] + hash;
  }
}

function makeUdapp(blockchain, compilersArtefacts, logHtmlCallback) {
  // ----------------- UniversalDApp -----------------
  // TODO: to remove when possible
  blockchain.event.register('transactionBroadcasted', (txhash, networkName) => {
    var txLink = txDetailsLink(networkName, txhash);
    if (txLink && logHtmlCallback) logHtmlCallback(yo`<a href="${txLink}" target="_blank">${txLink}</a>`);
  }); // ----------------- Tx listener -----------------

  const transactionReceiptResolver = new TransactionReceiptResolver(blockchain);
  const txlistener = blockchain.getTxListener({
    api: {
      contracts: function () {
        if (compilersArtefacts['__last']) return compilersArtefacts.getAllContractDatas();
        return null;
      },
      resolveReceipt: function (tx, cb) {
        transactionReceiptResolver.resolve(tx, cb);
      }
    }
  });
  registry.put({
    api: txlistener,
    name: 'txlistener'
  });
  blockchain.startListening(txlistener);
  const eventsDecoder = new EventsDecoder({
    api: {
      resolveReceipt: function (tx, cb) {
        transactionReceiptResolver.resolve(tx, cb);
      }
    }
  });
  txlistener.startListening();
  registry.put({
    api: eventsDecoder,
    name: 'eventsDecoder'
  });
}

/***/ }),

/***/ "./app/udapp/run-tab.js":
/*!******************************!*\
  !*** ./app/udapp/run-tab.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RunTab = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

const EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

const Card = __webpack_require__(/*! ../ui/card */ "./app/ui/card.js");

const css = __webpack_require__(/*! ../tabs/styles/run-tab-styles */ "./app/tabs/styles/run-tab-styles.js");

const SettingsUI = __webpack_require__(/*! ../tabs/runTab/settings.js */ "./app/tabs/runTab/settings.js");

const Recorder = __webpack_require__(/*! ../tabs/runTab/model/recorder.js */ "./app/tabs/runTab/model/recorder.js");

const RecorderUI = __webpack_require__(/*! ../tabs/runTab/recorder.js */ "./app/tabs/runTab/recorder.js");

const DropdownLogic = __webpack_require__(/*! ../tabs/runTab/model/dropdownlogic.js */ "./app/tabs/runTab/model/dropdownlogic.js");

const ContractDropdownUI = __webpack_require__(/*! ../tabs/runTab/contractDropdown.js */ "./app/tabs/runTab/contractDropdown.js");

const UniversalDAppUI = __webpack_require__(/*! ../ui/universal-dapp-ui */ "./app/ui/universal-dapp-ui.js");

const profile = {
  name: 'udapp',
  displayName: 'Deploy & run transactions',
  icon: 'assets/img/deployAndRun.webp',
  description: 'execute and save transactions',
  kind: 'udapp',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/run.html',
  version: packageJson.version,
  permission: true,
  events: ['newTransaction'],
  methods: ['createVMAccount', 'sendTransaction', 'getAccounts', 'pendingTransactionsCount']
};

class RunTab extends _engine.LibraryPlugin {
  constructor(blockchain, pluginUDapp, config, fileManager, editor, filePanel, compilersArtefacts, networkModule, mainView, fileProvider) {
    super(pluginUDapp, profile);
    this.event = new EventManager();
    this.config = config;
    this.blockchain = blockchain;
    this.fileManager = fileManager;
    this.editor = editor;

    this.logCallback = msg => {
      mainView.getTerminal().logHtml(msg);
    };

    this.filePanel = filePanel;
    this.compilersArtefacts = compilersArtefacts;
    this.networkModule = networkModule;
    this.fileProvider = fileProvider;
  }

  renderContainer() {
    this.container = yo`<div class="${css.runTabView} run-tab" id="runTabView" data-id="runTabView"></div>`;
    var el = yo`
    <div class="list-group list-group-flush">
      ${this.settingsUI.render()}
      ${this.contractDropdownUI.render()}
      ${this.recorderCard.render()}
      ${this.instanceContainer}
    </div>
    `;
    this.container.appendChild(el);
    return this.container;
  }

  renderInstanceContainer() {
    this.instanceContainer = yo`<div class="${css.instanceContainer} border-0 list-group-item"></div>`;
    const instanceContainerTitle = yo`
      <div class="d-flex justify-content-between align-items-center pl-2 ml-1 mb-2"
        title="Autogenerated generic user interfaces for interaction with deployed contracts">
        Deployed Contracts
        <i class="mr-2 ${css.icon} far fa-trash-alt" data-id="deployAndRunClearInstances" onclick=${() => this.event.trigger('clearInstance', [])}
          title="Clear instances list and reset recorder" aria-hidden="true">
        </i>
      </div>`;
    this.noInstancesText = yo`
      <span class="mx-2 mt-3 alert alert-warning" data-id="deployAndRunNoInstanceText" role="alert">
        Currently you have no contract instances to interact with.
      </span>`;
    this.event.register('clearInstance', () => {
      this.instanceContainer.innerHTML = ''; // clear the instances list

      this.instanceContainer.appendChild(instanceContainerTitle);
      this.instanceContainer.appendChild(this.noInstancesText);
    });
    this.instanceContainer.appendChild(instanceContainerTitle);
    this.instanceContainer.appendChild(this.noInstancesText);
  }

  renderSettings() {
    this.settingsUI = new SettingsUI(this.blockchain, this.networkModule);
    this.settingsUI.event.register('clearInstance', () => {
      this.event.trigger('clearInstance', []);
    });
  }

  renderDropdown(udappUI, fileManager, compilersArtefacts, config, editor, logCallback) {
    const dropdownLogic = new DropdownLogic(compilersArtefacts, config, editor, this);
    this.contractDropdownUI = new ContractDropdownUI(this.blockchain, dropdownLogic, logCallback, this);
    fileManager.events.on('currentFileChanged', this.contractDropdownUI.changeCurrentFile.bind(this.contractDropdownUI));
    this.contractDropdownUI.event.register('clearInstance', () => {
      const noInstancesText = this.noInstancesText;

      if (noInstancesText.parentNode) {
        noInstancesText.parentNode.removeChild(noInstancesText);
      }
    });
    this.contractDropdownUI.event.register('newContractABIAdded', (abi, address) => {
      this.instanceContainer.appendChild(udappUI.renderInstanceFromABI(abi, address, '<at address>'));
    });
    this.contractDropdownUI.event.register('newContractInstanceAdded', (contractObject, address, value) => {
      this.instanceContainer.appendChild(udappUI.renderInstance(contractObject, address, value));
    });
  }

  renderRecorder(udappUI, fileManager, config, logCallback) {
    this.recorderCount = yo`<span>0</span>`;
    const recorder = new Recorder(this.blockchain, fileManager, config);
    recorder.event.register('recorderCountChange', count => {
      this.recorderCount.innerText = count;
    });
    this.event.register('clearInstance', recorder.clearAll.bind(recorder));
    this.recorderInterface = new RecorderUI(this.blockchain, recorder, logCallback, config);
    this.recorderInterface.event.register('newScenario', (abi, address, contractName) => {
      var noInstancesText = this.noInstancesText;

      if (noInstancesText.parentNode) {
        noInstancesText.parentNode.removeChild(noInstancesText);
      }

      this.instanceContainer.appendChild(udappUI.renderInstanceFromABI(abi, address, contractName));
    });
    this.recorderInterface.render();
  }

  renderRecorderCard() {
    const collapsedView = yo`
      <div class="d-flex flex-column">
        <div class="ml-2 badge badge-pill badge-primary" title="The number of recorded transactions">${this.recorderCount}</div>
      </div>`;
    const expandedView = yo`
      <div class="d-flex flex-column">
        <div class="${css.recorderDescription} mt-2">
          All transactions (deployed contracts and function executions) in this environment can be saved and replayed in
          another environment. e.g Transactions created in Javascript VM can be replayed in the Injected Web3.
        </div>
        <div class="${css.transactionActions}">
          ${this.recorderInterface.recordButton}
          ${this.recorderInterface.runButton}
          </div>
        </div>
      </div>`;
    this.recorderCard = new Card({}, {}, {
      title: 'Transactions recorded',
      collapsedView: collapsedView
    });
    this.recorderCard.event.register('expandCollapseCard', (arrow, body, status) => {
      body.innerHTML = '';
      status.innerHTML = '';

      if (arrow === 'down') {
        status.appendChild(collapsedView);
        body.appendChild(expandedView);
      } else if (arrow === 'up') {
        status.appendChild(collapsedView);
      }
    });
  }

  render() {
    this.udappUI = new UniversalDAppUI(this.blockchain, this.logCallback);
    this.blockchain.resetAndInit(this.config, {
      getAddress: cb => {
        cb(null, $('#txorigin').val());
      },
      getValue: cb => {
        try {
          const number = document.querySelector('#value').value;
          const select = document.getElementById('unit');
          const index = select.selectedIndex;
          const selectedUnit = select.querySelectorAll('option')[index].dataset.unit;
          let unit = 'ether'; // default

          if (['ether', 'finney', 'gwei', 'wei'].indexOf(selectedUnit) >= 0) {
            unit = selectedUnit;
          }

          cb(null, Web3.utils.toWei(number, unit));
        } catch (e) {
          cb(e);
        }
      },
      getGasLimit: cb => {
        try {
          cb(null, '0x' + new ethJSUtil.BN($('#gasLimit').val(), 10).toString(16));
        } catch (e) {
          cb(e.message);
        }
      }
    });
    this.renderInstanceContainer();
    this.renderSettings();
    this.renderDropdown(this.udappUI, this.fileManager, this.compilersArtefacts, this.config, this.editor, this.logCallback);
    this.renderRecorder(this.udappUI, this.fileManager, this.config, this.logCallback);
    this.renderRecorderCard();
    return this.renderContainer();
  }

}

exports.RunTab = RunTab;

/***/ }),

/***/ "./app/ui/TreeView.js":
/*!****************************!*\
  !*** ./app/ui/TreeView.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .li_tv {
    list-style-type: none;
    -webkit-margin-before: 0px;
    -webkit-margin-after: 0px;
    -webkit-margin-start: 0px;
    -webkit-margin-end: 0px;
    -webkit-padding-start: 0px;
  }
  .ul_tv {
    list-style-type: none;
    -webkit-margin-before: 0px;
    -webkit-margin-after: 0px;
    -webkit-margin-start: 0px;
    -webkit-margin-end: 0px;
    -webkit-padding-start: 0px;
  }
  .caret_tv {
    width: 10px;
    flex-shrink: 0;
    padding-right: 5px;
  }
  .label_item {
    word-break: break-all;
  }
  .label_key {
    min-width: 15%;
    max-width: 80%;
    word-break: break-word;
  }
  .label_value {
    min-width: 10%;
  }
`;

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");
/**
 * TreeView
 *  - extendable by specifying custom `extractData` and `formatSelf` function
 *  - trigger `nodeClick` and `leafClick`
 */


class TreeView {
  constructor(opts) {
    this.event = new EventManager();
    this.extractData = opts.extractData || this.extractDataDefault;
    this.formatSelf = opts.formatSelf || this.formatSelfDefault;
    this.view = null;
    this.expandPath = [];
  }

  render(json, expand) {
    var view = this.renderProperties(json, expand);

    if (!this.view) {
      this.view = view;
    }

    return view;
  }

  update(json) {
    if (this.view) {
      yo.update(this.view, this.render(json));
    }
  }

  renderObject(item, parent, key, expand, keyPath) {
    var data = this.extractData(item, parent, key);
    var children = (data.children || []).map((child, index) => {
      return this.renderObject(child.value, data, child.key, expand, keyPath + '/' + child.key);
    });
    return this.formatData(key, data, children, expand, keyPath);
  }

  renderProperties(json, expand, key) {
    key = key || '';
    var children = Object.keys(json).map(innerkey => {
      return this.renderObject(json[innerkey], json, innerkey, expand, innerkey);
    });
    return yo`<ul key=${key} data-id="treeViewUl${key}" class="${css.ul_tv} ml-0 px-2">${children}</ul>`;
  }

  formatData(key, data, children, expand, keyPath) {
    var self = this;
    var li = yo`<li key=${keyPath} data-id="treeViewLi${keyPath}" class=${css.li_tv}></li>`;
    var caret = yo`<div class="px-1 fas fa-caret-right caret ${css.caret_tv}"></div>`;
    var label = yo`
      <div key=${keyPath} data-id="treeViewDiv${keyPath}" class="d-flex flex-row align-items-center">
        ${caret}
        <span class="w-100">${self.formatSelf(key, data, li)}</span>
      </div>`;
    const expanded = self.expandPath.includes(keyPath);
    li.appendChild(label);

    if (data.children) {
      var list = yo`<ul key=${keyPath} data-id="treeViewUlList${keyPath}" class="pl-2 ${css.ul_tv}">${children}</ul>`;
      list.style.display = expanded ? 'block' : 'none';
      caret.className = list.style.display === 'none' ? `fas fa-caret-right caret ${css.caret_tv}` : `fas fa-caret-down caret ${css.caret_tv}`;
      caret.setAttribute('data-id', `treeViewToggle${keyPath}`);

      label.onclick = function () {
        self.expand(keyPath);

        if (self.isExpanded(keyPath)) {
          if (!self.expandPath.includes(keyPath)) self.expandPath.push(keyPath);
        } else {
          self.expandPath = self.expandPath.filter(path => !path.startsWith(keyPath));
        }
      };

      label.oncontextmenu = function (event) {
        self.event.trigger('nodeRightClick', [keyPath, data, label, event]);
      };

      li.appendChild(list);
    } else {
      caret.style.visibility = 'hidden';

      label.oncontextmenu = function (event) {
        self.event.trigger('leafRightClick', [keyPath, data, label, event]);
      };

      label.onclick = function (event) {
        self.event.trigger('leafClick', [keyPath, data, label, event]);
      };
    }

    return li;
  }

  isExpanded(path) {
    var current = this.nodeAt(path);

    if (current) {
      return current.style.display !== 'none';
    }

    return false;
  }

  expand(path) {
    var caret = this.caretAt(path);
    var node = this.nodeAt(path);

    if (node) {
      node.style.display = node.style.display === 'none' ? 'block' : 'none';
      caret.className = node.style.display === 'none' ? `fas fa-caret-right caret ${css.caret_tv}` : `fas fa-caret-down caret ${css.caret_tv}`;
      this.event.trigger('nodeClick', [path, node]);
    }
  }

  caretAt(path) {
    var label = this.labelAt(path);

    if (label) {
      return label.querySelector('.caret');
    }
  }

  itemAt(path) {
    return this.view.querySelector(`li[key="${path}"]`);
  }

  labelAt(path) {
    return this.view.querySelector(`div[key="${path}"]`);
  }

  nodeAt(path) {
    return this.view.querySelector(`ul[key="${path}"]`);
  }

  updateNodeFromJSON(path, jsonTree, expand) {
    var newTree = this.renderProperties(jsonTree, expand, path);
    var current = this.nodeAt(path);

    if (current && current.parentElement) {
      current.parentElement.replaceChild(newTree, current);
    }
  }

  formatSelfDefault(key, data) {
    return yo`
      <div class="d-flex mb-1 flex-row ${css.label_item}">
        <label class="small font-weight-bold pr-1 ${css.label_key}">${key}:</label> 
        <label class="m-0 ${css.label_value}">${data.self}</label>
      </div>
    `;
  }

  extractDataDefault(item, parent, key) {
    var ret = {};

    if (item instanceof Array) {
      ret.children = item.map((item, index) => {
        return {
          key: index,
          value: item
        };
      });
      ret.self = 'Array';
      ret.isNode = true;
      ret.isLeaf = false;
    } else if (item instanceof Object) {
      ret.children = Object.keys(item).map(key => {
        return {
          key: key,
          value: item[key]
        };
      });
      ret.self = 'Object';
      ret.isNode = true;
      ret.isLeaf = false;
    } else {
      ret.self = item;
      ret.children = null;
      ret.isNode = false;
      ret.isLeaf = true;
    }

    return ret;
  }

}

module.exports = TreeView;

/***/ }),

/***/ "./app/ui/auto-complete-popup.js":
/*!***************************************!*\
  !*** ./app/ui/auto-complete-popup.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var EventManager = remixLib.EventManager;

var Commands = __webpack_require__(/*! ../../lib/commands */ "./lib/commands.js"); // -------------- styling ----------------------


var css = __webpack_require__(/*! ./styles/auto-complete-popup-styles */ "./app/ui/styles/auto-complete-popup-styles.js");
/* USAGE:

  var autoCompletePopup = new AutoCompletePopup({
    options: []
  })
  autoCompletePopup.event.register('handleSelect', function (input) { })
  autoCompletePopup.event.register('updateList', function () { })

*/


class AutoCompletePopup {
  constructor(opts = {}) {
    var self = this;
    self.event = new EventManager();
    self.isOpen = false;
    self.opts = opts;
    self.data = {
      _options: []
    };
    self._components = {};
    self._view;
    self._startingElement = 0;
    self._elementsToShow = 4;
    self._selectedElement = 0;
    this.extraCommands = [];
    this.extendAutocompletion();
  }

  render() {
    var self = this;
    let autoComplete = yo`
      <div class="${css.popup} alert alert-secondary">
        <div>
          ${self.data._options.map((item, index) => {
      return yo`
              <div data-id="autoCompletePopUpAutoCompleteItem" class="${css.autoCompleteItem} ${css.listHandlerHide} item ${self._selectedElement === index ? 'border border-primary' : ''}">
                  <div value=${index} onclick=${event => {
        self.handleSelect(event.srcElement.innerText);
      }}>
                    ${getKeyOf(item)} 
                  </div>
                  <div>
                    ${getValueOf(item)}
                  </div>
              </div>
            `;
    })}
        </div>
        <div class="${css.listHandlerHide}">
          <div class="${css.pageNumberAlignment}">Page ${self._startingElement / self._elementsToShow + 1} of ${Math.ceil(self.data._options.length / self._elementsToShow)}</div>
        </div>
      </div>
    `;

    function setUpPopUp(autoComplete) {
      handleOpenPopup(autoComplete);
      handleListSize(autoComplete);
    }

    function handleOpenPopup(autoComplete) {
      autoComplete.style.display = self.data._options.length > 0 ? 'block' : 'none';
    }

    function handleListSize(autoComplete) {
      if (self.data._options.length >= self._startingElement) {
        for (let i = self._startingElement; i < self._elementsToShow + self._startingElement; i++) {
          let el = autoComplete.querySelectorAll('.item')[i];

          if (el) {
            el.classList.remove(css.listHandlerHide);
            el.classList.add(css.listHandlerShow);
          }
        }
      }
    }

    setUpPopUp(autoComplete);
    if (!this._view) this._view = autoComplete;
    return autoComplete;
  }

  handleSelect(text) {
    this.removeAutoComplete();
    this.event.trigger('handleSelect', [text]);
  }

  moveUp() {
    if (this._selectedElement === 0) return;
    this._selectedElement--;
    this._startingElement = this._selectedElement > 0 ? this._selectedElement - 1 : 0;
    this.event.trigger('updateList');
    yo.update(this._view, this.render());
  }

  moveDown() {
    if (this.data._options.length <= this._selectedElement + 1) return;
    this._selectedElement++;
    this._startingElement = this._selectedElement - 1;
    this.event.trigger('updateList');
    yo.update(this._view, this.render());
  }

  handleAutoComplete(event, inputString) {
    if (this.isOpen && (event.which === 27 || event.which === 8 || event.which === 46)) {
      // backspace or any key that should remove the autocompletion
      this.removeAutoComplete();
      return true;
    }

    if (this.isOpen && (event.which === 13 || event.which === 9)) {
      // enter and tab (validate completion)
      event.preventDefault();

      if (this.data._options[this._selectedElement]) {
        this.handleSelect(getKeyOf(this.data._options[this._selectedElement]));
      }

      this.removeAutoComplete();
      return true;
    }

    if (this.isOpen && event.which === 38) {
      // move up
      event.preventDefault();
      this.isOpen = true;
      this.moveUp();
      return true;
    }

    if (this.isOpen && event.which === 40) {
      // move down
      event.preventDefault();
      this.isOpen = true;
      this.moveDown();
      return true;
    }

    if (event.which === 13 || event.which === 9) {
      // enter || tab and autocompletion is off, just returning false
      return false;
    }

    let textList = inputString.split(' ');
    let autoCompleteInput = textList.length > 1 ? textList[textList.length - 1] : textList[0];

    if (inputString.length >= 2) {
      // more than 2 letters, start completion
      this.data._options = [];
      Commands.allPrograms.forEach(item => {
        const program = getKeyOf(item);

        if (program.substring(0, program.length - 1).includes(autoCompleteInput.trim())) {
          this.data._options.push(item);
        } else if (autoCompleteInput.trim().includes(program) || program === autoCompleteInput.trim()) {
          Commands.allCommands.forEach(item => {
            const command = getKeyOf(item);

            if (command.includes(autoCompleteInput.trim())) {
              this.data._options.push(item);
            }
          });
        }
      });
      this.extraCommands.forEach(item => {
        const command = getKeyOf(item);

        if (command.includes(autoCompleteInput.trim())) {
          this.data._options.push(item);
        }
      });

      if (this.data._options.length === 1 && event.which === 9) {
        // if only one option and tab is pressed, we resolve it
        event.preventDefault();
        textList.pop();
        textList.push(getKeyOf(this.data._options[0]));
        this.handleSelect(`${textList}`.replace(/,/g, ' '));
        this.removeAutoComplete();
        return;
      }

      if (this.data._options.length) this.isOpen = true;
      yo.update(this._view, this.render());
      return true;
    }

    return false;
  }

  removeAutoComplete() {
    if (!this.isOpen) return;
    this._view.style.display = 'none';
    this.isOpen = false;
    this.data._options = [];
    this._startingElement = 0;
    this._selectedElement = 0;
    yo.update(this._view, this.render());
  }

  extendAutocompletion() {
    // TODO: this is not using the appManager interface. Terminal should be put as module
    this.opts.appManager.event.on('activate', async profile => {
      if (!profile.methods) return;
      profile.methods.forEach(method => {
        const key = `remix.call({name: '${profile.name}', key:'${method}', payload: []}).then((result) => { console.log(result) }).catch((error) => { console.log(error) })`;
        const keyValue = {};
        keyValue[key] = `call ${profile.name} - ${method}`;
        if (this.extraCommands.includes(keyValue)) return;
        this.extraCommands.push(keyValue);
      });
    });
  }

}

function getKeyOf(item) {
  return Object.keys(item)[0];
}

function getValueOf(item) {
  return Object.values(item)[0];
}

module.exports = AutoCompletePopup;

/***/ }),

/***/ "./app/ui/card.js":
/*!************************!*\
  !*** ./app/ui/card.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

module.exports = class Card {
  constructor(api, events, opts) {
    const self = this;
    self._api = api;
    self._events = events;
    self._opts = opts;
    self._view = {};
    self.event = new EventManager();
  }

  render() {
    const self = this;
    if (self._view.el) return self._view.el;
    self._view.cardBody = yo`<div></div>`;
    self._view.arrow = yo`<i class="${css.arrow} fas fa-angle-down" onclick="${() => trigger(this)}"></i>`;
    self._view.expandCollapseButton = yo`
    <div>${self._view.arrow}</div>`;
    self._view.statusBar = yo`<div>${self._opts.collapsedView}</div>`;
    self._view.cardHeader = yo`
    <div class="d-flex justify-content-between align-items-center" onclick=${() => trigger(self._view.arrow)}>
      <div class="pr-1 d-flex flex-row">
        <div>${self._opts.title}</div>
        ${self._view.statusBar}
      </div>
      <div>${self._view.expandCollapseButton}</div>
    </div>`;

    function trigger(el) {
      var body = self._view.cardBody;
      var status = self._view.statusBar;

      if (el.classList) {
        el.classList.toggle('fa-angle-up');
        var arrow = el.classList.toggle('fa-angle-down') ? 'up' : 'down';
        self.event.trigger('expandCollapseCard', [arrow, body, status]);
      }
    } // HTML


    self._view.el = yo`
      <div class="${css.cardContainer} list-group-item border-0">
        ${self._view.cardHeader}
        ${self._view.cardBody}
      </div>`;
    return self._view.el;
  }

};
const css = csjs`
  .cardContainer {
    padding             : 0 24px 16px;
    margin              : 0;
    background          : none;
  }
  .arrow {
    font-weight         : bold;
    cursor              : pointer;
    font-size           : 14px;
  }
  .arrow:hover {
  }

`;

/***/ }),

/***/ "./app/ui/confirmDialog.js":
/*!*********************************!*\
  !*** ./app/ui/confirmDialog.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const copyToClipboard = __webpack_require__(/*! ./copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

var css = csjs`
  .txInfoBox {
  }
  .wrapword {
    white-space: pre-wrap;       /* Since CSS 2.1 */
    white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
    white-space: -pre-wrap;      /* Opera 4-6 */
    white-space: -o-pre-wrap;    /* Opera 7 */
    word-wrap: break-word;       /* Internet Explorer 5.5+ */
  }
`; // TODO: self is not actually used and can be removed

function confirmDialog(tx, amount, gasEstimation, self, newGasPriceCb, initialParamsCb) {
  var onGasPriceChange = function () {
    var gasPrice = el.querySelector('#gasprice').value;
    newGasPriceCb(gasPrice, (txFeeText, priceStatus) => {
      el.querySelector('#txfee').innerHTML = txFeeText;
      el.gasPriceStatus = priceStatus;
    });
  };

  var el = yo`
  <div>
    <div>You are creating a transaction on the main network. Click confirm if you are sure to continue.</div>
    <div class=${css.txInfoBox}>
      <div>From: ${tx.from}</div>
      <div>To: ${tx.to ? tx.to : '(Contract Creation)'}</div>
      <div>Amount: ${amount} Ether</div>
      <div>Gas estimation: ${gasEstimation}</div>
      <div>Gas limit: ${tx.gas}</div>
      <div>Gas price: <input id='gasprice' oninput=${onGasPriceChange} /> Gwei <span> (visit <a target='_blank' href='https://ethgasstation.info'>ethgasstation.info</a> to get more info about gas price)</span></div>
      <div>Max transaction fee:<span id='txfee'></span></div>
      <div>Data:</div>
      <pre class=${css.wrapword}>${tx.data && tx.data.length > 50 ? tx.data.substring(0, 49) + '...' : tx.data} ${copyToClipboard(() => {
    return tx.data;
  })}</pre>
    </div>
    <div class=${css.checkbox}>
      <input id='confirmsetting' type="checkbox">
      <i class="fas fa-exclamation-triangle" aria-hidden="true"></i> Do not ask for confirmation again. (the setting will not be persisted for the next page reload)
    </div>
  </div>
  `;
  initialParamsCb((txFeeText, gasPriceValue, gasPriceStatus) => {
    if (txFeeText) {
      el.querySelector('#txfee').innerHTML = txFeeText;
    }

    if (gasPriceValue) {
      el.querySelector('#gasprice').value = gasPriceValue;
      onGasPriceChange();
    }

    if (gasPriceStatus !== undefined) {
      el.gasPriceStatus = gasPriceStatus;
    }
  });
  return el;
}

module.exports = confirmDialog;

/***/ }),

/***/ "./app/ui/contextMenu.js":
/*!*******************************!*\
  !*** ./app/ui/contextMenu.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js"); // -------------- copyToClipboard ----------------------


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
    .container
    {
      display: none;
      position: fixed;
      border-radius: 2px;
      z-index: 1000;
      box-shadow: 0 0 4px var(--dark);
    }
    .liitem
    {
      padding: 2px;
      padding-left: 6px;
      cursor: pointer;
      color: var(--text-dark);
      background-color: var(--light);
    }
    .liitem:hover
    {
      background-color:  var(--secondary);
    }
    #menuitems
    {
      list-style: none;
      margin: 0px;
    }
`;

module.exports = (event, items) => {
  event.preventDefault();

  function hide(event, force) {
    if (container && container.parentElement && (force || event.target !== container)) {
      container.parentElement.removeChild(container);
    }

    window.removeEventListener('click', hide);
  }

  const menu = Object.keys(items).map((item, index) => {
    const current = yo`<li id="menuitem${item.toLowerCase()}" class=${css.liitem}>${item}</li>`;

    current.onclick = () => {
      hide(null, true);
      items[item]();
    };

    return current;
  });
  const container = yo`<div id="menuItemsContainer" class="p-1 ${css.container} bg-light shadow border"><ul id='menuitems'>${menu}</ul></div>`;
  container.style.left = event.pageX + 'px';
  container.style.top = event.pageY + 'px';
  container.style.display = 'block';
  document.querySelector('body').appendChild(container);
  const menuItemsContainer = document.getElementById('menuItemsContainer');
  const boundary = menuItemsContainer.getBoundingClientRect();

  if (boundary.bottom > (window.innerHeight || document.documentElement.clientHeight)) {
    menuItemsContainer.style.position = 'absolute';
    menuItemsContainer.style.bottom = '10px';
    menuItemsContainer.style.top = null;
  }

  setTimeout(() => {
    window.addEventListener('click', hide);
  }, 500);
  return {
    hide
  };
};

/***/ }),

/***/ "./app/ui/copy-to-clipboard.js":
/*!*************************************!*\
  !*** ./app/ui/copy-to-clipboard.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js"); // -------------- copyToClipboard ----------------------


const copy = __webpack_require__(/*! copy-text-to-clipboard */ "../../../node_modules/copy-text-to-clipboard/index.js");

var addTooltip = __webpack_require__(/*! ./tooltip */ "./app/ui/tooltip.js"); // -------------- styling ----------------------


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .copyIcon {
    margin-left: 5px;
    cursor: pointer;
  }
`;

module.exports = function copyToClipboard(getContent, tip = 'Copy value to clipboard', icon = 'fa-copy') {
  var copyIcon = yo`<i title="${tip}" class="${css.copyIcon} far ${icon} p-2" data-id="copyToClipboardCopyIcon" aria-hidden="true"></i>`;

  copyIcon.onclick = event => {
    event.stopPropagation();
    var copiableContent;

    try {
      copiableContent = getContent();
    } catch (e) {
      addTooltip(e.message);
      return;
    }

    if (copiableContent) {
      // module `copy` keeps last copied thing in the memory, so don't show tooltip if nothing is copied, because nothing was added to memory
      try {
        if (typeof copiableContent !== 'string') {
          copiableContent = JSON.stringify(copiableContent, null, '\t');
        }
      } catch (e) {}

      copy(copiableContent);
      addTooltip('Copied value to clipboard.');
    } else {
      addTooltip('Cannot copy empty content!');
    }
  };

  return copyIcon;
};

/***/ }),

/***/ "./app/ui/landing-page/landing-page.js":
/*!*********************************************!*\
  !*** ./app/ui/landing-page/landing-page.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LandingPage = void 0;

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../../../package.json */ "../../../package.json"));

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

let csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

let globalRegistry = __webpack_require__(/*! ../../../global/registry */ "./global/registry.js");

let CompilerImport = __webpack_require__(/*! ../../compiler/compiler-imports */ "./app/compiler/compiler-imports.js");

var modalDialogCustom = __webpack_require__(/*! ../modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var tooltip = __webpack_require__(/*! ../tooltip */ "./app/ui/tooltip.js");

var GistHandler = __webpack_require__(/*! ../../../lib/gist-handler */ "./lib/gist-handler.js");

var QueryParams = __webpack_require__(/*! ../../../lib/query-params.js */ "./lib/query-params.js");

let css = csjs`
  .text {
    cursor: pointer;
    font-weight: normal;
    max-width: 300px;
    user-select: none;
  }
  .text:hover {
    text-decoration: underline;
  }
  .homeContainer {
    user-select:none;
  }
  .thisJumboton {
    padding: 2.5rem 0rem;
    margin-bottom: 4rem;
    display: flex;
    align-items: center;
  }
  .hpLogoContainer {
    margin:30px;
    padding-right: 90px;
  }
  .jumboBtnContainer {
  }
  .headlineContainer {
    margin: 0 50px 0 70px;
  }
  .hpSections {
    min-width: 640px;
  }
  .labelIt {
    margin-bottom: 0;
  }
  .seeAll {
    margin-top: 7px;
    white-space: nowrap;
  }
  .importFrom p {
    margin-right: 10px;
  }
  .logoContainer {
    float: left;
  }
  .logoContainer img{
    height: 150px;
    opacity: 0.7;
  }
  .enviroments {
    display: flex;
  }
  .envLogo {
    height: 16px;
  }
  .envLabel {
    cursor: pointer;
  }
  .envButton {
    width: 120px;
    height: 70px;
  }
}
`;
const profile = {
  name: 'home',
  displayName: 'Home',
  methods: [],
  events: [],
  description: ' - ',
  icon: 'assets/img/remixLogo.webp',
  location: 'mainPanel',
  version: packageJson.version
};

class LandingPage extends _engine.ViewPlugin {
  constructor(appManager, verticalIcons) {
    super(profile);
    this.profile = profile;
    this.appManager = appManager;
    this.verticalIcons = verticalIcons;
    this.gistHandler = new GistHandler();
  }

  render() {
    let load = (service, item, examples, info) => {
      let compilerImport = new CompilerImport();
      let fileProviders = globalRegistry.get('fileproviders').api;
      const msg = yo`
        <div class="p-2">
          <span>Enter the ${item} you would like to load.</span>
          <div>${info}</div>
          <div>e.g ${examples.map(url => {
        return yo`<div class="p-1"><a>${url}</a></div>`;
      })}</div>
        </div>`;
      modalDialogCustom.prompt(`Import from ${service}`, msg, null, target => {
        if (target !== '') {
          compilerImport.import(target, loadingMsg => {
            tooltip(loadingMsg);
          }, (error, content, cleanUrl, type, url) => {
            if (error) {
              modalDialogCustom.alert(error);
            } else {
              fileProviders['browser'].addExternal(type + '/' + cleanUrl, content, url);
              this.verticalIcons.select('fileExplorers');
            }
          });
        }
      });
    };

    const learnMore = () => {
      window.open('https://remix-ide.readthedocs.io/en/latest/layout.html', '_blank');
    };

    const startSolidity = () => {
      this.appManager.ensureActivated('solidity');
      this.appManager.ensureActivated('udapp');
      this.appManager.ensureActivated('solidityStaticAnalysis');
      this.appManager.ensureActivated('solidityUnitTesting');
      this.verticalIcons.select('solidity');
    };

    const startVyper = () => {
      this.appManager.ensureActivated('vyper');
      this.appManager.ensureActivated('udapp');
      this.verticalIcons.select('vyper');
    };
    /*
    const startWorkshop = () => {
      this.appManager.ensureActivated('box')
      this.appManager.ensureActivated('solidity')
      this.appManager.ensureActivated('solidityUnitTesting')
      this.appManager.ensureActivated('workshops')
      this.verticalIcons.select('workshops')
    }
    */


    const startPipeline = () => {
      this.appManager.ensureActivated('solidity');
      this.appManager.ensureActivated('pipeline');
      this.appManager.ensureActivated('udapp');
    };

    const startDebugger = () => {
      this.appManager.ensureActivated('debugger');
      this.verticalIcons.select('debugger');
    };

    const startMythX = () => {
      this.appManager.ensureActivated('solidity');
      this.appManager.ensureActivated('mythx');
      this.verticalIcons.select('mythx');
    };

    const startSourceVerify = () => {
      this.appManager.ensureActivated('solidity');
      this.appManager.ensureActivated('source-verification');
      this.verticalIcons.select('source-verification');
    };

    const startPluginManager = () => {
      this.appManager.ensureActivated('pluginManager');
      this.verticalIcons.select('pluginManager');
    };

    const createNewFile = () => {
      let fileExplorer = globalRegistry.get('fileexplorer/browser').api;
      fileExplorer.createNewFile();
    };

    const connectToLocalhost = () => {
      this.appManager.ensureActivated('remixd');
    };

    const importFromGist = () => {
      this.gistHandler.loadFromGist({
        gist: ''
      }, globalRegistry.get('filemanager').api);
      this.verticalIcons.select('fileExplorers');
    };

    globalRegistry.get('themeModule').api.events.on('themeChanged', () => {
      globalRegistry.get('themeModule').api.fixInvert(document.getElementById('remixLogo'));
      globalRegistry.get('themeModule').api.fixInvert(document.getElementById('solidityLogo'));
      globalRegistry.get('themeModule').api.fixInvert(document.getElementById('vyperLogo'));
      globalRegistry.get('themeModule').api.fixInvert(document.getElementById('pipelineLogo'));
      globalRegistry.get('themeModule').api.fixInvert(document.getElementById('debuggerLogo'));
      globalRegistry.get('themeModule').api.fixInvert(document.getElementById('workshopLogo'));
      globalRegistry.get('themeModule').api.fixInvert(document.getElementById('moreLogo'));
    });

    const createEnvButton = (imgPath, envID, envText, callback) => {
      return yo`
        <button class="btn border-secondary d-flex mr-3 text-nowrap justify-content-center flex-column align-items-center ${css.envButton}" data-id="landingPageStartSolidity" onclick=${() => callback()}>
          <img class="m-2 align-self-center ${css.envLogo}" id=${envID} src="${imgPath}">
          <label class="text-uppercase text-dark ${css.envLabel}">${envText}</label>
        </button>
      `;
    }; // main


    const solEnv = createEnvButton('assets/img/solidityLogo.webp', 'solidityLogo', 'Solidity', startSolidity);
    const vyperEnv = createEnvButton('assets/img/vyperLogo.webp', 'vyperLogo', 'Vyper', startVyper); // Featured

    const pipelineEnv = createEnvButton('assets/img/pipelineLogo.webp', 'pipelineLogo', 'Pipeline', startPipeline);
    const debuggerEnv = createEnvButton('assets/img/debuggerLogo.webp', 'debuggerLogo', 'Debugger', startDebugger);
    const mythXEnv = createEnvButton('assets/img/mythxLogo.webp', 'mythxLogo', 'MythX', startMythX);
    const sourceVerifyEnv = createEnvButton('assets/img/sourceVerifyLogo.webp', 'sourceVerifyLogo', 'Sourcify', startSourceVerify);
    const moreEnv = createEnvButton('assets/img/moreLogo.webp', 'moreLogo', 'More', startPluginManager);
    const invertNum = globalRegistry.get('themeModule').api.currentTheme().quality === 'dark' ? 1 : 0;
    solEnv.getElementsByTagName('img')[0].style.filter = `invert(${invertNum})`;
    vyperEnv.getElementsByTagName('img')[0].style.filter = `invert(${invertNum})`;
    pipelineEnv.getElementsByTagName('img')[0].style.filter = `invert(${invertNum})`;
    debuggerEnv.getElementsByTagName('img')[0].style.filter = `invert(${invertNum})`;
    mythXEnv.getElementsByTagName('img')[0].style.filter = `invert(${invertNum})`;
    sourceVerifyEnv.getElementsByTagName('img')[0].style.filter = `invert(${invertNum})`;
    moreEnv.getElementsByTagName('img')[0].style.filter = `invert(${invertNum})`;

    let switchToPreviousVersion = () => {
      const query = new QueryParams();
      query.update({
        appVersion: '0.7.7'
      });
      document.location.reload();
    };

    const img = yo`<img src="assets/img/sleepingRemiCroped.webp"></img>`;
    const container = yo`<div class="${css.homeContainer} bg-light" data-id="landingPageHomeContainer">
      <div>
        <div class="alert alert-info clearfix py-3 ${css.thisJumboton}">
          <div class="${css.headlineContainer}">
            <div class="${css.logoContainer}">${img}</div>
          </div>
          <div class="${css.jumboBtnContainer} px-5">
            <button class="btn btn-primary mx-3" href="#" onclick=${() => learnMore()} role="button">Learn more</button>
            <button class="btn btn-secondary" onclick=${() => switchToPreviousVersion()}>Use previous version</button>
          </div>
        </div><!-- end of jumbotron -->
      </div><!-- end of jumbotron container -->
      <div class="row ${css.hpSections} mx-4" data-id="landingPageHpSections">
        <div id="col1" class="col-sm-5">
          <div class="mb-5">
            <h4>Environments</h4>
            <div class="${css.enviroments} pt-2">
              ${solEnv}
              ${vyperEnv}
            </div>
          </div>
          <div class="file">
            <h4>File</h4>
            <p class="mb-1 ${css.text}" onclick=${() => createNewFile()}>New File</p>
            <p class="mb-1">
              <p class="${css.labelIt} ${css.text}">
                Open Files
                <input title="open file" type="file" onchange="${event => {
      event.stopPropagation();
      let fileExplorer = globalRegistry.get('fileexplorer/browser').api;
      fileExplorer.uploadFile(event);
    }}" multiple />
              </p>
            </p>
            <p class="mb-1 ${css.text}" onclick=${() => connectToLocalhost()}>Connect to Localhost</p>
            <p class="mt-3 mb-0"><label>IMPORT FROM:</label></p>
            <div class="btn-group">
              <button class="btn mr-1 btn-secondary" data-id="landingPageImportFromGistButton" onclick="${() => importFromGist()}">Gist</button>
              <button class="btn mx-1 btn-secondary" onclick="${() => load('Github', 'github URL', ['https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/nf-token-metadata.sol', 'https://github.com/OpenZeppelin/openzeppelin-solidity/blob/67bca857eedf99bf44a4b6a0fc5b5ed553135316/contracts/access/Roles.sol', 'github:OpenZeppelin/openzeppelin-solidity/contracts/ownership/Ownable.sol#v2.1.2'])}">GitHub</button>
              <button class="btn mx-1 btn-secondary" onclick="${() => load('Swarm', 'bzz-raw URL', ['bzz-raw://<swarm-hash>'])}">Swarm</button>
              <button class="btn mx-1 btn-secondary" onclick="${() => load('Ipfs', 'ipfs URL', ['ipfs://<ipfs-hash>'])}">Ipfs</button>
              <button class="btn mx-1 btn-secondary" onclick="${() => load('Https', 'http/https raw content', ['https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/master/contracts/crowdsale/validation/IndividuallyCappedCrowdsale.sol'])}">https</button>
              <button class="btn mx-1 btn-secondary  text-nowrap" onclick="${() => load('@resolver-engine', 'resolver-engine URL', ['github:OpenZeppelin/openzeppelin-solidity/contracts/ownership/Ownable.sol#v2.1.2'], yo`<span>please checkout <a class='text-primary' href="https://github.com/Crypto-Punkers/resolver-engine" target='_blank'>https://github.com/Crypto-Punkers/resolver-engine</a> for more information</span>`)}">Resolver-engine</button>
            </div><!-- end of btn-group -->
          </div><!-- end of div.file -->
        </div><!-- end of #col1 -->
        <div id="col2" class="col-sm-7">
          <div class="plugins mb-5">
            <h4>Featured Plugins</h4>
            <div class="d-flex flex-row pt-2">
              ${pipelineEnv}
              ${mythXEnv}
              ${sourceVerifyEnv}
              ${debuggerEnv}
              ${moreEnv}
            </div>
          </div>
          <div class="resources">
            <h4>Resources</h4>
            <p class="mb-1"><a class="${css.text}" target="__blank" href="https://remix-ide.readthedocs.io/en/latest/#">Documentation</a></p>
            <p class="mb-1"><a class="${css.text}" target="__blank" href="https://gitter.im/ethereum/remix">Gitter channel</a></p>
            <p class="mb-1"><a class="${css.text}" target="__blank" href="https://medium.com/remix-ide">Medium Posts</a></p>
            <p class="mb-1"><a class="${css.text}" target="__blank" href="https://remix-ide.readthedocs.io/en/latest/">Tutorials</a></p>
          </div>
        </div><!-- end of #col2 -->
      </div><!-- end of hpSections -->
      </div>`;
    return container;
  }

}

exports.LandingPage = LandingPage;

/***/ }),

/***/ "./app/ui/modal-dialog-custom.js":
/*!***************************************!*\
  !*** ./app/ui/modal-dialog-custom.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var modal = __webpack_require__(/*! ./modaldialog.js */ "./app/ui/modaldialog.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = __webpack_require__(/*! ./styles/modal-dialog-custom-styles */ "./app/ui/styles/modal-dialog-custom-styles.js");

module.exports = {
  alert: function (title, text) {
    if (text) return modal(title, yo`<div>${text}</div>`, null, {
      label: null
    });
    return modal('', yo`<div>${title}</div>`, null, {
      label: null
    });
  },
  prompt: function (title, text, inputValue, ok, cancel, focus) {
    return prompt(title, text, false, inputValue, ok, cancel, focus);
  },
  promptPassphrase: function (title, text, inputValue, ok, cancel) {
    return prompt(title, text, true, inputValue, ok, cancel);
  },
  promptPassphraseCreation: function (ok, cancel) {
    var text = 'Please provide a Passphrase for the account creation';
    var input = yo`<div>
      <input id="prompt1" type="password" name='prompt_text' class="${css['prompt_text']}" >
      <br>
      <br>
      <input id="prompt2" type="password" name='prompt_text' class="${css['prompt_text']}" >
    </div>`;
    return modal(null, yo`<div>${text}<div>${input}</div></div>`, {
      fn: () => {
        if (typeof ok === 'function') {
          if (input.querySelector('#prompt1').value === input.querySelector('#prompt2').value) {
            ok(null, input.querySelector('#prompt1').value);
          } else {
            ok('Passphase does not match');
          }
        }
      }
    }, {
      fn: () => {
        if (typeof cancel === 'function') cancel();
      }
    });
  },
  promptMulti: function ({
    title,
    text,
    inputValue
  }, ok, cancel) {
    if (!inputValue) inputValue = '';
    var input = yo`<textarea id="prompt_text" data-id="modalDialogCustomPromptText" class=${css.prompt_text} rows="4" cols="50"></textarea>`;
    return modal(title, yo`<div>${text}<div>${input}</div></div>`, {
      fn: () => {
        if (typeof ok === 'function') ok(document.getElementById('prompt_text').value);
      }
    }, {
      fn: () => {
        if (typeof cancel === 'function') cancel();
      }
    });
  },
  confirm: function (title, text, ok, cancel) {
    return modal(title, yo`<div>${text}</div>`, {
      fn: () => {
        if (typeof ok === 'function') ok();
      }
    }, {
      fn: () => {
        if (typeof cancel === 'function') cancel();
      }
    });
  }
};

function prompt(title, text, hidden, inputValue, ok, cancel, focus) {
  if (!inputValue) inputValue = '';
  var type = hidden ? 'password' : 'text';
  var input = yo`<input type=${type} name='prompt_text' id='prompt_text' class="${css['prompt_text']} form-control" value='${inputValue}' data-id="modalDialogCustomPromptText">`;
  modal(title, yo`<div>${text}<div>${input}</div></div>`, {
    fn: () => {
      if (typeof ok === 'function') ok(document.getElementById('prompt_text').value);
    }
  }, {
    fn: () => {
      if (typeof cancel === 'function') cancel();
    }
  }, focus ? '#prompt_text' : undefined);
}

/***/ }),

/***/ "./app/ui/modaldialog.js":
/*!*******************************!*\
  !*** ./app/ui/modaldialog.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = __webpack_require__(/*! ./styles/modaldialog-styles */ "./app/ui/styles/modaldialog-styles.js");

let incomingModal = false; // in case modals are queued, ensure we are not hiding the last one.

module.exports = (title, content, ok, cancel, focusSelector, opts) => {
  let agreed = true;
  let footerIsActive = false;
  opts = opts || {};
  var container = document.querySelector(`.modal`);

  if (!container) {
    document.querySelector('body').appendChild(html(opts));
    container = document.querySelector(`.modal`);
    incomingModal = false;
  } else incomingModal = true;

  var closeDiv = document.getElementById('modal-close');
  if (opts.hideClose) closeDiv.style.display = 'none';
  var okDiv = document.getElementById('modal-footer-ok');
  okDiv.innerHTML = ok && ok.label !== undefined ? ok.label : 'OK';
  okDiv.style.display = okDiv.innerHTML === '' ? 'none' : 'inline-block';
  var cancelDiv = document.getElementById('modal-footer-cancel');
  cancelDiv.innerHTML = cancel && cancel.label !== undefined ? cancel.label : 'Cancel';
  cancelDiv.style.display = cancelDiv.innerHTML === '' ? 'none' : 'inline-block';
  var modal = document.querySelector(`.modal-body`);
  var modalTitle = document.querySelector(`.modal-header h6`);
  modalTitle.innerHTML = '';
  if (title) modalTitle.innerText = title;
  modal.innerHTML = '';
  if (content) modal.appendChild(content);
  setFocusOn('ok');
  show();

  function setFocusOn(btn) {
    var okDiv = document.getElementById('modal-footer-ok');
    var cancelDiv = document.getElementById('modal-footer-cancel');

    if (btn === 'ok') {
      okDiv.className = okDiv.className.replace(/\bbtn-light\b/g, 'btn-dark');
      cancelDiv.className = cancelDiv.className.replace(/\bbtn-dark\b/g, 'btn-light');
    } else {
      cancelDiv.className = cancelDiv.className.replace(/\bbtn-light\b/g, 'btn-dark');
      okDiv.className = okDiv.className.replace(/\bbtn-dark\b/g, 'btn-light');
    }
  }

  function okListener() {
    removeEventListener();
    if (ok && ok.fn && agreed) ok.fn();
    if (!incomingModal) hide();
    incomingModal = false;
  }

  function cancelListener() {
    removeEventListener();
    if (cancel && cancel.fn) cancel.fn();
    if (!incomingModal) hide();
    incomingModal = false;
  }

  function modalKeyEvent(e) {
    if (e.keyCode === 27) {
      // Esc
      cancelListener();
    } else if (e.keyCode === 13) {
      // Enter
      e.preventDefault();
      okListener();
    } else if (e.keyCode === 37 && footerIsActive) {
      // Arrow Left
      e.preventDefault();
      agreed = true;
      setFocusOn('ok');
    } else if (e.keyCode === 39 && footerIsActive) {
      // Arrow Right
      e.preventDefault();
      agreed = false;
      setFocusOn('cancel');
    }
  }

  function hide() {
    if (!container) return;
    container.style.display = 'none';
    if (container.parentElement) container.parentElement.removeChild(container);
    container = null;
    incomingModal = false;
  }

  function show() {
    if (!container) return;
    container.style.display = 'block';

    if (focusSelector) {
      const focusTarget = document.querySelector(`.modal ${focusSelector}`);

      if (focusTarget) {
        focusTarget.focus();

        if (typeof focusTarget.setSelectionRange === 'function') {
          focusTarget.setSelectionRange(0, focusTarget.value.length);
        }
      }
    }
  }

  function removeEventListener() {
    okDiv.removeEventListener('click', okListener);
    cancelDiv.removeEventListener('click', cancelListener);
    closeDiv.removeEventListener('click', cancelListener);
    document.removeEventListener('keydown', modalKeyEvent);

    if (document.getElementById('modal-background')) {
      document.getElementById('modal-background').removeEventListener('click', cancelListener);
    }
  }

  okDiv.addEventListener('click', okListener);
  cancelDiv.addEventListener('click', cancelListener);
  closeDiv.addEventListener('click', cancelListener);
  document.addEventListener('keydown', modalKeyEvent);
  let modalDialog = document.getElementById('modal-dialog');

  if (modalDialog) {
    modalDialog.addEventListener('click', e => {
      footerIsActive = document.activeElement === modalDialog;

      if (e.toElement === modalDialog) {
        cancelListener(); // click is outside of modal-content
      }
    });
  }

  return {
    container,
    okListener,
    cancelListener,
    hide
  };
};

function html(opts) {
  return yo`
  <div id="modal-dialog" data-id="modalDialogContainer" class="modal" tabindex="-1" role="dialog">
    <div id="modal-background" class="modal-dialog" role="document">
      <div class="modal-content ${css.modalContent} ${opts.class}">
        <div class="modal-header">
          <h6 class="modal-title" data-id="modalDialogModalTitle"></h6>
          <span class="modal-close">
            <i id="modal-close" title="Close" class="fas fa-times" aria-hidden="true"></i>
          </span>
        </div>
        <div class="modal-body ${css.modalBody}" data-id="modalDialogModalBody"> - </div>
        <div class="modal-footer" data-id="modalDialogModalFooter" autofocus>
          <span id="modal-footer-ok" class="${css['modalFooterOk']} modal-ok btn btn-sm btn-light" tabindex='5'>OK</span>
          <span id="modal-footer-cancel" class="${css['modalFooterCancel']} modal-cancel btn btn-sm btn-light" tabindex='10' data-dismiss="modal">Cancel</span>
        </div>
      </div>
    </div>
  </div>`;
}

/***/ }),

/***/ "./app/ui/multiParamManager.js":
/*!*************************************!*\
  !*** ./app/ui/multiParamManager.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = __webpack_require__(/*! ../../universal-dapp-styles */ "./universal-dapp-styles.js");

var copyToClipboard = __webpack_require__(/*! ./copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var txFormat = remixLib.execution.txFormat;

class MultiParamManager {
  /**
    *
    * @param {bool} lookupOnly
    * @param {Object} funABI
    * @param {Function} clickMultiCallBack
    * @param {string} inputs
    * @param {string} title
    * @param {string} evmBC
    *
    */
  constructor(lookupOnly, funABI, clickCallBack, inputs, title, evmBC, isDeploy) {
    this.lookupOnly = lookupOnly;
    this.funABI = funABI;
    this.clickCallBack = clickCallBack;
    this.inputs = inputs;
    this.title = title;
    this.evmBC = evmBC;
    this.basicInputField;
    this.multiFields;
    this.isDeploy = isDeploy;
  }

  switchMethodViewOn() {
    this.contractActionsContainerSingle.style.display = 'none';
    this.contractActionsContainerMulti.style.display = 'flex';
    this.makeMultiVal();
  }

  switchMethodViewOff() {
    this.contractActionsContainerSingle.style.display = 'flex';
    this.contractActionsContainerMulti.style.display = 'none';
    var multiValString = this.getMultiValsString();
    if (multiValString) this.basicInputField.value = multiValString;
  }

  getValue(item, index) {
    var valStr = item.value.join('');
    return valStr;
  }

  getMultiValsString() {
    var valArray = this.multiFields.querySelectorAll('input');
    var ret = '';
    var valArrayTest = [];

    for (var j = 0; j < valArray.length; j++) {
      if (ret !== '') ret += ',';
      var elVal = valArray[j].value;
      valArrayTest.push(elVal);
      elVal = elVal.replace(/(^|,\s+|,)(\d+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted number by quoted number

      elVal = elVal.replace(/(^|,\s+|,)(0[xX][0-9a-fA-F]+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted hex string by quoted hex string

      try {
        JSON.parse(elVal);
      } catch (e) {
        elVal = '"' + elVal + '"';
      }

      ret += elVal;
    }

    var valStringTest = valArrayTest.join('');

    if (valStringTest) {
      return ret;
    } else {
      return '';
    }
  }

  emptyInputs() {
    var valArray = this.multiFields.querySelectorAll('input');

    for (var k = 0; k < valArray.length; k++) {
      valArray[k].value = '';
    }

    this.basicInputField.value = '';
  }

  makeMultiVal() {
    var inputString = this.basicInputField.value;

    if (inputString) {
      inputString = inputString.replace(/(^|,\s+|,)(\d+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted number by quoted number

      inputString = inputString.replace(/(^|,\s+|,)(0[xX][0-9a-fA-F]+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted hex string by quoted hex string

      var inputJSON = JSON.parse('[' + inputString + ']');
      var multiInputs = this.multiFields.querySelectorAll('input');

      for (var k = 0; k < multiInputs.length; k++) {
        if (inputJSON[k]) {
          multiInputs[k].value = JSON.stringify(inputJSON[k]);
        }
      }
    }
  }

  createMultiFields() {
    if (this.funABI.inputs) {
      return yo`<div>
        ${this.funABI.inputs.map(function (inp) {
        return yo`<div class="${css.multiArg}"><label for="${inp.name}"> ${inp.name}: </label><input class="form-control" placeholder="${inp.type}" title="${inp.name}" data-id="multiParamManagerInput${inp.name}"></div>`;
      })}
      </div>`;
    }
  }

  render() {
    var title;

    if (this.title) {
      title = this.title;
    } else if (this.funABI.name) {
      title = this.funABI.name;
    } else {
      title = this.funABI.type === 'receive' ? '(receive)' : '(fallback)';
    }

    this.basicInputField = yo`<input class="form-control" data-id="multiParamManagerBasicInputField"></input>`;
    this.basicInputField.setAttribute('placeholder', this.inputs);
    this.basicInputField.setAttribute('title', this.inputs);
    this.basicInputField.setAttribute('data-id', this.inputs);

    var onClick = () => {
      this.clickCallBack(this.funABI.inputs, this.basicInputField.value);
    };

    const width = this.isDeploy ? '' : 'w-50';
    let funcButton = yo`<button onclick=${() => onClick()} class="${css.instanceButton} ${width} btn btn-sm" data-id="multiParamManagerFuncButton">${title}</button>`;
    this.contractActionsContainerSingle = yo`
    <div class="${css.contractActionsContainerSingle} pt-2">
      ${funcButton}
      ${this.basicInputField}
      <i class="fas fa-angle-down ${css.methCaret}" onclick=${() => this.switchMethodViewOn()} title=${title} ></i>
    </div>`;
    this.multiFields = this.createMultiFields();

    var multiOnClick = () => {
      var valsString = this.getMultiValsString();

      if (valsString) {
        this.clickCallBack(this.funABI.inputs, valsString);
      } else {
        this.clickCallBack(this.funABI.inputs, '');
      }
    };

    var expandedButton = yo`<button onclick=${() => {
      multiOnClick();
    }} class="${css.instanceButton}" data-id="multiParamManagerExpandedButton"></button>`;
    this.contractActionsContainerMulti = yo`<div class="${css.contractActionsContainerMulti}" >
      <div class="${css.contractActionsContainerMultiInner} text-dark" >
        <div onclick=${() => {
      this.switchMethodViewOff();
    }} class="${css.multiHeader}">
          <div class="${css.multiTitle} run-instance-multi-title">${title}</div>
          <i class='fas fa-angle-up ${css.methCaret}'></i>
        </div>
        ${this.multiFields}
        <div class="${css.group} ${css.multiArg}" >
          ${copyToClipboard(() => {
      var multiString = this.getMultiValsString();
      var multiJSON = JSON.parse('[' + multiString + ']');
      var encodeObj;

      if (this.evmBC) {
        encodeObj = txFormat.encodeData(this.funABI, multiJSON, this.evmBC);
      } else {
        encodeObj = txFormat.encodeData(this.funABI, multiJSON);
      }

      if (encodeObj.error) {
        throw new Error(encodeObj.error);
      } else {
        return encodeObj.data;
      }
    }, 'Encode values of input fields & copy to clipboard', 'fa-clipboard')}
            ${expandedButton}
        </div>
      </div>
    </div>`;
    var contractProperty = yo`
      <div class="${css.contractProperty}">
        ${this.contractActionsContainerSingle} ${this.contractActionsContainerMulti}
      </div>
    `;

    if (this.lookupOnly) {
      // call. stateMutability is either pure or view
      expandedButton.setAttribute('title', title + ' - call');
      expandedButton.innerHTML = 'call';
      expandedButton.classList.add('btn-info');
      expandedButton.setAttribute('data-id', title + ' - call');
      funcButton.setAttribute('title', title + ' - call');
      funcButton.classList.add('btn-info');
      funcButton.setAttribute('data-id', title + ' - call');
    } else if (this.funABI.stateMutability === 'payable' || this.funABI.payable) {
      // transact. stateMutability = payable
      expandedButton.setAttribute('title', title + ' - transact (payable)');
      expandedButton.innerHTML = 'transact';
      expandedButton.classList.add('btn-danger');
      expandedButton.setAttribute('data-id', title + ' - transact (payable)');
      funcButton.setAttribute('title', title + ' - transact (payable)');
      funcButton.classList.add('btn-danger');
      funcButton.setAttribute('data-id', title + ' - transact (payable)');
    } else {
      // transact. stateMutability = nonpayable
      expandedButton.setAttribute('title', title + ' - transact (not payable)');
      expandedButton.innerHTML = 'transact';
      expandedButton.classList.add('btn-warning');
      expandedButton.setAttribute('data-id', title + ' - transact (not payable)');
      funcButton.classList.add('btn-warning');
      funcButton.setAttribute('title', title + ' - transact (not payable)');
      funcButton.setAttribute('data-id', title + ' - transact (not payable)');
    }

    if (this.funABI.inputs && this.funABI.inputs.length > 0) {
      contractProperty.classList.add(css.hasArgs);
    } else if (this.funABI.type === 'fallback' || this.funABI.type === 'receive') {
      contractProperty.classList.add(css.hasArgs);
      this.basicInputField.setAttribute('title', `'(${this.funABI.type}')`); // probably should pass name instead

      this.contractActionsContainerSingle.querySelector('i').style.visibility = 'hidden';
      this.basicInputField.setAttribute('data-id', `'(${this.funABI.type}')`);
    } else {
      this.contractActionsContainerSingle.querySelector('i').style.visibility = 'hidden';
      this.basicInputField.style.visibility = 'hidden';
    }

    return contractProperty;
  }

}

module.exports = MultiParamManager;

/***/ }),

/***/ "./app/ui/persmission-handler.js":
/*!***************************************!*\
  !*** ./app/ui/persmission-handler.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PermissionHandler = void 0;

/* global localStorage */
const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const addTooltip = __webpack_require__(/*! ./tooltip */ "./app/ui/tooltip.js");

const modalDialog = __webpack_require__(/*! ./modaldialog */ "./app/ui/modaldialog.js");

const globalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

const css = csjs`
.permission h4 {
  text-transform: uppercase;
  text-align: center;
}
.permission h6 {
  text-transform: uppercase;
}
.remember {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.images {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 10px;
}
.images img {
  width: 40px;
  height: 40px;
}
.images i {
  margin: 0 20px;
}
`;

function notAllowWarning(from, to, method) {
  return `${from.displayName || from.name} is not allowed to call ${method} method of ${to.displayName || to.name}.`;
}

class PermissionHandler {
  constructor() {
    this.permissions = this._getFromLocal();
    this.currentVersion = 1; // here we remove the old permissions saved before adding 'permissionVersion'
    // since with v1 the structure has been changed because of new engine ^0.2.0-alpha.6 changes

    if (!localStorage.getItem('permissionVersion')) {
      localStorage.setItem('plugins/permissions', '');
      localStorage.setItem('permissionVersion', this.currentVersion);
    }
  }

  _getFromLocal() {
    const permission = localStorage.getItem('plugins/permissions');
    return permission ? JSON.parse(permission) : {};
  }

  persistPermissions() {
    const permissions = JSON.stringify(this.permissions);
    localStorage.setItem('plugins/permissions', permissions);
  }

  clear() {
    localStorage.removeItem('plugins/permissions');
    addTooltip('All Permissions have been reset');
  }
  /**
   * Show a message to ask the user for a permission
   * @param {PluginProfile} from The name and hash of the plugin that make the call
   * @param {ModuleProfile} to The name of the plugin that receive the call
   * @param {string} method The name of the function to be called
   * @param {string} message from the caller plugin to add more details if needed
   * @returns {Promise<{ allow: boolean; remember: boolean }} Answer from the user to the permission
   */


  async openPermission(from, to, method, message) {
    return new Promise((resolve, reject) => {
      modalDialog(`Permission needed for ${to.displayName || to.name}`, this.form(from, to, method, message), {
        label: 'Accept',
        fn: () => {
          if (this.permissions[to.name][method][from.name]) {
            this.permissions[to.name][method][from.name] = {
              allow: true,
              hash: from.hash
            };
            this.persistPermissions();
          }

          resolve(true);
        }
      }, {
        label: 'Decline',
        fn: () => {
          if (this.permissions[to.name][method][from.name]) {
            this.permissions[to.name][method][from.name] = {
              allow: false,
              hash: from.hash
            };
            this.persistPermissions();
          }

          reject(notAllowWarning(from, to, method));
        }
      });
    });
  }
  /**
   * Check if a plugin has the permission to call another plugin and askPermission if needed
   * @param {PluginProfile} from the profile of the plugin that make the call
   * @param {ModuleProfile} to The profile of the module that receive the call
   * @param {string} method The name of the function to be called
   * @param {string} message from the caller plugin to add more details if needed
   * @returns {Promise<boolean>}
   */


  async askPermission(from, to, method, message) {
    try {
      this.permissions = this._getFromLocal();
      if (!this.permissions[to.name]) this.permissions[to.name] = {};
      if (!this.permissions[to.name][method]) this.permissions[to.name][method] = {};
      if (!this.permissions[to.name][method][from.name]) return this.openPermission(from, to, method, message);
      const {
        allow,
        hash
      } = this.permissions[to.name][method][from.name];

      if (!allow) {
        const warning = notAllowWarning(from, to, method);
        addTooltip(warning);
        return false;
      }

      return hash === from.hash ? true // Allow
      : this.openPermission(from, to, method, message); // New version of a plugin
    } catch (err) {
      throw new Error(err);
    }
  }
  /**
   * The permission form
   * @param {PluginProfile} from The name and hash of the plugin that make the call
   * @param {ModuleProfile} to The name of the plugin that receive the call
   * @param {string} method The name of te methode to be called
   * @param {string} message from the caller plugin to add more details if needed
   */


  form(from, to, method, message) {
    const fromName = from.displayName || from.name;
    const toName = to.displayName || to.name;
    const remember = this.permissions[to.name][method][from.name];

    const switchMode = e => {
      e.target.checked ? this.permissions[to.name][method][from.name] = {} : delete this.permissions[to.name][method][from.name];
    };

    const rememberSwitch = remember ? yo`<input type="checkbox" onchange="${switchMode}" checkbox class="form-check-input" id="remember" data-id="permissionHandlerRememberChecked">` : yo`<input type="checkbox" onchange="${switchMode}" class="form-check-input" id="remember" data-id="permissionHandlerRememberUnchecked">`;
    const text = `"${fromName}" ${remember ? `has changed and` : ``} would like to access to "${method}" of "${toName}"`;
    const imgFrom = yo`<img id="permissionModalImagesFrom" src="${from.icon}" />`;
    const imgTo = yo`<img id="permissionModalImagesTo" src="${to.icon}" />`;
    const pluginsImages = yo`
      <article class="${css.images}">
        ${imgFrom}
        <i class="fas fa-arrow-right"></i>
        ${imgTo}
      </article>
    `;
    globalRegistry.get('themeModule').api.fixInvert(imgFrom);
    globalRegistry.get('themeModule').api.fixInvert(imgTo);
    const pluginMessage = message ? yo`
      <div>
        <h6>Description</h6>
        <p>${message}</p>
      </div>
    ` : ``;
    return yo`
      <section class="${css.permission}">
        ${pluginsImages}
        <article>
          <h4 data-id="permissionHandlerMessage">${text} :</h4>
          <h6>${fromName}</h6>
          <p>${from.description || yo`<i>No description Provided</i>`}</p>
          <h6>${toName} :</p>
          <p>${to.description || yo`<i>No description Provided</i>`}</p>
          ${pluginMessage}
        </article>

        <article class="${css.remember}">
          <div class="form-check">
            ${rememberSwitch}
            <label class="form-check-label" for="remember" data-id="permissionHandlerRememberChoice">Remember this choice</label>
          </div>
          <button class="btn btn-sm" onclick="${_ => this.clear()}">Reset all Permissions</button>
        </article>
      </section>
    `;
  }

}

exports.PermissionHandler = PermissionHandler;

/***/ }),

/***/ "./app/ui/renderer.js":
/*!****************************!*\
  !*** ./app/ui/renderer.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = __webpack_require__(/*! ./styles/renderer-styles */ "./app/ui/styles/renderer-styles.js");

var globlalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");
/**
 * After refactor, the renderer is only used to render error/warning
 * TODO: This don't need to be an object anymore. Simplify and just export the renderError function.
 *
 */


function Renderer(localRegistry) {
  const self = this;
  self._components = {};
  self._components.registry = localRegistry || globlalRegistry; // dependencies

  self._deps = {
    fileManager: self._components.registry.get('filemanager').api,
    config: self._components.registry.get('config').api
  };

  if (document && document.head) {
    document.head.appendChild(css);
  }
}

Renderer.prototype._error = function (file, error) {
  const self = this;

  const editor = self._components.registry.get('editor').api;

  if (file === self._deps.config.get('currentFile')) {
    editor.addAnnotation(error);
  }
};

Renderer.prototype._errorClick = function (errFile, errLine, errCol) {
  const self = this;

  const editor = self._components.registry.get('editor').api;

  if (errFile !== self._deps.config.get('currentFile')) {
    // TODO: refactor with this._components.contextView.jumpTo
    var provider = self._deps.fileManager.fileProviderOf(errFile);

    if (provider) {
      provider.exists(errFile, (error, exist) => {
        if (error) return console.log(error);

        self._deps.fileManager.open(errFile);

        editor.gotoLine(errLine, errCol);
      });
    }
  } else {
    editor.gotoLine(errLine, errCol);
  }
};
/**
 * format msg like error or warning,
 *
 * @param {String or DOMElement} message
 * @param {DOMElement} container
 * @param {Object} options {
 *  useSpan,
 *  noAnnotations,
 *  click:(Function),
 *  type:(
 *    warning,
 *    error
 *  ),
 *  errFile,
 *  errLine,
 *  errCol
 * }
 */


Renderer.prototype.error = function (message, container, opt) {
  if (!message) return;
  if (container === undefined) return;
  opt = opt || {};
  var text;

  if (typeof message === 'string') {
    text = message;
    message = yo`<span>${message}</span>`;
  } else if (message.innerText) {
    text = message.innerText;
  }

  var errLocation = text.match(/^([^:]*):([0-9]*):(([0-9]*):)? /);

  if ((!opt.errFile || !opt.errCol || !opt.errLine) && errLocation) {
    errLocation = parseRegExError(errLocation);
    opt.errFile = errLocation.errFile;
    opt.errLine = errLocation.errLine;
    opt.errCol = errLocation.errCol;
  }

  if (!opt.noAnnotations && errLocation) {
    this._error(errLocation.errFile, {
      row: errLocation.errLine,
      column: errLocation.errCol,
      text: text,
      type: opt.type
    });
  }

  var $pre = $(opt.useSpan ? yo`<span></span>` : yo`<pre></pre>`).html(message);
  let classList = opt.type === 'error' ? 'alert alert-danger' : 'alert alert-warning';
  var $error = $(yo`<div class="sol ${opt.type} ${classList}"><div class="close" data-id="renderer"><i class="fas fa-times"></i></div></div>`).prepend($pre);
  $(container).append($error);
  $error.click(ev => {
    if (opt.click) {
      opt.click(message);
    } else if (opt.errFile && opt.errLine && opt.errCol) {
      this._errorClick(opt.errFile, opt.errLine, opt.errCol);
    }
  });
  $error.find('.close').click(function (ev) {
    ev.preventDefault();
    $error.remove();
    return false;
  });
};

function parseRegExError(err) {
  return {
    errFile: err[1],
    errLine: parseInt(err[2], 10) - 1,
    errCol: err[4] ? parseInt(err[4], 10) : 0
  };
}

module.exports = Renderer;

/***/ }),

/***/ "./app/ui/sendTxCallbacks.js":
/*!***********************************!*\
  !*** ./app/ui/sendTxCallbacks.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const confirmDialog = __webpack_require__(/*! ./confirmDialog */ "./app/ui/confirmDialog.js");

const modalCustom = __webpack_require__(/*! ./modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

const modalDialog = __webpack_require__(/*! ./modaldialog */ "./app/ui/modaldialog.js");

const typeConversion = remixLib.execution.typeConversion;

const Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

module.exports = {
  getCallBacksWithContext: (udappUI, blockchain) => {
    let callbacks = {};
    callbacks.confirmationCb = confirmationCb;
    callbacks.continueCb = continueCb;
    callbacks.promptCb = promptCb;
    callbacks.udappUI = udappUI;
    callbacks.blockchain = blockchain;
    return callbacks;
  }
};

const continueCb = function (error, continueTxExecution, cancelCb) {
  if (error) {
    const msg = typeof error !== 'string' ? error.message : error;
    modalDialog('Gas estimation failed', yo`
        <div>Gas estimation errored with the following message (see below).
        The transaction execution will likely fail. Do you want to force sending? <br>${msg}</div>
      `, {
      label: 'Send Transaction',
      fn: () => continueTxExecution()
    }, {
      label: 'Cancel Transaction',
      fn: () => cancelCb()
    });
  } else {
    continueTxExecution();
  }
};

const promptCb = function (okCb, cancelCb) {
  modalCustom.promptPassphrase('Passphrase requested', 'Personal mode is enabled. Please provide passphrase of account', '', okCb, cancelCb);
};

const confirmationCb = function (network, tx, gasEstimation, continueTxExecution, cancelCb) {
  let self = this;

  if (network.name !== 'Main') {
    return continueTxExecution(null);
  }

  var amount = Web3.utils.fromWei(typeConversion.toInt(tx.value), 'ether');
  var content = confirmDialog(tx, amount, gasEstimation, self.udappUI, (gasPrice, cb) => {
    let txFeeText, priceStatus; // TODO: this try catch feels like an anti pattern, can/should be
    // removed, but for now keeping the original logic

    try {
      var fee = Web3.utils.toBN(tx.gas).mul(Web3.utils.toBN(Web3.utils.toWei(gasPrice.toString(10), 'gwei')));
      txFeeText = ' ' + Web3.utils.fromWei(fee.toString(10), 'ether') + ' Ether';
      priceStatus = true;
    } catch (e) {
      txFeeText = ' Please fix this issue before sending any transaction. ' + e.message;
      priceStatus = false;
    }

    cb(txFeeText, priceStatus);
  }, cb => {
    self.blockchain.web3().eth.getGasPrice((error, gasPrice) => {
      const warnMessage = ' Please fix this issue before sending any transaction. ';

      if (error) {
        return cb('Unable to retrieve the current network gas price.' + warnMessage + error);
      }

      try {
        var gasPriceValue = Web3.utils.fromWei(gasPrice.toString(10), 'gwei');
        cb(null, gasPriceValue);
      } catch (e) {
        cb(warnMessage + e.message, null, false);
      }
    });
  });
  modalDialog('Confirm transaction', content, {
    label: 'Confirm',
    fn: () => {
      self.blockchain.config.setUnpersistedProperty('doNotShowTransactionConfirmationAgain', content.querySelector('input#confirmsetting').checked); // TODO: check if this is check is still valid given the refactor

      if (!content.gasPriceStatus) {
        cancelCb('Given gas price is not correct');
      } else {
        var gasPrice = Web3.utils.toWei(content.querySelector('#gasprice').value, 'gwei');
        continueTxExecution(gasPrice);
      }
    }
  }, {
    label: 'Cancel',
    fn: () => {
      return cancelCb('Transaction canceled by user.');
    }
  });
};

/***/ }),

/***/ "./app/ui/styles/auto-complete-popup-styles.js":
/*!*****************************************************!*\
  !*** ./app/ui/styles/auto-complete-popup-styles.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .popup             {
    position         : absolute;
    text-align       : left;
    display          : none;
    width            : 95%;
    font-family      : monospace;
    background-color : var(--secondary);
    overflow         : auto;
    padding-bottom   : 13px;
    z-index          : 80;
    bottom           : 1em;
    border-width     : 4px;
    left             : 2em;
  }

  .autoCompleteItem {
    padding          : 4px;
    border-radius    : 2px;
  }

  .popup a {
    cursor           : pointer;
  }

  .listHandlerShow   {
    display          : block;
  }

  .listHandlerHide   {
    display          : none;
  }

  .listHandlerButtonShow {
    position         : fixed;
    width            : 46%;
  }

  .pageNumberAlignment {
    font-size        : 10px;
    float            : right;
  }

  .modalContent {
    position         : absolute;
    margin-left      : 20%;
    margin-bottom    : 32px;
    bottom           : 0px;
    padding          : 0;
    line-height      : 18px;
    font-size        : 12px;
    width            : 40%;
    box-shadow       : 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
    -webkit-animation-name: animatebottom;
    -webkit-animation-duration: 0.4s;
    animation-name   : animatetop;
    animation-duration: 0.4s
  }

  @-webkit-keyframes animatetop {
    from {bottom: -300px; opacity: 0}
    to {bottom: 0; opacity: 1}
  }

  @keyframes animatetop {
    from {bottom: -300px; opacity: 0}
    to {bottom: 0; opacity: 1}
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/ui/styles/modal-dialog-custom-styles.js":
/*!*****************************************************!*\
  !*** ./app/ui/styles/modal-dialog-custom-styles.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .prompt_text {
    width: 100%;
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/ui/styles/modaldialog-styles.js":
/*!*********************************************!*\
  !*** ./app/ui/styles/modaldialog-styles.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`

  .modalFooter {
  }
  .modalContent {
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
    -webkit-animation-name: animatetop;
    -webkit-animation-duration: 0.4s;
    animation-name: animatetop;
    animation-duration: 0.4s
  }
  .modalBody {
    word-break: break-word;
    overflow-y: auto;
    max-height: 600px;
  }
  .modalFooterOk {
  }
  .modalFooterCancel {
  }
  @-webkit-keyframes animatetop {
    from {top: -300px; opacity: 0}
    to {top: 0; opacity: 1}
  }
  @keyframes animatetop {
    from {top: -300px; opacity: 0}
    to {top: 0; opacity: 1}
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/ui/styles/renderer-styles.js":
/*!******************************************!*\
  !*** ./app/ui/styles/renderer-styles.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = yo`<style>
.sol.success,
.sol.error,
.sol.warning {
    white-space: pre-line;
    word-wrap: break-word;
    cursor: pointer;
    position: relative;
    margin: 0.5em 0 1em 0;
    border-radius: 5px;
    line-height: 20px;
    padding: 8px 15px;
}

.sol.success pre,
.sol.error pre,
.sol.warning pre {
    white-space: pre-line;
    overflow-y: hidden;
    background-color: transparent;
    margin: 0;
    font-size: 12px;
    border: 0 none;
    padding: 0;
    border-radius: 0;
}

.sol.success .close,
.sol.error .close,
.sol.warning .close {
    white-space: pre-line;
    font-weight: bold;
    position: absolute;
    color: hsl(0, 0%, 0%); /* black in style-guide.js */
    top: 0;
    right: 0;
    padding: 0.5em;
}

.sol.error {
}

.sol.warning {
}

.sol.success {
  /* background-color:  // styles.rightPanel.message_Success_BackgroundColor; */
}</style>`;
module.exports = css;

/***/ }),

/***/ "./app/ui/styles/tooltip-styles.js":
/*!*****************************************!*\
  !*** ./app/ui/styles/tooltip-styles.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .tooltip {
    z-index: 1001;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: fixed;
    min-height: 50px;
    padding: 16px 24px 12px;
    border-radius: 3px;
    bottom: -300;
    left: 40%;
    font-size: 14px;
    text-align: center;
    bottom: 0;
    flex-direction: row;
  }
  @-webkit-keyframes animatebottom  {
    0% {bottom: -300px}
    100% {bottom: 0}
  }
  @keyframes animatebottom  {
    0% {bottom: -300px}
    100% {bottom: 0}
  }
  @-webkit-keyframes animatetop  {
    0% {bottom: 0}
    100% {bottom: -300px}
  }
  @keyframes animatetop  {
    0% {bottom: 0}
    100% {bottom: -300px}
  }
  .animateTop {
    -webkit-animation-name: animatetop;
    -webkit-animation-duration: 2s;
    animation-name: animatetop;
    animation-duration: 2s;
  }
  .animateBottom {
    -webkit-animation-name: animatebottom;
    -webkit-animation-duration: 2s;
    animation-name: animatebottom;
    animation-duration: 2s;    
  }
`;
module.exports = css;

/***/ }),

/***/ "./app/ui/svgLogo.js":
/*!***************************!*\
  !*** ./app/ui/svgLogo.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basicLogo = basicLogo;

var _yoYo = _interopRequireDefault(__webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function basicLogo() {
  return (0, _yoYo.default)`<svg id="Ebene_2" data-name="Ebene 2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 105 100"> 
<title>remix_logo1</title>
<path d="M91.84,35a.09.09,0,0,1-.1-.07,41,41,0,0,0-79.48,0,.09.09,0,0,1-.1.07C9.45,35,1,35.35,1,42.53c0,8.56,1,16,6,20.32,2.16,1.85,5.81,2.3,9.27,2.22a44.4,44.4,0,0,0,6.45-.68.09.09,0,0,0,.06-.15A34.81,34.81,0,0,1,17,45c0-.1,0-.21,0-.31a35,35,0,0,1,70,0c0,.1,0,.21,0,.31a34.81,34.81,0,0,1-5.78,19.24.09.09,0,0,0,.06.15,44.4,44.4,0,0,0,6.45.68c3.46.08,7.11-.37,9.27-2.22,5-4.27,6-11.76,6-20.32C103,35.35,94.55,35,91.84,35Z"/>
<path d="M52,74,25.4,65.13a.1.1,0,0,0-.1.17L51.93,91.93a.1.1,0,0,0,.14,0L78.7,65.3a.1.1,0,0,0-.1-.17L52,74A.06.06,0,0,1,52,74Z"/>
<path d="M75.68,46.9,82,45a.09.09,0,0,0,.08-.09,29.91,29.91,0,0,0-.87-6.94.11.11,0,0,0-.09-.08l-6.43-.58a.1.1,0,0,1-.06-.18l4.78-4.18a.13.13,0,0,0,0-.12,30.19,30.19,0,0,0-3.65-6.07.09.09,0,0,0-.11,0l-5.91,2a.1.1,0,0,1-.12-.14L72.19,23a.11.11,0,0,0,0-.12,29.86,29.86,0,0,0-5.84-4.13.09.09,0,0,0-.11,0l-4.47,4.13a.1.1,0,0,1-.17-.07l.09-6a.1.1,0,0,0-.07-.1,30.54,30.54,0,0,0-7-1.47.1.1,0,0,0-.1.07l-2.38,5.54a.1.1,0,0,1-.18,0l-2.37-5.54a.11.11,0,0,0-.11-.06,30,30,0,0,0-7,1.48.12.12,0,0,0-.07.1l.08,6.05a.09.09,0,0,1-.16.07L37.8,18.76a.11.11,0,0,0-.12,0,29.75,29.75,0,0,0-5.83,4.13.11.11,0,0,0,0,.12l2.59,5.6a.11.11,0,0,1-.13.14l-5.9-2a.11.11,0,0,0-.12,0,30.23,30.23,0,0,0-3.62,6.08.11.11,0,0,0,0,.12l4.79,4.19a.1.1,0,0,1-.06.17L23,37.91a.1.1,0,0,0-.09.07A29.9,29.9,0,0,0,22,44.92a.1.1,0,0,0,.07.1L28.4,47a.1.1,0,0,1,0,.18l-5.84,3.26a.16.16,0,0,0,0,.11,30.17,30.17,0,0,0,2.1,6.76c.32.71.67,1.4,1,2.08a.1.1,0,0,0,.06,0L52,68.16H52l26.34-8.78a.1.1,0,0,0,.06-.05,30.48,30.48,0,0,0,3.11-8.88.1.1,0,0,0-.05-.11l-5.83-3.26A.1.1,0,0,1,75.68,46.9Z"/>
</svg>`;
}

/***/ }),

/***/ "./app/ui/tooltip.js":
/*!***************************!*\
  !*** ./app/ui/tooltip.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global Element */
var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var css = __webpack_require__(/*! ./styles/tooltip-styles */ "./app/ui/styles/tooltip-styles.js");

var modal = __webpack_require__(/*! ./modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");
/**
 * Open a tooltip
 * @param {string} tooltipText The text shown by the tooltip
 * @param {function} [action] Returns An HTMLElement to display for action
 */


module.exports = function addTooltip(tooltipText, action, opts) {
  action = action || function () {
    return yo`<div></div>`;
  };

  let t = new Toaster();
  return t.render(tooltipText, action(t), opts);
};

class Toaster {
  hide() {
    if (this.id) clearTimeout(this.id);
    setTimeout(() => {
      // remove from body after the animation is finished
      if (this.tooltip.parentElement) this.tooltip.parentElement.removeChild(this.tooltip);
    }, 2000);
    animation(this.tooltip, css.animateTop.className);
  }
  /**
   * Force resolve the promise to close
   * the toaster ignoring timeout
   */


  forceResolve() {
    if (this.id) clearTimeout(this.id);
    if (this.resolveFn) this.resolveFn();
  }

  render(tooltipText, actionElement, opts) {
    opts = defaultOptions(opts);
    let canShorten = true;

    if (tooltipText instanceof Element) {
      canShorten = false;
    } else {
      if (typeof tooltipText === 'object') {
        if (tooltipText.message) {
          tooltipText = tooltipText.message;
        } else {
          try {
            tooltipText = JSON.stringify(tooltipText);
          } catch (e) {}
        }
      }
    }

    return new Promise((resolve, reject) => {
      const shortTooltipText = canShorten && tooltipText.length > 201 ? tooltipText.substring(0, 200) + '...' : tooltipText;
      this.resolveFn = resolve;

      function showFullMessage() {
        modal.alert(tooltipText);
      }

      function closeTheToaster(self) {
        self.hide();
        over();
        resolve();
      }

      let button = tooltipText.length > 201 ? yo`
      <button class="btn btn-secondary btn-sm mx-3" style="white-space: nowrap;" onclick=${() => showFullMessage()}>Show full message</button>
      ` : ``;
      this.tooltip = yo`
        <div data-shared="tooltipPopup" class="${css.tooltip} alert alert-info p-2"  onmouseenter=${() => {
        over();
      }} onmouseleave=${() => {
        out();
      }}>
          <span class="px-2">
            ${shortTooltipText}
            ${button}
            ${actionElement}
          </span>
          <span style="align-self: baseline;">
            <button data-id="tooltipCloseButton" class="fas fa-times btn-info mx-1 p-0" onclick=${() => closeTheToaster(this)}></button>
          </span>
        </div>`;

      let timeOut = () => {
        return setTimeout(() => {
          if (this.id) {
            this.hide();
            resolve();
          }
        }, opts.time);
      };

      let over = () => {
        if (this.id) {
          clearTimeout(this.id);
          this.id = null;
        }
      };

      let out = () => {
        if (!this.id) this.id = timeOut();
      };

      this.id = timeOut();
      document.body.appendChild(this.tooltip);
      animation(this.tooltip, css.animateBottom.className);
    });
  }

}

let defaultOptions = opts => {
  opts = opts || {};
  return {
    time: opts.time || 7000
  };
};

let animation = (tooltip, anim) => {
  tooltip.classList.remove(css.animateTop.className);
  tooltip.classList.remove(css.animateBottom.className);
  void tooltip.offsetWidth; // trick for restarting the animation

  tooltip.classList.add(anim);
};

/***/ }),

/***/ "./app/ui/txLogger.js":
/*!****************************!*\
  !*** ./app/ui/txLogger.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var copyToClipboard = __webpack_require__(/*! ./copy-to-clipboard */ "./app/ui/copy-to-clipboard.js"); // -------------- styling ----------------------


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var EventManager = __webpack_require__(/*! ../../lib/events */ "./lib/events.js");

var helper = __webpack_require__(/*! ../../lib/helper */ "./lib/helper.js");

var modalDialog = __webpack_require__(/*! ./modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var typeConversion = remixLib.execution.typeConversion;

var globlalRegistry = __webpack_require__(/*! ../../global/registry */ "./global/registry.js");

var css = csjs`
  .log {
    display: flex;
    cursor: pointer;
    align-items: center;
    cursor: pointer;
  }
  .log:hover {
    opacity: 0.8;
  }
  .arrow {
    color: var(--text-info);
    font-size: 20px;
    cursor: pointer;
    display: flex;
    margin-left: 10px;
  }
  .arrow:hover {
    color: var(--secondary);
  }
  .txLog {
  }
  .txStatus {
    display: flex;
    font-size: 20px;
    margin-right: 20px;
    float: left;
  }
  .succeeded {
    color: var(--success);
  }
  .failed {
    color: var(--danger);
  }
  .notavailable {
  }
  .call {
    font-size: 7px;
    border-radius: 50%;
    min-width: 20px;
    min-height: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: var(--text-info);
    text-transform: uppercase;
    font-weight: bold;
  }
  .txItem {
    color: var(--text-info);
    margin-right: 5px;
    float: left;
  }
  .txItemTitle {
    font-weight: bold;
  }
  .tx {
    color: var(--text-info);
    font-weight: bold;
    float: left;
    margin-right: 10px;
  }
  .txTable,
  .tr,
  .td {
    border-collapse: collapse;
    font-size: 10px;
    color: var(--text-info);
    border: 1px solid var(--text-info);
  }
  #txTable {
    margin-top: 1%;
    margin-bottom: 5%;
    align-self: center;
    width: 85%;
  }
  .tr, .td {
    padding: 4px;
    vertical-align: baseline;
  }
  .td:first-child {
    min-width: 30%;
    width: 30%;
    align-items: baseline;
    font-weight: bold;
  }
  .tableTitle {
    width: 25%;
  }
  .buttons {
    display: flex;
    margin-left: auto;
  }
  .debug {
    white-space: nowrap;
  }
  .debug:hover {
    opacity: 0.8;
  }`;
/**
  * This just export a function that register to `newTransaction` and forward them to the logger.
  *
  */

class TxLogger {
  constructor(terminal, blockchain) {
    this.event = new EventManager();
    this.seen = {};

    function filterTx(value, query) {
      if (value.length) {
        return helper.find(value, query);
      }

      return false;
    }

    this.eventsDecoder = globlalRegistry.get('eventsDecoder').api;
    this.txListener = globlalRegistry.get('txlistener').api;
    this.terminal = terminal; // dependencies

    this._deps = {
      compilersArtefacts: globlalRegistry.get('compilersartefacts').api
    };
    this.logKnownTX = this.terminal.registerCommand('knownTransaction', (args, cmds, append) => {
      var data = args[0];
      var el;

      if (data.tx.isCall) {
        el = renderCall(this, data);
      } else {
        el = renderKnownTransaction(this, data, blockchain);
      }

      this.seen[data.tx.hash] = el;
      append(el);
    }, {
      activate: true,
      filterFn: filterTx
    });
    this.logUnknownTX = this.terminal.registerCommand('unknownTransaction', (args, cmds, append) => {
      // triggered for transaction AND call
      var data = args[0];
      var el = renderUnknownTransaction(this, data, blockchain);
      append(el);
    }, {
      activate: false,
      filterFn: filterTx
    });
    this.logEmptyBlock = this.terminal.registerCommand('emptyBlock', (args, cmds, append) => {
      var data = args[0];
      var el = renderEmptyBlock(this, data);
      append(el);
    }, {
      activate: true
    });
    this.txListener.event.register('newBlock', block => {
      if (!block.transactions || block.transactions && !block.transactions.length) {
        this.logEmptyBlock({
          block: block
        });
      }
    });
    this.txListener.event.register('newTransaction', (tx, receipt) => {
      log(this, tx, receipt);
    });
    this.txListener.event.register('newCall', tx => {
      log(this, tx, null);
    });
    this.terminal.updateJournal({
      type: 'select',
      value: 'unknownTransaction'
    });
    this.terminal.updateJournal({
      type: 'select',
      value: 'knownTransaction'
    });
  }

}

function debug(e, data, self) {
  e.stopPropagation();

  if (data.tx.isCall && data.tx.envMode !== 'vm') {
    modalDialog.alert('Cannot debug this call. Debugging calls is only possible in JavaScript VM mode.');
  } else {
    self.event.trigger('debuggingRequested', [data.tx.hash]);
  }
}

function log(self, tx, receipt) {
  var resolvedTransaction = self.txListener.resolvedTransaction(tx.hash);

  if (resolvedTransaction) {
    var compiledContracts = null;

    if (self._deps.compilersArtefacts['__last']) {
      compiledContracts = self._deps.compilersArtefacts['__last'].getContracts();
    }

    self.eventsDecoder.parseLogs(tx, resolvedTransaction.contractName, compiledContracts, (error, logs) => {
      if (!error) {
        self.logKnownTX({
          tx: tx,
          receipt: receipt,
          resolvedData: resolvedTransaction,
          logs: logs
        });
      }
    });
  } else {
    // contract unknown - just displaying raw tx.
    self.logUnknownTX({
      tx: tx,
      receipt: receipt
    });
  }
}

function renderKnownTransaction(self, data, blockchain) {
  var from = data.tx.from;
  var to = data.resolvedData.contractName + '.' + data.resolvedData.fn;
  var obj = {
    from,
    to
  };
  var txType = 'knownTx';
  var tx = yo`
    <span id="tx${data.tx.hash}" data-id="txLogger${data.tx.hash}">
      <div class="${css.log}" onclick=${e => txDetails(e, tx, data, obj)}>
        ${checkTxStatus(data.receipt, txType)}
        ${context(self, {
    from,
    to,
    data
  }, blockchain)}
        <div class=${css.buttons}>
          <button class="${css.debug} btn btn-primary btn-sm" data-shared="txLoggerDebugButton" data-id="txLoggerDebugButton${data.tx.hash}" onclick=${e => debug(e, data, self)}>Debug</div>
        </div>
        <i class="${css.arrow} fas fa-angle-down"></i>
      </div>
    </span>
  `;
  return tx;
}

function renderCall(self, data) {
  var to = data.resolvedData.contractName + '.' + data.resolvedData.fn;
  var from = data.tx.from ? data.tx.from : ' - ';
  var input = data.tx.input ? helper.shortenHexData(data.tx.input) : '';
  var obj = {
    from,
    to
  };
  var txType = 'call';
  var tx = yo`
    <span id="tx${data.tx.hash}">
      <div class="${css.log}" onclick=${e => txDetails(e, tx, data, obj)}>
        ${checkTxStatus(data.tx, txType)}
        <span class=${css.txLog}>
          <span class=${css.tx}>[call]</span>
          <div class=${css.txItem}><span class=${css.txItemTitle}>from:</span> ${from}</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>to:</span> ${to}</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>data:</span> ${input}</div>
        </span>
        <div class=${css.buttons}>
          <div class="${css.debug} btn btn-primary btn-sm" onclick=${e => debug(e, data, self)}>Debug</div>
        </div>
        <i class="${css.arrow} fas fa-angle-down"></i>
      </div>
    </span>
  `;
  return tx;
}

function renderUnknownTransaction(self, data, blockchain) {
  var from = data.tx.from;
  var to = data.tx.to;
  var obj = {
    from,
    to
  };
  var txType = 'unknown' + (data.tx.isCall ? 'Call' : 'Tx');
  var tx = yo`
    <span id="tx${data.tx.hash}">
      <div class="${css.log}" onclick=${e => txDetails(e, tx, data, obj)}>
        ${checkTxStatus(data.receipt || data.tx, txType)}
        ${context(self, {
    from,
    to,
    data
  }, blockchain)}
        <div class=${css.buttons}>
          <div class="${css.debug} btn btn-primary btn-sm" onclick=${e => debug(e, data, self)}>Debug</div>
        </div>
        <i class="${css.arrow} fas fa-angle-down"></i>
      </div>
    </span>
  `;
  return tx;
}

function renderEmptyBlock(self, data) {
  return yo`
    <span class=${css.txLog}>
      <span class='${css.tx}'><div class=${css.txItem}>[<span class=${css.txItemTitle}>block:${data.block.number} - </span> 0 transactions]</span></span>
    </span>`;
}

function checkTxStatus(tx, type) {
  if (tx.status === '0x1' || tx.status === true) {
    return yo`<i class="${css.txStatus} ${css.succeeded} fas fa-check-circle"></i>`;
  }

  if (type === 'call' || type === 'unknownCall') {
    return yo`<i class="${css.txStatus} ${css.call}">call</i>`;
  } else if (tx.status === '0x0' || tx.status === false) {
    return yo`<i class="${css.txStatus} ${css.failed} fas fa-times-circle"></i>`;
  } else {
    return yo`<i class="${css.txStatus} ${css.notavailable} fas fa-circle-thin" title='Status not available' ></i>`;
  }
}

function context(self, opts, blockchain) {
  var data = opts.data || '';
  var from = opts.from ? helper.shortenHexData(opts.from) : '';
  var to = opts.to;
  if (data.tx.to) to = to + ' ' + helper.shortenHexData(data.tx.to);
  var val = data.tx.value;
  var hash = data.tx.hash ? helper.shortenHexData(data.tx.hash) : '';
  var input = data.tx.input ? helper.shortenHexData(data.tx.input) : '';
  var logs = data.logs && data.logs.decoded && data.logs.decoded.length ? data.logs.decoded.length : 0;
  var block = data.receipt ? data.receipt.blockNumber : data.tx.blockNumber || '';
  var i = data.receipt ? data.receipt.transactionIndex : data.tx.transactionIndex;
  var value = val ? typeConversion.toInt(val) : 0;

  if (blockchain.getProvider() === 'vm') {
    return yo`
      <div>
        <span class=${css.txLog}>
          <span class=${css.tx}>[vm]</span>
          <div class=${css.txItem}><span class=${css.txItemTitle}>from:</span> ${from}</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>to:</span> ${to}</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>value:</span> ${value} wei</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>data:</span> ${input}</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>logs:</span> ${logs}</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>hash:</span> ${hash}</div>
        </span>
      </div>`;
  } else if (blockchain.getProvider() !== 'vm' && data.resolvedData) {
    return yo`
      <div>
        <span class=${css.txLog}>
        <span class='${css.tx}'>[block:${block} txIndex:${i}]</span>
          <div class=${css.txItem}><span class=${css.txItemTitle}>from:</span> ${from}</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>to:</span> ${to}</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>value:</span> ${value} wei</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>data:</span> ${input}</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>logs:</span> ${logs}</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>hash:</span> ${hash}</div>
        </span>
      </div>`;
  } else {
    to = helper.shortenHexData(to);
    hash = helper.shortenHexData(data.tx.blockHash);
    return yo`
      <div>
        <span class=${css.txLog}>
          <span class='${css.tx}'>[block:${block} txIndex:${i}]</span>
          <div class=${css.txItem}><span class=${css.txItemTitle}>from:</span> ${from}</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>to:</span> ${to}</div>
          <div class=${css.txItem}><span class=${css.txItemTitle}>value:</span> ${value} wei</div>
        </span>
      </div>`;
  }
}

module.exports = TxLogger; // helpers

function txDetails(e, tx, data, obj) {
  const from = obj.from;
  const to = obj.to;
  const arrowUp = yo`<i class="${css.arrow} fas fa-angle-up"></i>`;
  const arrowDown = yo`<i class="${css.arrow} fas fa-angle-down"></i>`;
  let blockElement = e.target;

  while (true) {
    // get the parent block element
    if (blockElement.className.startsWith('block')) break;else if (blockElement.parentElement) {
      blockElement = blockElement.parentElement;
    } else break;
  }

  let table = blockElement.querySelector(`#${tx.id} [class^="txTable"]`);
  const log = blockElement.querySelector(`#${tx.id} [class^='log']`);
  const arrow = blockElement.querySelector(`#${tx.id} [class^='arrow']`);

  if (table && table.parentNode) {
    tx.removeChild(table);
    log.removeChild(arrow);
    log.appendChild(arrowDown);
  } else {
    log.removeChild(arrow);
    log.appendChild(arrowUp);
    table = createTable({
      hash: data.tx.hash,
      status: data.receipt ? data.receipt.status : null,
      isCall: data.tx.isCall,
      contractAddress: data.tx.contractAddress,
      data: data.tx,
      from,
      to,
      gas: data.tx.gas,
      input: data.tx.input,
      'decoded input': data.resolvedData && data.resolvedData.params ? JSON.stringify(typeConversion.stringify(data.resolvedData.params), null, '\t') : ' - ',
      'decoded output': data.resolvedData && data.resolvedData.decodedReturnValue ? JSON.stringify(typeConversion.stringify(data.resolvedData.decodedReturnValue), null, '\t') : ' - ',
      logs: data.logs,
      val: data.tx.value,
      transactionCost: data.tx.transactionCost,
      executionCost: data.tx.executionCost
    });
    tx.appendChild(table);
  }
}

function createTable(opts) {
  var table = yo`<table class="${css.txTable}" id="txTable" data-id="txLoggerTable${opts.hash}"></table>`;

  if (!opts.isCall) {
    var msg = '';

    if (opts.status !== undefined && opts.status !== null) {
      if (opts.status === '0x0' || opts.status === false) {
        msg = ' Transaction mined but execution failed';
      } else if (opts.status === '0x1' || opts.status === true) {
        msg = ' Transaction mined and execution succeed';
      }
    } else {
      msg = ' Status not available at the moment';
    }

    table.appendChild(yo`
      <tr class="${css.tr}">
        <td class="${css.td}" data-shared="key_${opts.hash}"> status </td>
        <td class="${css.td}" data-id="txLoggerTableStatus${opts.hash}" data-shared="pair_${opts.hash}">${opts.status}${msg}</td>
      </tr>`);
  }

  var transactionHash = yo`
    <tr class="${css.tr}">
      <td class="${css.td}" data-shared="key_${opts.hash}"> transaction hash </td>
      <td class="${css.td}" data-id="txLoggerTableHash${opts.hash}" data-shared="pair_${opts.hash}">${opts.hash}
        ${copyToClipboard(() => opts.hash)}
      </td>
    </tr>
  `;
  table.appendChild(transactionHash);
  var contractAddress = yo`
    <tr class="${css.tr}">
      <td class="${css.td}" data-shared="key_${opts.hash}"> contract address </td>
      <td class="${css.td}" data-id="txLoggerTableContractAddress${opts.hash}" data-shared="pair_${opts.hash}">${opts.contractAddress}
        ${copyToClipboard(() => opts.contractAddress)}
      </td>
    </tr>
  `;
  if (opts.contractAddress) table.appendChild(contractAddress);
  var from = yo`
    <tr class="${css.tr}">
      <td class="${css.td} ${css.tableTitle}" data-shared="key_${opts.hash}"> from </td>
      <td class="${css.td}" data-id="txLoggerTableFrom${opts.hash}" data-shared="pair_${opts.hash}">${opts.from}
        ${copyToClipboard(() => opts.from)}
      </td>
    </tr>
  `;
  if (opts.from) table.appendChild(from);
  var toHash;
  var data = opts.data; // opts.data = data.tx

  if (data.to) {
    toHash = opts.to + ' ' + data.to;
  } else {
    toHash = opts.to;
  }

  var to = yo`
    <tr class="${css.tr}">
    <td class="${css.td}" data-shared="key_${opts.hash}"> to </td>
    <td class="${css.td}" data-id="txLoggerTableTo${opts.hash}" data-shared="pair_${opts.hash}">${toHash}
      ${copyToClipboard(() => data.to ? data.to : toHash)}
    </td>
    </tr>
  `;
  if (opts.to) table.appendChild(to);
  var gas = yo`
    <tr class="${css.tr}">
      <td class="${css.td}" data-shared="key_${opts.hash}"> gas </td>
      <td class="${css.td}" data-id="txLoggerTableGas${opts.hash}" data-shared="pair_${opts.hash}">${opts.gas} gas
        ${copyToClipboard(() => opts.gas)}
      </td>
    </tr>
  `;
  if (opts.gas) table.appendChild(gas);
  var callWarning = '';

  if (opts.isCall) {
    callWarning = '(Cost only applies when called by a contract)';
  }

  if (opts.transactionCost) {
    table.appendChild(yo`
    <tr class="${css.tr}">
      <td class="${css.td}" data-shared="key_${opts.hash}"> transaction cost </td>
      <td class="${css.td}" data-id="txLoggerTableTransactionCost${opts.hash}" data-shared="pair_${opts.hash}">${opts.transactionCost} gas ${callWarning}
        ${copyToClipboard(() => opts.transactionCost)}
      </td>
    </tr>`);
  }

  if (opts.executionCost) {
    table.appendChild(yo`
    <tr class="${css.tr}">
      <td class="${css.td}" data-shared="key_${opts.hash}"> execution cost </td>
      <td class="${css.td}" data-id="txLoggerTableExecutionHash${opts.hash}" data-shared="pair_${opts.hash}">${opts.executionCost} gas ${callWarning}
        ${copyToClipboard(() => opts.executionCost)}
      </td>
    </tr>`);
  }

  var hash = yo`
    <tr class="${css.tr}">
      <td class="${css.td}" data-shared="key_${opts.hash}"> hash </td>
      <td class="${css.td}" data-id="txLoggerTableHash${opts.hash}" data-shared="pair_${opts.hash}">${opts.hash}
        ${copyToClipboard(() => opts.hash)}
      </td>
    </tr>
  `;
  if (opts.hash) table.appendChild(hash);
  var input = yo`
    <tr class="${css.tr}">
      <td class="${css.td}" data-shared="key_${opts.hash}"> input </td>
      <td class="${css.td}" data-id="txLoggerTableInput${opts.hash}" data-shared="pair_${opts.hash}">${helper.shortenHexData(opts.input)}
        ${copyToClipboard(() => opts.input)}
      </td>
    </tr>
  `;
  if (opts.input) table.appendChild(input);

  if (opts['decoded input']) {
    var inputDecoded = yo`
    <tr class="${css.tr}">
      <td class="${css.td}" data-shared="key_${opts.hash}"> decoded input </td>
      <td class="${css.td}" data-id="txLoggerTableDecodedInput${opts.hash}" data-shared="pair_${opts.hash}">${opts['decoded input']}
        ${copyToClipboard(() => opts['decoded input'])}
      </td>
    </tr>`;
    table.appendChild(inputDecoded);
  }

  if (opts['decoded output']) {
    var outputDecoded = yo`
    <tr class="${css.tr}">
      <td class="${css.td}" data-shared="key_${opts.hash}"> decoded output </td>
      <td class="${css.td}" id="decodedoutput" data-id="txLoggerTableDecodedOutput${opts.hash}" data-shared="pair_${opts.hash}">${opts['decoded output']}
        ${copyToClipboard(() => opts['decoded output'])}
      </td>
    </tr>`;
    table.appendChild(outputDecoded);
  }

  var stringified = ' - ';

  if (opts.logs && opts.logs.decoded) {
    stringified = typeConversion.stringify(opts.logs.decoded);
  }

  var logs = yo`
    <tr class="${css.tr}">
      <td class="${css.td}" data-shared="key_${opts.hash}"> logs </td>
      <td class="${css.td}" id="logs" data-id="txLoggerTableLogs${opts.hash}" data-shared="pair_${opts.hash}">
        ${JSON.stringify(stringified, null, '\t')}
        ${copyToClipboard(() => JSON.stringify(stringified, null, '\t'))}
        ${copyToClipboard(() => JSON.stringify(opts.logs.raw || '0'))}
      </td>
    </tr>
  `;
  if (opts.logs) table.appendChild(logs);
  var val = opts.val != null ? typeConversion.toInt(opts.val) : 0;
  val = yo`
    <tr class="${css.tr}">
      <td class="${css.td}" data-shared="key_${opts.hash}"> value </td>
      <td class="${css.td}" data-id="txLoggerTableValue${opts.hash}" data-shared="pair_${opts.hash}">${val} wei
        ${copyToClipboard(() => `${val} wei`)}
      </td>
    </tr>
  `;
  if (opts.val) table.appendChild(val);
  return table;
}

/***/ }),

/***/ "./app/ui/universal-dapp-ui.js":
/*!*************************************!*\
  !*** ./app/ui/universal-dapp-ui.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global */


var $ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");

var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var ethJSUtil = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

var BN = ethJSUtil.BN;

var helper = __webpack_require__(/*! ../../lib/helper */ "./lib/helper.js");

var copyToClipboard = __webpack_require__(/*! ./copy-to-clipboard */ "./app/ui/copy-to-clipboard.js");

var css = __webpack_require__(/*! ../../universal-dapp-styles */ "./universal-dapp-styles.js");

var MultiParamManager = __webpack_require__(/*! ./multiParamManager */ "./app/ui/multiParamManager.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var txFormat = remixLib.execution.txFormat;
const txHelper = remixLib.execution.txHelper;

var TreeView = __webpack_require__(/*! ./TreeView */ "./app/ui/TreeView.js");

var txCallBacks = __webpack_require__(/*! ./sendTxCallbacks */ "./app/ui/sendTxCallbacks.js");

function UniversalDAppUI(blockchain, logCallback) {
  this.blockchain = blockchain;
  this.logCallback = logCallback;
  this.compilerData = {
    contractsDetails: {}
  };
}

function decodeResponseToTreeView(response, fnabi) {
  var treeView = new TreeView({
    extractData: (item, parent, key) => {
      var ret = {};

      if (BN.isBN(item)) {
        ret.self = item.toString(10);
        ret.children = [];
      } else {
        ret = treeView.extractDataDefault(item, parent, key);
      }

      return ret;
    }
  });
  return treeView.render(txFormat.decodeResponse(response, fnabi));
}

UniversalDAppUI.prototype.renderInstance = function (contract, address, contractName) {
  var noInstances = document.querySelector('[data-id="deployAndRunNoInstanceText"]');

  if (noInstances) {
    noInstances.parentNode.removeChild(noInstances);
  }

  const abi = txHelper.sortAbiFunction(contract.abi);
  return this.renderInstanceFromABI(abi, address, contractName);
}; // TODO this function was named before "appendChild".
// this will render an instance: contract name, contract address, and all the public functions
// basically this has to be called for the "atAddress" (line 393) and when a contract creation succeed
// this returns a DOM element


UniversalDAppUI.prototype.renderInstanceFromABI = function (contractABI, address, contractName) {
  let self = this;
  address = (address.slice(0, 2) === '0x' ? '' : '0x') + address.toString('hex');
  address = ethJSUtil.toChecksumAddress(address);
  var instance = yo`<div class="instance run-instance border-dark ${css.instance} ${css.hidesub}" id="instance${address}" data-shared="universalDappUiInstance"></div>`;
  const context = this.blockchain.context();
  var shortAddress = helper.shortenAddress(address);
  var title = yo`
    <div class="${css.title} alert alert-secondary">
      <button data-id="universalDappUiTitleExpander" class="btn ${css.titleExpander}" onclick="${e => {
    toggleClass(e);
  }}">
        <i class="fas fa-angle-right" aria-hidden="true"></i>
      </button>
      <div class="input-group ${css.nameNbuts}">
        <div class="${css.titleText} input-group-prepend">
          <span class="input-group-text ${css.spanTitleText}">
            ${contractName} at ${shortAddress} (${context})
          </span>
        </div>
        <div class="btn-group">
          <button class="btn p-1 btn-secondary">${copyToClipboard(() => address)}</button>
        </div>
      </div>
    </div>
  `;
  var close = yo`
    <button
      class="${css.udappClose} mr-2 p-1 btn btn-secondary"
      data-id="universalDappUiUdappClose"
      onclick=${remove}
      title="Remove from the list"
    >
      <i class="${css.closeIcon} fas fa-times" aria-hidden="true"></i>
    </button>`;
  title.querySelector('.btn-group').appendChild(close);
  var contractActionsWrapper = yo`
    <div class="${css.cActionsWrapper}" data-id="universalDappUiContractActionWrapper">
    </div>
  `;

  function remove() {
    instance.remove(); // @TODO perhaps add a callack here to warn the caller that the instance has been removed
  }

  function toggleClass(e) {
    $(instance).toggleClass(`${css.hidesub} bg-light`); // e.currentTarget.querySelector('i')

    e.currentTarget.querySelector('i').classList.toggle(`fa-angle-right`);
    e.currentTarget.querySelector('i').classList.toggle(`fa-angle-down`);
  }

  instance.appendChild(title);
  instance.appendChild(contractActionsWrapper);
  $.each(contractABI, (i, funABI) => {
    if (funABI.type !== 'function') {
      return;
    } // @todo getData cannot be used with overloaded functions


    contractActionsWrapper.appendChild(this.getCallButton({
      funABI: funABI,
      address: address,
      contractABI: contractABI,
      contractName: contractName
    }));
  });
  const calldataInput = yo`
    <input id="deployAndRunLLTxCalldata" class="${css.calldataInput} form-control" title="The Calldata to send to fallback function of the contract.">
  `;
  const llIError = yo`
    <label id="deployAndRunLLTxError" class="text-danger my-2"></label>
  `; // constract LLInteractions elements

  const lowLevelInteracions = yo`
    <div class="d-flex flex-column">
      <div class="d-flex flex-row justify-content-between mt-2">
        <div class="py-2 border-top d-flex justify-content-start flex-grow-1">
          Low level interactions
        </div>
        <a
          href="https://solidity.readthedocs.io/en/v0.6.2/contracts.html#receive-ether-function"
          title="check out docs for using 'receive'/'fallback'"
          target="_blank"
        >
          <i aria-hidden="true" class="fas fa-info my-2 mr-1"></i>
        </a>
      </div>
      <div class="d-flex flex-column align-items-start">
        <label class="">CALLDATA</label>
        <div class="d-flex justify-content-end w-100 align-items-center">
          ${calldataInput}
          <button id="deployAndRunLLTxSendTransaction" data-id="pluginManagerSettingsDeployAndRunLLTxSendTransaction" class="${css.instanceButton} p-0 w-50 btn border-warning text-warning" title="Send data to contract." onclick=${() => sendData()}>Transact</button>
        </div>
      </div>
      <div>
        ${llIError}
      </div>
    </div>
  `;

  function sendData() {
    function setLLIError(text) {
      llIError.innerText = text;
    }

    setLLIError('');
    const fallback = txHelper.getFallbackInterface(contractABI);
    const receive = txHelper.getReceiveInterface(contractABI);
    const args = {
      funABI: fallback || receive,
      address: address,
      contractName: contractName,
      contractABI: contractABI
    };
    const amount = document.querySelector('#value').value;

    if (amount !== '0') {
      // check for numeric and receive/fallback
      if (!helper.isNumeric(amount)) {
        return setLLIError('Value to send should be a number');
      } else if (!receive && !(fallback && fallback.stateMutability === 'payable')) {
        return setLLIError("In order to receive Ether transfer the contract should have either 'receive' or payable 'fallback' function");
      }
    }

    let calldata = calldataInput.value;

    if (calldata) {
      if (calldata.length < 2 || calldata.length < 4 && helper.is0XPrefixed(calldata)) {
        return setLLIError('The calldata should be a valid hexadecimal value with size of at least one byte.');
      } else {
        if (helper.is0XPrefixed(calldata)) {
          calldata = calldata.substr(2, calldata.length);
        }

        if (!helper.isHexadecimal(calldata)) {
          return setLLIError('The calldata should be a valid hexadecimal value.');
        }
      }

      if (!fallback) {
        return setLLIError("'Fallback' function is not defined");
      }
    }

    if (!receive && !fallback) return setLLIError(`Both 'receive' and 'fallback' functions are not defined`); // we have to put the right function ABI:
    // if receive is defined and that there is no calldata => receive function is called
    // if fallback is defined => fallback function is called

    if (receive && !calldata) args.funABI = receive;else if (fallback) args.funABI = fallback;
    if (!args.funABI) return setLLIError(`Please define a 'Fallback' function to send calldata and a either 'Receive' or payable 'Fallback' to send ethers`);
    self.runTransaction(false, args, null, calldataInput.value, null);
  }

  contractActionsWrapper.appendChild(lowLevelInteracions);
  return instance;
}; // TODO this is used by renderInstance when a new instance is displayed.
// this returns a DOM element.


UniversalDAppUI.prototype.getCallButton = function (args) {
  let self = this;
  var outputOverride = yo`<div class=${css.value}></div>`; // show return value

  const isConstant = args.funABI.constant !== undefined ? args.funABI.constant : false;
  const lookupOnly = args.funABI.stateMutability === 'view' || args.funABI.stateMutability === 'pure' || isConstant;
  const multiParamManager = new MultiParamManager(lookupOnly, args.funABI, (valArray, inputsValues) => self.runTransaction(lookupOnly, args, valArray, inputsValues, outputOverride), self.blockchain.getInputs(args.funABI));
  const contractActionsContainer = yo`<div class="${css.contractActionsContainer}" >${multiParamManager.render()}</div>`;
  contractActionsContainer.appendChild(outputOverride);
  return contractActionsContainer;
};

UniversalDAppUI.prototype.runTransaction = function (lookupOnly, args, valArr, inputsValues, outputOverride) {
  const functionName = args.funABI.type === 'function' ? args.funABI.name : `(${args.funABI.type})`;
  const logMsg = `${lookupOnly ? 'call' : 'transact'} to ${args.contractName}.${functionName}`;
  const callbacksInContext = txCallBacks.getCallBacksWithContext(this, this.blockchain);

  const outputCb = returnValue => {
    if (outputOverride) {
      const decoded = decodeResponseToTreeView(returnValue, args.funABI);
      outputOverride.innerHTML = '';
      outputOverride.appendChild(decoded);
    }
  };

  const params = args.funABI.type !== 'fallback' ? inputsValues : '';
  this.blockchain.runOrCallContractMethod(args.contractName, args.contractAbi, args.funABI, inputsValues, args.address, params, lookupOnly, logMsg, this.logCallback, outputCb, callbacksInContext.confirmationCb.bind(callbacksInContext), callbacksInContext.continueCb.bind(callbacksInContext), callbacksInContext.promptCb.bind(callbacksInContext));
};

module.exports = UniversalDAppUI;

/***/ }),

/***/ "./assets/js/editor/darkTheme.js":
/*!***************************************!*\
  !*** ./assets/js/editor/darkTheme.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable */
ace.define("ace/theme/remixDark", ["require", "exports", "module", "ace/lib/dom"], function (acequire, exports, module) {
  exports.isDark = true;
  exports.cssClass = "ace-remixDark";
  exports.cssText = ".ace-remixDark .ace_gutter {\
  background: #2a2c3f;\
  color: #8789a1;\
  border-right: 1px solid #282828;\
  }\
  .ace-remixDark .ace_gutter-cell.ace_warning {\
  background-image: none;\
  background: #FC0;\
  border-left: none;\
  padding-left: 0;\
  color: #000;\
  }\
  .ace-remixDark .ace_gutter-cell.ace_error {\
  background-position: -6px center;\
  background-image: none;\
  background: #F10;\
  border-left: none;\
  padding-left: 0;\
  color: #000;\
  }\
  .ace-remixDark .ace_print-margin {\
  border-left: 1px solid #555;\
  right: 0;\
  background: #1D1D1D;\
  }\
  .ace-remixDark {\
  background-color: #222336;\
  color: #a2a3bd;\
  }\
  .ace-remixDark .ace_cursor {\
  border-left: 2px solid #FFFFFF;\
  }\
  .ace-remixDark .ace_cursor.ace_overwrite {\
  border-left: 0px;\
  border-bottom: 1px solid #FFFFFF;\
  }\
  .ace-remixDark .ace_marker-layer .ace_selection {\
  background: #494836;\
  }\
  .ace-remixDark .ace_marker-layer .ace_step {\
  background: rgb(198, 219, 174);\
  }\
  .ace-remixDark .ace_marker-layer .ace_bracket {\
  margin: -1px 0 0 -1px;\
  border: 1px solid #FCE94F;\
  }\
  .ace-remixDark .ace_marker-layer .ace_active-line {\
  background: #363950;\
  }\
  .ace-remixDark .ace_gutter-active-line {\
  background-color: #363950;\
  }\
  .ace-remixDark .ace_invisible {\
  color: #404040;\
  }\
  .ace-remixDark .ace_rparen {\
    color: #d4d7ed;\
  }\
  .ace-remixDark .ace_lparen {\
    color: #d4d7ed;\
  }\
  .ace-remixDark .ace_keyword {\
  color:#ffa76d;\
  }\
  .ace-remixDark .ace_keyword.ace_operator {\
  color:#eceeff;\
  }\
  .ace-remixDark .ace_constant {\
  color:#1EDAFB;\
  }\
  .ace-remixDark .ace_constant.ace_language {\
  color:#FDC251;\
  }\
  .ace-remixDark .ace_constant.ace_library {\
  color:#8DFF0A;\
  }\
  .ace-remixDark .ace_constant.ace_numeric {\
  color:#eceeff;\
  }\
  .ace-remixDark .ace_invalid {\
  color:#FFFFFF;\
  background-color:#990000;\
  }\
  .ace-remixDark .ace_invalid.ace_deprecated {\
  color:#FFFFFF;\
  background-color:#990000;\
  }\
  .ace-remixDark .ace_support {\
  color: #999;\
  }\
  .ace-remixDark .ace_support.ace_function {\
  color:#3fe2a7;\
  }\
  .ace-remixDark .ace_function {\
  color:#3fe2a7;\
  }\
  .ace-remixDark .ace_string {\
  color:#eceeff;\
  }\
  .ace-remixDark .ace_comment {\
  color:#a7a7a7;\
  font-style:italic;\
  padding-bottom: 0px;\
  }\
  .ace-remixDark .ace_type {\
  color:#75ceef;\
  }]\
  .ace-remixDark .ace_visibility (\
    color:#f7d777;\
  )\
  .ace-remixDark .ace_identifier {\
    color:#bec1dd;\
  }\
  .ace-remixDark .ace_modifier {\
    color:#efff2f;\
  }\
  .ace-remixDark .ace-boolean {\
    color:#ff86ac;\
  }\
  .ace-remixDark .ace_statemutability {\
    color:#FFCC00;\
  }\
  .ace-remixDark .ace_variable {\
  color:#e0bb83;\
  }\
  .ace-remixDark .ace_meta.ace_tag {\
  color:#BE53E6;\
  }\
  .ace-remixDark .ace_entity.ace_other.ace_attribute-name {\
  color:#4aa8fd;\
  }\
  .ace-remixDark .ace_markup.ace_underline {\
  text-decoration: underline;\
  }\
  .ace-remixDark .ace_fold-widget {\
  text-align: center;\
  }\
  .ace-remixDark .ace_fold-widget:hover {\
  color: #777;\
  }\
  .ace-remixDark .ace_fold-widget.ace_start,\
  .ace-remixDark .ace_fold-widget.ace_end,\
  .ace-remixDark .ace_fold-widget.ace_closed{\
  background: none;\
  border: none;\
  box-shadow: none;\
  }\
  .ace-remixDark .ace_fold-widget.ace_start:after {\
  content: ''\
  }\
  .ace-remixDark .ace_fold-widget.ace_end:after {\
  content: ''\
  }\
  .ace-remixDark .ace_fold-widget.ace_closed:after {\
  content: ''\
  }\
  .ace-remixDark .ace_indent-guide {\
  border-right:1px dotted #333;\
  margin-right:-1px;\
  }\
  .ace-remixDark .ace_fold { \
  background: #222; \
  border-radius: 3px; \
  color: #7AF; \
  border: none; \
  }\
  .ace-remixDark .ace_fold:hover {\
  background: #CCC; \
  color: #000;\
  }\
  ";
  var dom = acequire("../lib/dom");
  dom.importCssString(exports.cssText, exports.cssClass);
});

/***/ }),

/***/ "./blockchain/blockchain.js":
/*!**********************************!*\
  !*** ./blockchain/blockchain.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

const txFormat = remixLib.execution.txFormat;
const txExecution = remixLib.execution.txExecution;
const typeConversion = remixLib.execution.typeConversion;
const Txlistener = remixLib.execution.txListener;
const TxRunner = remixLib.execution.txRunner;
const txHelper = remixLib.execution.txHelper;
const EventManager = remixLib.EventManager;
const executionContext = remixLib.execution.executionContext;

const Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

const async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

const {
  EventEmitter
} = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

const {
  resultToRemixTx
} = __webpack_require__(/*! ./txResultHelper */ "./blockchain/txResultHelper.js");

const VMProvider = __webpack_require__(/*! ./providers/vm.js */ "./blockchain/providers/vm.js");

const InjectedProvider = __webpack_require__(/*! ./providers/injected.js */ "./blockchain/providers/injected.js");

const NodeProvider = __webpack_require__(/*! ./providers/node.js */ "./blockchain/providers/node.js");

class Blockchain {
  // NOTE: the config object will need to be refactored out in remix-lib
  constructor(config) {
    this.event = new EventManager();
    this.executionContext = executionContext;
    this.events = new EventEmitter();
    this.config = config;
    this.txRunner = new TxRunner({}, {
      config: config,
      detectNetwork: cb => {
        this.executionContext.detectNetwork(cb);
      },
      personalMode: () => {
        return this.getProvider() === 'web3' ? this.config.get('settings/personal-mode') : false;
      }
    }, this.executionContext);
    this.executionContext.event.register('contextChanged', this.resetEnvironment.bind(this));
    this.networkcallid = 0;
    this.setupEvents();
    this.setupProviders();
  }

  setupEvents() {
    this.executionContext.event.register('contextChanged', (context, silent) => {
      this.event.trigger('contextChanged', [context, silent]);
    });
    this.executionContext.event.register('addProvider', network => {
      this.event.trigger('addProvider', [network]);
    });
    this.executionContext.event.register('removeProvider', name => {
      this.event.trigger('removeProvider', [name]);
    });
  }

  setupProviders() {
    this.providers = {};
    this.providers.vm = new VMProvider(this.executionContext);
    this.providers.injected = new InjectedProvider(this.executionContext);
    this.providers.web3 = new NodeProvider(this.executionContext, this.config);
  }

  getCurrentProvider() {
    const provider = this.getProvider();
    return this.providers[provider];
  }
  /** Return the list of accounts */
  // note: the dual promise/callback is kept for now as it was before


  getAccounts(cb) {
    return new Promise((resolve, reject) => {
      this.getCurrentProvider().getAccounts((error, accounts) => {
        if (cb) {
          return cb(error, accounts);
        }

        if (error) {
          reject(error);
        }

        resolve(accounts);
      });
    });
  }

  deployContractAndLibraries(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb) {
    const {
      continueCb,
      promptCb,
      statusCb,
      finalCb
    } = callbacks;
    const constructor = selectedContract.getConstructorInterface();
    txFormat.buildData(selectedContract.name, selectedContract.object, compilerContracts, true, constructor, args, (error, data) => {
      if (error) return statusCb(`creation of ${selectedContract.name} errored: ` + error);
      statusCb(`creation of ${selectedContract.name} pending...`);
      this.createContract(selectedContract, data, continueCb, promptCb, confirmationCb, finalCb);
    }, statusCb, (data, runTxCallback) => {
      // called for libraries deployment
      this.runTx(data, confirmationCb, continueCb, promptCb, runTxCallback);
    });
  }

  deployContractWithLibrary(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb) {
    const {
      continueCb,
      promptCb,
      statusCb,
      finalCb
    } = callbacks;
    const constructor = selectedContract.getConstructorInterface();
    txFormat.encodeConstructorCallAndLinkLibraries(selectedContract.object, args, constructor, contractMetadata.linkReferences, selectedContract.bytecodeLinkReferences, (error, data) => {
      if (error) return statusCb(`creation of ${selectedContract.name} errored: ` + error);
      statusCb(`creation of ${selectedContract.name} pending...`);
      this.createContract(selectedContract, data, continueCb, promptCb, confirmationCb, finalCb);
    });
  }

  createContract(selectedContract, data, continueCb, promptCb, confirmationCb, finalCb) {
    if (data) {
      data.contractName = selectedContract.name;
      data.linkReferences = selectedContract.bytecodeLinkReferences;
      data.contractABI = selectedContract.abi;
    }

    this.runTx({
      data: data,
      useCall: false
    }, confirmationCb, continueCb, promptCb, (error, txResult, address) => {
      if (error) {
        return finalCb(`creation of ${selectedContract.name} errored: ${error}`);
      }

      if (txResult.result.status && txResult.result.status === '0x0') {
        return finalCb(`creation of ${selectedContract.name} errored: transaction execution failed`);
      }

      finalCb(null, selectedContract, address);
    });
  }

  determineGasPrice(cb) {
    this.getCurrentProvider().getGasPrice((error, gasPrice) => {
      const warnMessage = ' Please fix this issue before sending any transaction. ';

      if (error) {
        return cb('Unable to retrieve the current network gas price.' + warnMessage + error);
      }

      try {
        const gasPriceValue = this.fromWei(gasPrice, false, 'gwei');
        cb(null, gasPriceValue);
      } catch (e) {
        cb(warnMessage + e.message, null, false);
      }
    });
  }

  getInputs(funABI) {
    if (!funABI.inputs) {
      return '';
    }

    return txHelper.inputParametersDeclarationToString(funABI.inputs);
  }

  fromWei(value, doTypeConversion, unit) {
    if (doTypeConversion) {
      return Web3.utils.fromWei(typeConversion.toInt(value), unit || 'ether');
    }

    return Web3.utils.fromWei(value.toString(10), unit || 'ether');
  }

  toWei(value, unit) {
    return Web3.utils.toWei(value, unit || 'gwei');
  }

  calculateFee(gas, gasPrice, unit) {
    return Web3.utils.toBN(gas).mul(Web3.utils.toBN(Web3.utils.toWei(gasPrice.toString(10), unit || 'gwei')));
  }

  determineGasFees(tx) {
    const determineGasFeesCb = (gasPrice, cb) => {
      let txFeeText, priceStatus; // TODO: this try catch feels like an anti pattern, can/should be
      // removed, but for now keeping the original logic

      try {
        const fee = this.calculateFee(tx.gas, gasPrice);
        txFeeText = ' ' + this.fromWei(fee, false, 'ether') + ' Ether';
        priceStatus = true;
      } catch (e) {
        txFeeText = ' Please fix this issue before sending any transaction. ' + e.message;
        priceStatus = false;
      }

      cb(txFeeText, priceStatus);
    };

    return determineGasFeesCb;
  }

  changeExecutionContext(context, confirmCb, infoCb, cb) {
    return this.executionContext.executionContextChange(context, null, confirmCb, infoCb, cb);
  }

  setProviderFromEndpoint(target, context, cb) {
    return this.executionContext.setProviderFromEndpoint(target, context, cb);
  }

  updateNetwork(cb) {
    this.executionContext.detectNetwork((err, {
      id,
      name
    } = {}) => {
      if (err) {
        return cb(err);
      }

      cb(null, {
        id,
        name
      });
    });
  }

  detectNetwork(cb) {
    return this.executionContext.detectNetwork(cb);
  }

  getProvider() {
    return this.executionContext.getProvider();
  }

  isWeb3Provider() {
    const isVM = this.getProvider() === 'vm';
    const isInjected = this.getProvider() === 'injected';
    return !isVM && !isInjected;
  }

  isInjectedWeb3() {
    return this.getProvider() === 'injected';
  }

  signMessage(message, account, passphrase, cb) {
    this.getCurrentProvider().signMessage(message, account, passphrase, cb);
  }

  web3() {
    return this.executionContext.web3();
  }

  getTxListener(opts) {
    opts.event = {
      // udapp: this.udapp.event
      udapp: this.event
    };
    const txlistener = new Txlistener(opts, this.executionContext);
    return txlistener;
  }

  runOrCallContractMethod(contractName, contractAbi, funABI, value, address, callType, lookupOnly, logMsg, logCallback, outputCb, confirmationCb, continueCb, promptCb) {
    // contractsDetails is used to resolve libraries
    txFormat.buildData(contractName, contractAbi, {}, false, funABI, callType, (error, data) => {
      if (error) {
        return logCallback(`${logMsg} errored: ${error} `);
      }

      if (!lookupOnly) {
        logCallback(`${logMsg} pending ... `);
      } else {
        logCallback(`${logMsg}`);
      }

      if (funABI.type === 'fallback') data.dataHex = value;
      const useCall = funABI.stateMutability === 'view' || funABI.stateMutability === 'pure';
      this.runTx({
        to: address,
        data,
        useCall
      }, confirmationCb, continueCb, promptCb, (error, txResult, _address, returnValue) => {
        if (error) {
          return logCallback(`${logMsg} errored: ${error} `);
        }

        if (lookupOnly) {
          outputCb(returnValue);
        }
      });
    }, msg => {
      logCallback(msg);
    }, (data, runTxCallback) => {
      // called for libraries deployment
      this.runTx(data, confirmationCb, runTxCallback, promptCb, () => {});
    });
  }

  context() {
    return this.executionContext.isVM() ? 'memory' : 'blockchain';
  } // NOTE: the config is only needed because exectuionContext.init does
  // if config.get('settings/always-use-vm'), we can simplify this later


  resetAndInit(config, transactionContextAPI) {
    this.transactionContextAPI = transactionContextAPI;
    this.executionContext.init(config);
    this.executionContext.stopListenOnLastBlock();
    this.executionContext.listenOnLastBlock();
    this.resetEnvironment();
  }

  addNetwork(customNetwork) {
    this.executionContext.addProvider(customNetwork);
  }

  removeNetwork(name) {
    this.executionContext.removeProvider(name);
  } // TODO : event should be triggered by Udapp instead of TxListener

  /** Listen on New Transaction. (Cannot be done inside constructor because txlistener doesn't exist yet) */


  startListening(txlistener) {
    txlistener.event.register('newTransaction', tx => {
      this.events.emit('newTransaction', tx);
    });
  }

  resetEnvironment() {
    this.getCurrentProvider().resetEnvironment(); // TODO: most params here can be refactored away in txRunner
    // this.txRunner = new TxRunner(this.providers.vm.accounts, {

    this.txRunner = new TxRunner(this.providers.vm.RemixSimulatorProvider.Accounts.accounts, {
      // TODO: only used to check value of doNotShowTransactionConfirmationAgain property
      config: this.config,
      // TODO: to refactor, TxRunner already has access to executionContext
      detectNetwork: cb => {
        this.executionContext.detectNetwork(cb);
      },
      personalMode: () => {
        return this.getProvider() === 'web3' ? this.config.get('settings/personal-mode') : false;
      }
    }, this.executionContext);
    this.txRunner.event.register('transactionBroadcasted', txhash => {
      this.executionContext.detectNetwork((error, network) => {
        if (error || !network) return;
        this.event.trigger('transactionBroadcasted', [txhash, network.name]);
      });
    });
  }
  /**
   * Create a VM Account
   * @param {{privateKey: string, balance: string}} newAccount The new account to create
   */


  createVMAccount(newAccount) {
    if (this.getProvider() !== 'vm') {
      throw new Error('plugin API does not allow creating a new account through web3 connection. Only vm mode is allowed');
    }

    return this.providers.vm.createVMAccount(newAccount);
  }

  newAccount(_password, passwordPromptCb, cb) {
    return this.getCurrentProvider().newAccount(passwordPromptCb, cb);
  }
  /** Get the balance of an address, and convert wei to ether */


  getBalanceInEther(address, cb) {
    this.getCurrentProvider().getBalanceInEther(address, cb);
  }

  pendingTransactionsCount() {
    return Object.keys(this.txRunner.pendingTxs).length;
  }
  /**
   * This function send a tx only to javascript VM or testnet, will return an error for the mainnet
   * SHOULD BE TAKEN CAREFULLY!
   *
   * @param {Object} tx    - transaction.
   */


  sendTransaction(tx) {
    return new Promise((resolve, reject) => {
      this.executionContext.detectNetwork((error, network) => {
        if (error) return reject(error);

        if (network.name === 'Main' && network.id === '1') {
          return reject(new Error('It is not allowed to make this action against mainnet'));
        }

        this.txRunner.rawRun(tx, (network, tx, gasEstimation, continueTxExecution, cancelCb) => {
          continueTxExecution();
        }, (error, continueTxExecution, cancelCb) => {
          if (error) {
            reject(error);
          } else {
            continueTxExecution();
          }
        }, (okCb, cancelCb) => {
          okCb();
        }, (error, result) => {
          if (error) return reject(error);

          try {
            resolve(resultToRemixTx(result));
          } catch (e) {
            reject(e);
          }
        });
      });
    });
  }

  runTx(args, confirmationCb, continueCb, promptCb, cb) {
    const self = this;
    async.waterfall([function getGasLimit(next) {
      if (self.transactionContextAPI.getGasLimit) {
        return self.transactionContextAPI.getGasLimit(next);
      }

      next(null, 3000000);
    }, function queryValue(gasLimit, next) {
      if (args.value) {
        return next(null, args.value, gasLimit);
      }

      if (args.useCall || !self.transactionContextAPI.getValue) {
        return next(null, 0, gasLimit);
      }

      self.transactionContextAPI.getValue(function (err, value) {
        next(err, value, gasLimit);
      });
    }, function getAccount(value, gasLimit, next) {
      if (args.from) {
        return next(null, args.from, value, gasLimit);
      }

      if (self.transactionContextAPI.getAddress) {
        return self.transactionContextAPI.getAddress(function (err, address) {
          next(err, address, value, gasLimit);
        });
      }

      self.getAccounts(function (err, accounts) {
        let address = accounts[0];
        if (err) return next(err);
        if (!address) return next('No accounts available'); // if (self.executionContext.isVM() && !self.providers.vm.accounts[address]) {

        if (self.executionContext.isVM() && !self.providers.vm.RemixSimulatorProvider.Accounts.accounts[address]) {
          return next('Invalid account selected');
        }

        next(null, address, value, gasLimit);
      });
    }, function runTransaction(fromAddress, value, gasLimit, next) {
      const tx = {
        to: args.to,
        data: args.data.dataHex,
        useCall: args.useCall,
        from: fromAddress,
        value: value,
        gasLimit: gasLimit,
        timestamp: args.data.timestamp
      };
      const payLoad = {
        funAbi: args.data.funAbi,
        funArgs: args.data.funArgs,
        contractBytecode: args.data.contractBytecode,
        contractName: args.data.contractName,
        contractABI: args.data.contractABI,
        linkReferences: args.data.linkReferences
      };
      let timestamp = Date.now();

      if (tx.timestamp) {
        timestamp = tx.timestamp;
      }

      self.event.trigger('initiatingTransaction', [timestamp, tx, payLoad]);
      self.txRunner.rawRun(tx, confirmationCb, continueCb, promptCb, function (error, result) {
        if (error) return next(error);
        const rawAddress = self.executionContext.isVM() ? result.result.createdAddress : result.result.contractAddress;
        let eventName = tx.useCall ? 'callExecuted' : 'transactionExecuted';
        self.event.trigger(eventName, [error, tx.from, tx.to, tx.data, tx.useCall, result, timestamp, payLoad, rawAddress]);

        if (error && typeof error !== 'string') {
          if (error.message) error = error.message;else {
            try {
              error = 'error: ' + JSON.stringify(error);
            } catch (e) {}
          }
        }

        next(error, result);
      });
    }], (error, txResult) => {
      if (error) {
        return cb(error);
      }

      const isVM = this.executionContext.isVM();

      if (isVM) {
        const vmError = txExecution.checkVMError(txResult);

        if (vmError.error) {
          return cb(vmError.message);
        }
      }

      let address = null;
      let returnValue = null;

      if (txResult && txResult.result) {
        address = isVM ? txResult.result.createdAddress : txResult.result.contractAddress; // if it's not the VM, we don't have return value. We only have the transaction, and it does not contain the return value.

        returnValue = txResult.result.execResult && isVM ? txResult.result.execResult.returnValue : txResult.result;
      }

      cb(error, txResult, address, returnValue);
    });
  }

}

module.exports = Blockchain;

/***/ }),

/***/ "./blockchain/pluginUDapp.js":
/*!***********************************!*\
  !*** ./blockchain/pluginUDapp.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const {
  EventEmitter
} = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

class PluginUdapp {
  constructor(blockchain) {
    this.blockchain = blockchain;
    this.events = new EventEmitter();
    this.setupEvents();
  }

  setupEvents() {
    this.blockchain.events.on('newTransaction', (tx, receipt) => {
      this.events.emit('newTransaction', tx, receipt);
    });
  }

  createVMAccount(newAccount) {
    return this.blockchain.createVMAccount(newAccount);
  }

  sendTransaction(tx) {
    return this.blockchain.sendTransaction(tx);
  }

  getAccounts(cb) {
    return this.blockchain.getAccounts(cb);
  }

  pendingTransactionsCount() {
    return this.blockchain.pendingTransactionsCount();
  }

}

module.exports = PluginUdapp;

/***/ }),

/***/ "./blockchain/providers/injected.js":
/*!******************************************!*\
  !*** ./blockchain/providers/injected.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

const {
  stripHexPrefix,
  hashPersonalMessage
} = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

class InjectedProvider {
  constructor(executionContext) {
    this.executionContext = executionContext;
  }

  getAccounts(cb) {
    return this.executionContext.web3().eth.getAccounts(cb);
  }

  newAccount(passwordPromptCb, cb) {
    passwordPromptCb(passphrase => {
      this.executionContext.web3().personal.newAccount(passphrase, cb);
    });
  }

  resetEnvironment() {}

  getBalanceInEther(address, cb) {
    address = stripHexPrefix(address);
    this.executionContext.web3().eth.getBalance(address, (err, res) => {
      if (err) {
        return cb(err);
      }

      cb(null, Web3.utils.fromWei(res.toString(10), 'ether'));
    });
  }

  getGasPrice(cb) {
    this.executionContext.web3().eth.getGasPrice(cb);
  }

  signMessage(message, account, _passphrase, cb) {
    const messageHash = hashPersonalMessage(Buffer.from(message));

    try {
      this.executionContext.web3().eth.sign(message, account, (error, signedData) => {
        cb(error, '0x' + messageHash.toString('hex'), signedData);
      });
    } catch (e) {
      cb(e.message);
    }
  }

  getProvider() {
    return 'injected';
  }

}

module.exports = InjectedProvider;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./blockchain/providers/node.js":
/*!**************************************!*\
  !*** ./blockchain/providers/node.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

const {
  stripHexPrefix,
  hashPersonalMessage
} = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const Personal = __webpack_require__(/*! web3-eth-personal */ "../../../node_modules/web3-eth-personal/src/index.js");

class NodeProvider {
  constructor(executionContext, config) {
    this.executionContext = executionContext;
    this.config = config;
  }

  getAccounts(cb) {
    if (this.config.get('settings/personal-mode')) {
      return this.executionContext.web3().personal.getListAccounts(cb);
    }

    return this.executionContext.web3().eth.getAccounts(cb);
  }

  newAccount(passwordPromptCb, cb) {
    if (!this.config.get('settings/personal-mode')) {
      return cb('Not running in personal mode');
    }

    passwordPromptCb(passphrase => {
      this.executionContext.web3().personal.newAccount(passphrase, cb);
    });
  }

  resetEnvironment() {}

  getBalanceInEther(address, cb) {
    address = stripHexPrefix(address);
    this.executionContext.web3().eth.getBalance(address, (err, res) => {
      if (err) {
        return cb(err);
      }

      cb(null, Web3.utils.fromWei(res.toString(10), 'ether'));
    });
  }

  getGasPrice(cb) {
    this.executionContext.web3().eth.getGasPrice(cb);
  }

  signMessage(message, account, passphrase, cb) {
    const messageHash = hashPersonalMessage(Buffer.from(message));

    try {
      const personal = new Personal(this.executionContext.web3().currentProvider);
      personal.sign(message, account, passphrase, (error, signedData) => {
        cb(error, '0x' + messageHash.toString('hex'), signedData);
      });
    } catch (e) {
      cb(e.message);
    }
  }

  getProvider() {
    return this.executionContext.getProvider();
  }

}

module.exports = NodeProvider;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./blockchain/providers/vm.js":
/*!************************************!*\
  !*** ./blockchain/providers/vm.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const Web3 = __webpack_require__(/*! web3 */ "../../../node_modules/web3/src/index.js");

const {
  BN,
  privateToAddress,
  stripHexPrefix,
  hashPersonalMessage
} = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

const RemixSimulator = __webpack_require__(/*! @remix-project/remix-simulator */ "../../../dist/libs/remix-simulator/index.js");

class VMProvider {
  constructor(executionContext) {
    this.executionContext = executionContext;
    this.RemixSimulatorProvider = new RemixSimulator.Provider({
      executionContext: this.executionContext
    });
    this.RemixSimulatorProvider.init();
    this.web3 = new Web3(this.RemixSimulatorProvider);
    this.accounts = {};
  }

  getAccounts(cb) {
    this.web3.eth.getAccounts((err, accounts) => {
      if (err) {
        return cb('No accounts?');
      }

      return cb(null, accounts);
    });
  }

  resetEnvironment() {
    this.RemixSimulatorProvider.Accounts.resetAccounts();
    this.accounts = {};
  } // TODO: is still here because of the plugin API
  // can be removed later when we update the API


  createVMAccount(newAccount) {
    const {
      privateKey,
      balance
    } = newAccount;

    this.RemixSimulatorProvider.Accounts._addAccount(privateKey, balance);

    const privKey = Buffer.from(privateKey, 'hex');
    return '0x' + privateToAddress(privKey).toString('hex');
  }

  newAccount(_passwordPromptCb, cb) {
    this.RemixSimulatorProvider.Accounts.newAccount(cb);
  }

  getBalanceInEther(address, cb) {
    address = stripHexPrefix(address);
    this.web3.eth.getBalance(address, (err, res) => {
      if (err) {
        return cb(err);
      }

      cb(null, Web3.utils.fromWei(new BN(res).toString(10), 'ether'));
    });
  }

  getGasPrice(cb) {
    this.web3.eth.getGasPrice(cb);
  }

  signMessage(message, account, _passphrase, cb) {
    const messageHash = hashPersonalMessage(Buffer.from(message));
    this.web3.eth.sign(message, account, (error, signedData) => {
      if (error) {
        return cb(error);
      }

      cb(null, '0x' + messageHash.toString('hex'), signedData);
    });
  }

  getProvider() {
    return 'vm';
  }

}

module.exports = VMProvider;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./blockchain/txResultHelper.js":
/*!**************************************!*\
  !*** ./blockchain/txResultHelper.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

const {
  bufferToHex,
  isHexString
} = __webpack_require__(/*! ethereumjs-util */ "../../../node_modules/ethereumjs-util/dist/index.js");

function convertToPrefixedHex(input) {
  if (input === undefined || input === null || isHexString(input)) {
    return input;
  } else if (Buffer.isBuffer(input)) {
    return bufferToHex(input);
  }

  return '0x' + input.toString(16);
}
/*
 txResult.result can be 3 different things:
 - VM call or tx: ethereumjs-vm result object
 - Node transaction: object returned from eth.getTransactionReceipt()
 - Node call: return value from function call (not an object)

 Also, VM results use BN and Buffers, Node results use hex strings/ints,
 So we need to normalize the values to prefixed hex strings
*/


function resultToRemixTx(txResult) {
  const {
    result,
    transactionHash
  } = txResult;
  const {
    status,
    execResult,
    gasUsed,
    createdAddress,
    contractAddress
  } = result;
  let returnValue, errorMessage;

  if (isHexString(result)) {
    returnValue = result;
  } else if (execResult !== undefined) {
    returnValue = execResult.returnValue;
    errorMessage = execResult.exceptionError;
  }

  return {
    transactionHash,
    status,
    gasUsed: convertToPrefixedHex(gasUsed),
    error: errorMessage,
    return: convertToPrefixedHex(returnValue),
    createdAddress: convertToPrefixedHex(createdAddress || contractAddress)
  };
}

module.exports = {
  resultToRemixTx
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "../../../node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./config.js":
/*!*******************!*\
  !*** ./config.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CONFIG_FILE = '.remix.config';

const EventEmitter = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

function Config(storage) {
  this.items = {};
  this.unpersistedItems = {};
  this.events = new EventEmitter(); // load on instantiation

  try {
    var config = storage.get(CONFIG_FILE);

    if (config) {
      this.items = JSON.parse(config);
    }
  } catch (exception) {}

  this.exists = function (key) {
    return this.items[key] !== undefined;
  };

  this.get = function (key) {
    this.ensureStorageUpdated(key);
    return this.items[key];
  };

  this.set = function (key, content) {
    this.items[key] = content;

    try {
      storage.set(CONFIG_FILE, JSON.stringify(this.items));
      this.events.emit(key + '_changed', content);
    } catch (exception) {}
  };

  this.ensureStorageUpdated = function (key) {
    if (key === 'currentFile') {
      if (this.items[key] && this.items[key] !== '' && this.items[key].indexOf('config/') !== 0 && this.items[key].indexOf('browser/') !== 0 && this.items[key].indexOf('localhost/') !== 0 && this.items[key].indexOf('swarm/') !== 0 && this.items[key].indexOf('gist/') !== 0 && this.items[key].indexOf('github/') !== 0 && this.items[key].indexOf('ipfs/') !== 0 && this.items[key].indexOf('http/') !== 0 && this.items[key].indexOf('https/') !== 0) {
        this.items[key] = 'browser/' + this.items[key];
      }
    }
  };

  this.getUnpersistedProperty = function (key) {
    return this.unpersistedItems[key];
  }; // TODO: this only used for *one* property "doNotShowTransactionConfirmationAgain"
  // and can be removed once it's refactored away in txRunner


  this.setUnpersistedProperty = function (key, value) {
    this.unpersistedItems[key] = value;
  };
}

module.exports = Config;

/***/ }),

/***/ "./framingService.js":
/*!***************************!*\
  !*** ./framingService.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FramingService = void 0;

class FramingService {
  constructor(sidePanel, verticalIcon, mainView, resizeFeature) {
    this.sidePanel = sidePanel;
    this.verticalIcon = verticalIcon;
    this.mainPanel = mainView.getAppPanel();
    this.mainView = mainView;
    this.resizeFeature = resizeFeature;
  }

  start(params) {
    this.sidePanel.events.on('toggle', () => {
      this.resizeFeature.panel.clientWidth !== 0 ? this.resizeFeature.hidePanel() : this.resizeFeature.showPanel();
    });
    this.sidePanel.events.on('showing', () => {
      this.resizeFeature.panel.clientWidth === 0 ? this.resizeFeature.showPanel() : '';
    });
    this.mainPanel.events.on('toggle', () => {
      this.resizeFeature.showPanel();
    });
    this.verticalIcon.select('fileExplorers');
    document.addEventListener('keypress', e => {
      if (e.shiftKey && e.ctrlKey) {
        if (e.code === 'KeyF') {
          // Ctrl+Shift+F
          this.verticalIcon.select('fileExplorers');
        } else if (e.code === 'KeyA') {
          // Ctrl+Shift+A
          this.verticalIcon.select('pluginManager');
        } else if (e.code === 'KeyS') {
          //  Ctrl+Shift+S
          this.verticalIcon.select('settings');
        }

        e.preventDefault();
      }
    });
    if (params.minimizeterminal) this.mainView.minimizeTerminal();
    if (params.minimizesidepanel) this.resizeFeature.hidePanel();
  }

  embed() {
    this.mainView.minimizeTerminal();
    this.resizeFeature.hidePanel();
  }

}

exports.FramingService = FramingService;

/***/ }),

/***/ "./global/registry.js":
/*!****************************!*\
  !*** ./global/registry.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = new (__webpack_require__(/*! ../registry.js */ "./registry.js"))();

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // require('@babel/polyfill')

var App = __webpack_require__(/*! ./app.js */ "./app.js");

var app = new App({});
document.body.appendChild(app.render());
app.init(); // @TODO: refactor to remove

/***/ }),

/***/ "./lib/cmdInterpreterAPI.js":
/*!**********************************!*\
  !*** ./lib/cmdInterpreterAPI.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var EventManager = __webpack_require__(/*! ../lib/events */ "./lib/events.js");

var CompilerImport = __webpack_require__(/*! ../app/compiler/compiler-imports */ "./app/compiler/compiler-imports.js");

var toolTip = __webpack_require__(/*! ../app/ui/tooltip */ "./app/ui/tooltip.js");

var globalRegistry = __webpack_require__(/*! ../global/registry */ "./global/registry.js");

var SourceHighlighter = __webpack_require__(/*! ../app/editor/sourceHighlighter */ "./app/editor/sourceHighlighter.js");

var RemixDebug = __webpack_require__(/*! @remix-project/remix-debug */ "../../../dist/libs/remix-debug/index.js").EthDebugger;

var TreeView = __webpack_require__(/*! ../app/ui/TreeView */ "./app/ui/TreeView.js"); // TODO setup a direct reference to the UI components


var solidityTypeFormatter = __webpack_require__(/*! ../app/tabs/debugger/debuggerUI/vmDebugger/utils/SolidityTypeFormatter */ "./app/tabs/debugger/debuggerUI/vmDebugger/utils/SolidityTypeFormatter.js");

var GistHandler = __webpack_require__(/*! ./gist-handler */ "./lib/gist-handler.js");

class CmdInterpreterAPI {
  constructor(terminal, localRegistry, blockchain) {
    const self = this;
    self.event = new EventManager();
    self.blockchain = blockchain;
    self._components = {};
    self._components.registry = localRegistry || globalRegistry;
    self._components.terminal = terminal;
    self._components.sourceHighlighter = new SourceHighlighter();
    self._components.fileImport = new CompilerImport();
    self._components.gistHandler = new GistHandler();
    self._deps = {
      fileManager: self._components.registry.get('filemanager').api,
      editor: self._components.registry.get('editor').api,
      compilersArtefacts: self._components.registry.get('compilersartefacts').api,
      offsetToLineColumnConverter: self._components.registry.get('offsettolinecolumnconverter').api
    };
    self.commandHelp = {
      'remix.call(message: {name, key, payload})': 'Call a registered plugins',
      'remix.getFile(path)': 'Returns the content of the file located at the given path',
      'remix.setFile(path, content)': 'set the content of the file located at the given path',
      'remix.debug(hash)': 'Start debugging a transaction.',
      'remix.loadgist(id)': 'Load a gist in the file explorer.',
      'remix.loadurl(url)': 'Load the given url in the file explorer. The url can be of type github, swarm, ipfs or raw http',
      'remix.setproviderurl(url)': 'Change the current provider to Web3 provider and set the url endpoint.',
      'remix.execute(filepath)': 'Run the script specified by file path. If filepath is empty, script currently displayed in the editor is executed.',
      'remix.exeCurrent()': 'Run the script currently displayed in the editor',
      'remix.help()': 'Display this help message',
      'remix.debugHelp()': 'Display help message for debugging'
    };
  }

  call(message) {
    return this._components.terminal.externalApi.request(message);
  }

  log() {
    arguments[0] != null ? this._components.terminal.commands.html(arguments[0]) : this._components.terminal.commands.html(arguments[1]);
  }

  highlight(rawLocation) {
    var self = this;

    if (!rawLocation) {
      self._components.sourceHighlighter.currentSourceLocation(null);

      return;
    }

    var lineColumnPos = self._deps.offsetToLineColumnConverter.offsetToLineColumn(rawLocation, rawLocation.file, self._deps.compilersArtefacts['__last'].getSourceCode().sources, self._deps.compilersArtefacts['__last'].getAsts());

    self._components.sourceHighlighter.currentSourceLocation(lineColumnPos, rawLocation);
  }

  debug(hash, cb) {
    var self = this;
    delete self.d;
    self.blockchain.web3().eth.getTransaction(hash, (error, tx) => {
      if (error) return cb(error);
      var debugSession = new RemixDebug({
        compilationResult: () => {
          return self._deps.compilersArtefacts['__last'].getData();
        }
      });
      debugSession.addProvider('web3', self.blockchain.web3());
      debugSession.switchProvider('web3');
      debugSession.debug(tx);
      self.d = debugSession;

      this._components.terminal.commands.log('A new debugging session is available at remix.d');

      if (cb) cb(null, debugSession); // helpers

      self.d.highlight = (address, vmtraceIndex) => {
        if (!address) return self.highlight();
        self.d.sourceLocationFromVMTraceIndex(address, vmtraceIndex, (error, rawLocation) => {
          if (!error && rawLocation) {
            self.highlight(rawLocation);
          }
        });
      };

      self.d.stateAt = vmTraceIndex => {
        self.d.extractStateAt(vmTraceIndex, (error, state) => {
          if (error) return self.log(error);
          self.d.decodeStateAt(vmTraceIndex, state, (error, state) => {
            if (error) return this._components.terminal.commands.html(error);
            var treeView = new TreeView({
              json: true,
              formatSelf: solidityTypeFormatter.formatSelf,
              extractData: solidityTypeFormatter.extractData
            });
            self.log('State at ' + vmTraceIndex);

            self._components.terminal.commands.html(treeView.render(state, true));
          });
        });
      };

      self.d.localsAt = (contractAddress, vmTraceIndex) => {
        debugSession.sourceLocationFromVMTraceIndex(contractAddress, vmTraceIndex, (error, location) => {
          if (error) return self.log(error);
          debugSession.decodeLocalsAt(23, location, (error, locals) => {
            if (error) return this._components.terminal.commands.html(error);
            var treeView = new TreeView({
              json: true,
              formatSelf: solidityTypeFormatter.formatSelf,
              extractData: solidityTypeFormatter.extractData
            });
            self.log('Locals at ' + vmTraceIndex);

            self._components.terminal.commands.html(treeView.render(locals, true));
          });
        });
      };

      self.d.goTo = row => {
        if (self._deps.editor.current()) {
          var breakPoint = new remixLib.code.BreakpointManager(self.d, sourceLocation => {
            return self._deps.offsetToLineColumnConverter.offsetToLineColumn(sourceLocation, sourceLocation.file, self._deps.compilersArtefacts['__last'].getSourceCode().sources, self._deps.compilersArtefacts['__last'].getAsts());
          });
          breakPoint.event.register('breakpointHit', (sourceLocation, currentStep) => {
            self.log(null, 'step index ' + currentStep);
            self.highlight(sourceLocation);
            self.d.stateAt(currentStep);
            self.d.traceManager.getCurrentCalledAddressAt(currentStep, (error, address) => {
              if (error) return self.log(address);
              self.d.localsAt(address, currentStep);
            });
          });
          breakPoint.event.register('NoBreakpointHit', () => {
            self.log('line ' + row + ' is not part of the current execution');
          });
          breakPoint.add({
            fileName: self._deps.editor.current(),
            row: row - 1
          });
          breakPoint.jumpNextBreakpoint(0, true);
        }
      };
    });
  }

  loadgist(id, cb) {
    const self = this;

    self._components.gistHandler.loadFromGist({
      gist: id
    }, this._deps.fileManager);

    if (cb) cb();
  }

  loadurl(url, cb) {
    const self = this;

    self._components.fileImport.import(url, loadingMsg => {
      toolTip(loadingMsg);
    }, (err, content, cleanUrl, type, url) => {
      if (err) {
        toolTip(`Unable to load ${url}: ${err}`);
        if (cb) cb(err);
      } else {
        self._deps.fileManager.writeFile(type + '/' + cleanUrl, content);

        try {
          content = JSON.parse(content);
          async.eachOfSeries(content.sources, (value, file, callbackSource) => {
            var url = value.urls[0]; // @TODO retrieve all other contents ?

            self._components.fileImport.import(url, loadingMsg => {
              toolTip(loadingMsg);
            }, async (error, content, cleanUrl, type, url) => {
              if (error) {
                toolTip(`Cannot retrieve the content of ${url}: ${error}`);
                return callbackSource(`Cannot retrieve the content of ${url}: ${error}`);
              } else {
                try {
                  await self._deps.fileManager.writeFile(type + '/' + cleanUrl, content);
                  callbackSource();
                } catch (e) {
                  callbackSource(e.message);
                }
              }
            });
          }, error => {
            if (cb) cb(error);
          });
        } catch (e) {}

        if (cb) cb();
      }
    });
  }

  setproviderurl(url, cb) {
    this.blockchain.setProviderFromEndpoint(url, 'web3', error => {
      if (error) toolTip(error);
      if (cb) cb();
    });
  }

  exeCurrent(cb) {
    return this.execute(undefined, cb);
  }

  getFile(path, cb) {
    var provider = this._deps.fileManager.fileProviderOf(path);

    if (provider) {
      provider.get(path, cb);
    } else {
      cb('file not found');
    }
  }

  setFile(path, content, cb) {
    cb = cb || function () {};

    var provider = this._deps.fileManager.fileProviderOf(path);

    if (provider) {
      provider.set(path, content, error => {
        if (error) return cb(error);

        this._deps.fileManager.syncEditor(path);

        cb();
      });
    } else {
      cb('file not found');
    }
  }

  execute(file, cb) {
    const self = this;

    function _execute(content, cb) {
      if (!content) {
        toolTip('no content to execute');
        if (cb) cb();
        return;
      }

      self._components.terminal.commands.script(content);
    }

    if (typeof file === 'undefined') {
      var content = self._deps.editor.currentContent();

      _execute(content, cb);

      return;
    }

    var provider = self._deps.fileManager.fileProviderOf(file);

    if (!provider) {
      toolTip(`provider for path ${file} not found`);
      if (cb) cb();
      return;
    }

    provider.get(file, (error, content) => {
      if (error) {
        toolTip(error);
        if (cb) cb();
        return;
      }

      _execute(content, cb);
    });
  }

  help(cb) {
    const self = this;
    var help = yo`<div></div>`;

    for (var k in self.commandHelp) {
      help.appendChild(yo`<div>${k}: ${self.commandHelp[k]}</div>`);
      help.appendChild(yo`<br>`);
    }

    self._components.terminal.commands.html(help);

    if (cb) cb();
    return '';
  }

  debugHelp(cb) {
    const self = this;
    var help = yo`<div>Here are some examples of scripts that can be run (using remix.exeCurrent() or directly from the console)</div>`;
    help.appendChild(yo`<br>`);
    help.appendChild(yo`<br>`);
    help.appendChild(yo`<div>remix.debug('0x3c247ac268afb9a9c183feb9d4e83df51efbc8a2f4624c740789b788dac43029', function (error, debugSession) {
     remix.log = function () { arguments[0] != null ? console.log(arguments[0]) : console.log(arguments[1]) }

     remix.d.traceManager.getLength(remix.log)
     remix.storageView = remix.d.storageViewAt(97, '0x692a70d2e424a56d2c6c27aa97d1a86395877b3a')
     console.log('storage at 97 :')
     remix.storageView.storageRange(remix.log)
})<br/></div>`);
    help.appendChild(yo`<div>remix.log = function () { arguments[0] != null ? console.log(arguments[0]) : console.log(arguments[1]) }
    remix.d.extractStateAt(2, function (error, state) {
        remix.d.decodeStateAt(97, state, remix.log)
    })<br/></div>`);
    help.appendChild(yo`<br>`);
    help.appendChild(yo`<div>remix.highlight(contractAddress, vmTraceIndex)</div>`);
    help.appendChild(yo`<br>`);
    help.appendChild(yo`<div>remix.goTo(row) (this log the index in the vm trace, state and local variables)</div>`);
    help.appendChild(yo`<br>`);
    help.appendChild(yo`<div>remix.stateAt(vmTraceIndex)</div>`);
    help.appendChild(yo`<br>`);
    help.appendChild(yo`<div>remix.localsAt(vmTraceIndex)</div>`);
    help.appendChild(yo`<br>`);
    help.appendChild(yo`<div>Please see <a href="https://www.npmjs.com/package/remix-debug" target="_blank">https://www.npmjs.com/package/remix-debug</a> for more informations</div>`);

    self._components.terminal.commands.html(help);

    if (cb) cb();
    return '';
  }

}

module.exports = CmdInterpreterAPI;

/***/ }),

/***/ "./lib/commands.js":
/*!*************************!*\
  !*** ./lib/commands.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const allPrograms = [{
  'ethers': 'The ethers.js library is a compact and complete JavaScript library for Ethereum.'
}, {
  'remix': 'Ethereum IDE and tools for the web.'
}, {
  'web3': 'The web3.js library is a collection of modules which contain specific functionality for the ethereum ecosystem.'
}, {
  'swarmgw': 'This library can be used to upload/download files to Swarm via https://swarm-gateways.net/.'
}];
const allCommands = [{
  'remix.debug(hash)': 'Start debugging a transaction.'
}, {
  'remix.debugHelp()': 'Display help message for debugging'
}, {
  'remix.execute(filepath)': 'Run the script specified by file path. If filepath is empty, script currently displayed in the editor is executed.'
}, {
  'remix.exeCurrent()': 'Run the script currently displayed in the editor.'
}, {
  'remix.getFile(path)': 'Returns the content of the file located at the given path'
}, {
  'remix.help()': 'Display this help message.'
}, {
  'remix.loadgist(id)': 'Load a gist in the file explorer.'
}, {
  'remix.loadurl(url)': 'Load the given url in the file explorer. The url can be of type github, swarm or ipfs.'
}, {
  'remix.setFile(path, content)': 'set the content of the file located at the given path'
}, {
  'remix.setproviderurl(url)': 'Change the current provider to Web3 provider and set the url endpoint.'
}, {
  'swarmgw.get(url, cb)': 'Download files from Swarm via https://swarm-gateways.net/'
}, {
  'swarmgw.put(content, cb)': 'Upload files to Swarm via https://swarm-gateways.net/'
}, {
  'ethers.Contract': 'This API provides a graceful connection to a contract deployed on the blockchain, simplifying calling and querying its functions and handling all the binary protocol and conversion as necessarily.'
}, {
  'ethers.HDNode': 'A Hierarchical Deterministic Wallet represents a large tree of private keys which can reliably be reproduced from an initial seed.'
}, {
  'ethers.Interface': 'The Interface Object is a meta-class that accepts a Solidity (or compatible) Application Binary Interface (ABI) and populates functions to deal with encoding and decoding the parameters to pass in and results returned.'
}, {
  'ethers.providers': 'A Provider abstracts a connection to the Ethereum blockchain, for issuing queries and sending state changing transactions.'
}, {
  'ethers.SigningKey': 'The SigningKey interface provides an abstraction around the secp256k1 elliptic curve cryptography library.'
}, {
  'ethers.utils': 'The utility functions exposed in both the ethers umbrella package and the ethers-utils.'
}, {
  'ethers.utils.AbiCoder': 'Create a new ABI Coder object'
}, {
  'ethers.utils.RLP': 'This encoding method is used internally for several aspects of Ethereum, such as encoding transactions and determining contract addresses.'
}, {
  'ethers.Wallet': 'A wallet manages a private/public key pair which is used to cryptographically sign transactions and prove ownership on the Ethereum network.'
}, {
  'ethers.version': 'Contains the version of the ethers container object.'
}, {
  'web3.bzz': 'Bzz module for interacting with the swarm network.'
}, {
  'web3.eth': 'Eth module for interacting with the Ethereum network.'
}, {
  'web3.eth.accounts': 'The web3.eth.accounts contains functions to generate Ethereum accounts and sign transactions and data.'
}, {
  'web3.eth.abi': 'The web3.eth.abi functions let you de- and encode parameters to ABI (Application Binary Interface) for function calls to the EVM (Ethereum Virtual Machine).'
}, {
  'web3.eth.ens': 'The web3.eth.ens functions let you interacting with ENS.'
}, {
  'web3.eth.Iban': 'The web3.eth.Iban function lets convert Ethereum addresses from and to IBAN and BBAN.'
}, {
  'web3.eth.net': 'Net module for interacting with network properties.'
}, {
  'web3.eth.personal': 'Personal module for interacting with the Ethereum accounts.'
}, {
  'web3.eth.subscribe': 'The web3.eth.subscribe function lets you subscribe to specific events in the blockchain.'
}, {
  'web3.givenProvider': 'When using web3.js in an Ethereum compatible browser, it will set with the current native provider by that browser. Will return the given provider by the (browser) environment, otherwise null.'
}, {
  'web3.modules': 'Contains the version of the web3 container object.'
}, {
  'web3.providers': 'Contains the current available providers.'
}, {
  'web3.shh': 'Shh module for interacting with the whisper protocol'
}, {
  'web3.utils': 'This package provides utility functions for Ethereum dapps and other web3.js packages.'
}, {
  'web3.version': 'Contains the version of the web3 container object.'
}, {
  'web3.eth.clearSubscriptions();': 'Resets subscriptions.'
}, {
  'web3.eth.Contract(jsonInterface[, address][, options])': 'The web3.eth.Contract object makes it easy to interact with smart contracts on the ethereum blockchain.'
}, {
  'web3.eth.accounts.create([entropy]);': 'The web3.eth.accounts contains functions to generate Ethereum accounts and sign transactions and data.'
}];
module.exports = {
  allPrograms,
  allCommands
};

/***/ }),

/***/ "./lib/events.js":
/*!***********************!*\
  !*** ./lib/events.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

var EventManager = remixLib.EventManager;
module.exports = EventManager;

/***/ }),

/***/ "./lib/gist-handler.js":
/*!*****************************!*\
  !*** ./lib/gist-handler.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var modalDialogCustom = __webpack_require__(/*! ../app/ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

var request = __webpack_require__(/*! request */ "../../../node_modules/request/index.js"); // Allowing window to be overriden for testing


function GistHandler(_window) {
  if (_window !== undefined) {
    modalDialogCustom = _window;
  }

  this.handleLoad = function (params, cb) {
    if (!cb) cb = () => {};
    var loadingFromGist = false;
    var gistId;

    if (params['gist'] === '') {
      loadingFromGist = true;
      modalDialogCustom.prompt('Load a Gist', 'Enter the ID of the Gist or URL you would like to load.', null, target => {
        if (target !== '') {
          gistId = getGistId(target);

          if (gistId) {
            cb(gistId);
          } else {
            modalDialogCustom.alert('Error while loading gist. Please provide a valid Gist ID or URL.');
          }
        }
      });
      return loadingFromGist;
    } else {
      gistId = params['gist'];
      loadingFromGist = !!gistId;
    }

    if (loadingFromGist) {
      cb(gistId);
    }

    return loadingFromGist;
  };

  function getGistId(str) {
    var idr = /[0-9A-Fa-f]{8,}/;
    var match = idr.exec(str);
    return match ? match[0] : null;
  }

  this.loadFromGist = (params, fileManager) => {
    const gistProvider = fileManager.fileProviderOf('browser');
    const self = this;
    return self.handleLoad(params, function (gistId) {
      request.get({
        url: `https://api.github.com/gists/${gistId}`,
        json: true
      }, (error, response, data = {}) => {
        if (error || !data.files) {
          modalDialogCustom.alert(`Gist load error: ${error || data.message}`);
          return;
        }

        let obj = {};
        Object.keys(data.files).forEach(element => {
          obj['/gists/' + gistId + '/' + element] = data.files[element];
        });
        fileManager.setBatchFiles(obj, 'browser', true, errorLoadingFile => {
          if (!errorLoadingFile) {
            gistProvider.id = gistId;
            gistProvider.origGistFiles = data.files;
          }
        });
      });
    });
  };
}

module.exports = GistHandler;

/***/ }),

/***/ "./lib/helper.js":
/*!***********************!*\
  !*** ./lib/helper.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

module.exports = {
  shortenAddress: function (address, etherBalance) {
    var len = address.length;
    return address.slice(0, 5) + '...' + address.slice(len - 5, len) + (etherBalance ? ' (' + etherBalance.toString() + ' ether)' : '');
  },
  shortenHexData: function (data) {
    if (!data) return '';
    if (data.length < 5) return data;
    var len = data.length;
    return data.slice(0, 5) + '...' + data.slice(len - 5, len);
  },

  createNonClashingNameWithPrefix(name, fileProvider, prefix, cb) {
    if (!name) name = 'Undefined';
    var counter = '';
    var ext = 'sol';
    var reg = /(.*)\.([^.]+)/g;
    var split = reg.exec(name);

    if (split) {
      name = split[1];
      ext = split[2];
    }

    var exist = true;
    async.whilst(() => {
      return exist;
    }, callback => {
      fileProvider.exists(name + counter + prefix + '.' + ext, (error, currentExist) => {
        if (error) {
          callback(error);
        } else {
          exist = currentExist;
          if (exist) counter = (counter | 0) + 1;
          callback();
        }
      });
    }, error => {
      cb(error, name + counter + prefix + '.' + ext);
    });
  },

  createNonClashingName(name, fileProvider, cb) {
    this.createNonClashingNameWithPrefix(name, fileProvider, '', cb);
  },

  checkSpecialChars(name) {
    return name.match(/[:*?"<>\\'|]/) != null;
  },

  isHexadecimal(value) {
    return /^[0-9a-fA-F]+$/.test(value) && value.length % 2 === 0;
  },

  is0XPrefixed(value) {
    return value.substr(0, 2) === '0x';
  },

  isNumeric(value) {
    return /^\+?(0|[1-9]\d*)$/.test(value);
  },

  find: find
};

function findDeep(object, fn, found = {
  break: false,
  value: undefined
}) {
  if (typeof object !== 'object' || object === null) return;

  for (var i in object) {
    if (found.break) break;
    var el = object[i];
    if (el && el.innerText !== undefined && el.innerText !== null) el = el.innerText;

    if (fn(el, i, object)) {
      found.value = el;
      found.break = true;
      break;
    } else {
      findDeep(el, fn, found);
    }
  }

  return found.value;
}

function find(args, query) {
  query = query.trim();
  var isMatch = !!findDeep(args, function check(value, key) {
    if (value === undefined || value === null) return false;
    if (typeof value === 'function') return false;
    if (typeof value === 'object') return false;
    var contains = String(value).indexOf(query.trim()) !== -1;
    return contains;
  });
  return isMatch;
}

/***/ }),

/***/ "./lib/offsetToLineColumnConverter.js":
/*!********************************************!*\
  !*** ./lib/offsetToLineColumnConverter.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OffsetToLineColumnConverter = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var packageJson = _interopRequireWildcard(__webpack_require__(/*! ../../../../package.json */ "../../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const SourceMappingDecoder = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js").SourceMappingDecoder;

const profile = {
  name: 'offsetToLineColumnConverter',
  methods: [],
  events: [],
  version: packageJson.version
};

class OffsetToLineColumnConverter extends _engine.Plugin {
  constructor() {
    super(profile);
    this.lineBreakPositionsByContent = {};
    this.sourceMappingDecoder = new SourceMappingDecoder();
  }

  offsetToLineColumn(rawLocation, file, sources, asts) {
    if (!this.lineBreakPositionsByContent[file]) {
      const sourcesArray = Object.keys(sources);

      if (!asts && file === 0 && sourcesArray.length === 1) {
        // if we don't have ast, we process the only one available content
        this.lineBreakPositionsByContent[file] = this.sourceMappingDecoder.getLinebreakPositions(sources[sourcesArray[0]].content);
      } else {
        for (var filename in asts) {
          const source = asts[filename];

          if (source.id === file) {
            this.lineBreakPositionsByContent[file] = this.sourceMappingDecoder.getLinebreakPositions(sources[filename].content);
            break;
          }
        }
      }
    }

    return this.sourceMappingDecoder.convertOffsetToLineColumn(rawLocation, this.lineBreakPositionsByContent[file]);
  }

  clear() {
    this.lineBreakPositionsByContent = {};
  }

  activate() {
    this.on('solidity', 'compilationFinished', () => {
      this.clear();
    });
  }

}

exports.OffsetToLineColumnConverter = OffsetToLineColumnConverter;

/***/ }),

/***/ "./lib/panels-resize.js":
/*!******************************!*\
  !*** ./lib/panels-resize.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

const css = csjs`
  .dragbar            {
    width             : 2px;
    height            : 100%;
    cursor            : col-resize;
    z-index           : 999;
  }
  .ghostbar           {
    width             : 3px;
    background-color  : var(--primary);
    opacity           : 0.5;
    position          : absolute;
    cursor            : col-resize;
    z-index           : 9999;
    top               : 0;
    bottom            : 0;
  }
`;

class PanelsResize {
  constructor(panel) {
    this.panel = panel;
    const string = panel.style.minWidth;
    this.minWidth = string.length > 2 ? parseInt(string.substring(0, string.length - 2)) : 0;
  }

  render() {
    this.ghostbar = yo`<div class=${css.ghostbar}></div>`;

    const mousedown = event => {
      event.preventDefault();

      if (event.which === 1) {
        moveGhostbar(event);
        document.body.appendChild(this.ghostbar);
        document.addEventListener('mousemove', moveGhostbar);
        document.addEventListener('mouseup', removeGhostbar);
        document.addEventListener('keydown', cancelGhostbar);
      }
    };

    const cancelGhostbar = event => {
      if (event.keyCode === 27) {
        document.body.removeChild(this.ghostbar);
        document.removeEventListener('mousemove', moveGhostbar);
        document.removeEventListener('mouseup', removeGhostbar);
        document.removeEventListener('keydown', cancelGhostbar);
      }
    };

    const moveGhostbar = event => {
      this.ghostbar.style.left = event.x + 'px';
    };

    const removeGhostbar = event => {
      document.body.removeChild(this.ghostbar);
      document.removeEventListener('mousemove', moveGhostbar);
      document.removeEventListener('mouseup', removeGhostbar);
      document.removeEventListener('keydown', cancelGhostbar);
      this.setPosition(event);
    };

    return yo`<div onmousedown=${mousedown} class=${css.dragbar}></div>`;
  }

  calculatePanelWidth(event) {
    return event.x - this.panel.offsetLeft;
  }

  setPosition(event) {
    const panelWidth = this.calculatePanelWidth(event); // close the panel if the width is less than a minWidth

    if (panelWidth > this.minWidth - 10 || this.panel.style.display === 'none') {
      this.panel.style.width = panelWidth + 'px';
      this.showPanel();
    } else this.hidePanel();
  }

  hidePanel() {
    this.panel.style.display = 'none';
  }

  showPanel() {
    this.panel.style.display = 'flex';
  }

}

exports.default = PanelsResize;

/***/ }),

/***/ "./lib/publishOnIpfs.js":
/*!******************************!*\
  !*** ./lib/publishOnIpfs.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

const IpfsClient = __webpack_require__(/*! ipfs-mini */ "../../../node_modules/ipfs-mini/src/index.js");

const ipfsNodes = [new IpfsClient({
  host: 'ipfs.komputing.org',
  port: 443,
  protocol: 'https'
}), new IpfsClient({
  host: 'ipfs.infura.io',
  port: 5001,
  protocol: 'https'
}), new IpfsClient({
  host: '127.0.0.1',
  port: 5001,
  protocol: 'http'
})];

module.exports = (contract, fileManager, cb, ipfsVerifiedPublishCallBack) => {
  // gather list of files to publish
  var sources = [];
  var metadata;

  try {
    metadata = JSON.parse(contract.metadata);
  } catch (e) {
    return cb(e);
  }

  if (metadata === undefined) {
    return cb('No metadata');
  }

  async.eachSeries(Object.keys(metadata.sources), function (fileName, cb) {
    // find hash
    let hash = null;

    try {
      // we try extract the hash defined in the metadata.json
      // in order to check if the hash that we get after publishing is the same as the one located in metadata.json
      // if it's not the same, we throw "hash mismatch between solidity bytecode and uploaded content"
      // if we don't find the hash in the metadata.json, the check is not done.
      //
      // TODO: refactor this with publishOnSwarm
      if (metadata.sources[fileName].urls) {
        metadata.sources[fileName].urls.forEach(url => {
          if (url.includes('ipfs')) hash = url.match('dweb:/ipfs/(.+)')[1];
        });
      }
    } catch (e) {
      return cb('Error while extracting the hash from metadata.json');
    }

    fileManager.fileProviderOf(fileName).get(fileName, (error, content) => {
      if (error) {
        console.log(error);
      } else {
        sources.push({
          content: content,
          hash: hash,
          filename: fileName
        });
      }

      cb();
    });
  }, function (error) {
    if (error) {
      cb(error);
    } else {
      // publish the list of sources in order, fail if any failed
      var uploaded = [];
      async.eachSeries(sources, function (item, cb) {
        ipfsVerifiedPublish(item.content, item.hash, (error, result) => {
          try {
            item.hash = result.url.match('dweb:/ipfs/(.+)')[1];
          } catch (e) {
            item.hash = '<Metadata inconsistency> - ' + item.fileName;
          }

          if (!error && ipfsVerifiedPublishCallBack) ipfsVerifiedPublishCallBack(item);
          item.output = result;
          uploaded.push(item);
          cb(error);
        });
      }, () => {
        const metadataContent = JSON.stringify(metadata);
        ipfsVerifiedPublish(metadataContent, '', (error, result) => {
          try {
            contract.metadataHash = result.url.match('dweb:/ipfs/(.+)')[1];
          } catch (e) {
            contract.metadataHash = '<Metadata inconsistency> - metadata.json';
          }

          if (!error && ipfsVerifiedPublishCallBack) {
            ipfsVerifiedPublishCallBack({
              content: metadataContent,
              hash: contract.metadataHash
            });
          }

          uploaded.push({
            content: contract.metadata,
            hash: contract.metadataHash,
            filename: 'metadata.json',
            output: result
          });
          cb(error, uploaded);
        });
      });
    }
  });
};

async function ipfsVerifiedPublish(content, expectedHash, cb) {
  try {
    const results = await severalGatewaysPush(content);

    if (expectedHash && results !== expectedHash) {
      cb(null, {
        message: 'hash mismatch between solidity bytecode and uploaded content.',
        url: 'dweb:/ipfs/' + results,
        hash: results
      });
    } else {
      cb(null, {
        message: 'ok',
        url: 'dweb:/ipfs/' + results,
        hash: results
      });
    }
  } catch (error) {
    cb(error);
  }
}

function severalGatewaysPush(content) {
  const invert = p => new Promise((resolve, reject) => p.then(reject).catch(resolve)); // Invert res and rej


  const promises = ipfsNodes.map(node => invert(node.add(content)));
  return invert(Promise.all(promises));
}

/***/ }),

/***/ "./lib/publishOnSwarm.js":
/*!*******************************!*\
  !*** ./lib/publishOnSwarm.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var async = __webpack_require__(/*! async */ "../../../node_modules/async/dist/async.js");

var swarmgw = __webpack_require__(/*! swarmgw */ "../../../node_modules/swarmgw/index.js")();

module.exports = (contract, fileManager, cb, swarmVerifiedPublishCallBack) => {
  // gather list of files to publish
  var sources = [];
  var metadata;

  try {
    metadata = JSON.parse(contract.metadata);
  } catch (e) {
    return cb(e);
  }

  if (metadata === undefined) {
    return cb('No metadata');
  }

  async.eachSeries(Object.keys(metadata.sources), function (fileName, cb) {
    // find hash
    let hash = null;

    try {
      // we try extract the hash defined in the metadata.json
      // in order to check if the hash that we get after publishing is the same as the one located in metadata.json
      // if it's not the same, we throw "hash mismatch between solidity bytecode and uploaded content"
      // if we don't find the hash in the metadata.json, the check is not done.
      //
      // TODO: refactor this with publishOnIpfs
      if (metadata.sources[fileName].urls) {
        metadata.sources[fileName].urls.forEach(url => {
          if (url.includes('bzz')) hash = url.match('(bzzr|bzz-raw)://(.+)')[1];
        });
      }
    } catch (e) {
      return cb('Error while extracting the hash from metadata.json');
    }

    fileManager.fileProviderOf(fileName).get(fileName, (error, content) => {
      if (error) {
        console.log(error);
      } else {
        sources.push({
          content: content,
          hash: hash,
          filename: fileName
        });
      }

      cb();
    });
  }, function (error) {
    if (error) {
      cb(error);
    } else {
      // publish the list of sources in order, fail if any failed
      var uploaded = [];
      async.eachSeries(sources, function (item, cb) {
        swarmVerifiedPublish(item.content, item.hash, (error, result) => {
          try {
            item.hash = result.url.match('bzz-raw://(.+)')[1];
          } catch (e) {
            item.hash = '<Metadata inconsistency> - ' + item.fileName;
          }

          if (!error && swarmVerifiedPublishCallBack) swarmVerifiedPublishCallBack(item);
          item.output = result;
          uploaded.push(item); // TODO this is a fix cause Solidity metadata does not contain the right swarm hash (poc 0.3)

          metadata.sources[item.filename].urls[0] = result.url;
          cb(error);
        });
      }, () => {
        const metadataContent = JSON.stringify(metadata);
        swarmVerifiedPublish(metadataContent, '', (error, result) => {
          try {
            contract.metadataHash = result.url.match('bzz-raw://(.+)')[1];
          } catch (e) {
            contract.metadataHash = '<Metadata inconsistency> - metadata.json';
          }

          if (!error && swarmVerifiedPublishCallBack) {
            swarmVerifiedPublishCallBack({
              content: metadataContent,
              hash: contract.metadataHash
            });
          }

          uploaded.push({
            content: contract.metadata,
            hash: contract.metadataHash,
            filename: 'metadata.json',
            output: result
          });
          cb(error, uploaded);
        });
      });
    }
  });
};

function swarmVerifiedPublish(content, expectedHash, cb) {
  swarmgw.put(content, function (err, ret) {
    if (err) {
      cb(err);
    } else if (expectedHash && ret !== expectedHash) {
      cb(null, {
        message: 'hash mismatch between solidity bytecode and uploaded content.',
        url: 'bzz-raw://' + ret,
        hash: ret
      });
    } else {
      cb(null, {
        message: 'ok',
        url: 'bzz-raw://' + ret,
        hash: ret
      });
    }
  });
}

/***/ }),

/***/ "./lib/query-params.js":
/*!*****************************!*\
  !*** ./lib/query-params.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Allowing window to be overriden for testing

function QueryParams(_window) {
  if (_window === undefined) _window = window;

  this.get = function () {
    var qs = _window.location.hash.substr(1);

    if (_window.location.search.length > 0) {
      // use legacy query params instead of hash
      _window.location.hash = _window.location.search.substr(1);
      _window.location.search = '';
    }

    var params = {};
    var parts = qs.split('&');

    for (var x in parts) {
      var keyValue = parts[x].split('=');

      if (keyValue[0] !== '') {
        params[keyValue[0]] = keyValue[1];
      }
    }

    return params;
  };

  this.update = function (params) {
    var currentParams = this.get();
    var keys = Object.keys(params);

    for (var x in keys) {
      currentParams[keys[x]] = params[keys[x]];
    }

    var queryString = '#';
    var updatedKeys = Object.keys(currentParams);

    for (var y in updatedKeys) {
      queryString += updatedKeys[y] + '=' + currentParams[updatedKeys[y]] + '&';
    }

    _window.location.hash = queryString.slice(0, -1);
  };
}

module.exports = QueryParams;

/***/ }),

/***/ "./lib/transactionReceiptResolver.js":
/*!*******************************************!*\
  !*** ./lib/transactionReceiptResolver.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = class TransactionReceiptResolver {
  constructor(blockchain) {
    this._transactionReceipts = {};
    this.blockchain = blockchain;
  }

  resolve(tx, cb) {
    if (this._transactionReceipts[tx.hash]) {
      return cb(null, this._transactionReceipts[tx.hash]);
    }

    this.blockchain.web3().eth.getTransactionReceipt(tx.hash, (error, receipt) => {
      if (!error) {
        this._transactionReceipts[tx.hash] = receipt;
        cb(null, receipt);
      } else {
        cb(error);
      }
    });
  }

};

/***/ }),

/***/ "./loadFilesFromParent.js":
/*!********************************!*\
  !*** ./loadFilesFromParent.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = fileManager => {
  // The event listener needs to be registered as early as possible, because the
  // parent will send the message upon the "load" event.
  let filesToLoad = null;

  let loadFilesCallback = function (files) {
    filesToLoad = files;
  }; // will be replaced later


  window.addEventListener('message', function (ev) {
    if (typeof ev.data === typeof [] && ev.data[0] === 'loadFiles') {
      loadFilesCallback(ev.data[1]);
    }
  }, false); // Replace early callback with instant response

  loadFilesCallback = function (files) {
    fileManager.setBatchFiles(files);
  }; // Run if we did receive an event from remote instance while starting up


  if (filesToLoad !== null) {
    fileManager.setBatchFiles(filesToLoad);
  }
};

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./index */ "./index.js");

/***/ }),

/***/ "./migrateFileSystem.js":
/*!******************************!*\
  !*** ./migrateFileSystem.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _remixLib = __webpack_require__(/*! @remix-project/remix-lib */ "../../../dist/libs/remix-lib/index.js");

/*
  Migrating the files to the BrowserFS storage instead or raw localstorage
*/
var _default = fileProvider => {
  const fileStorage = new _remixLib.Storage('sol:');
  const flag = 'status';
  const fileStorageBrowserFS = new _remixLib.Storage('remix_browserFS_migration:');
  if (fileStorageBrowserFS.get(flag) === 'done') return;
  fileStorage.keys().forEach(path => {
    if (path !== '.remix.config') {
      const content = fileStorage.get(path);
      fileProvider.set(path, content); // TODO https://github.com/ethereum/remix-ide/issues/2377
      // fileStorage.remove(path) we don't want to remove it as we are still supporting the old version

      console.log('file migrated', path);
    }
  });
  fileStorageBrowserFS.set(flag, 'done');
};

exports.default = _default;

/***/ }),

/***/ "./publishToStorage.js":
/*!*****************************!*\
  !*** ./publishToStorage.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = publish;

const yo = __webpack_require__(/*! yo-yo */ "../../../node_modules/yo-yo/index.js");

const publishOnSwarm = __webpack_require__(/*! ./lib/publishOnSwarm */ "./lib/publishOnSwarm.js");

const publishOnIpfs = __webpack_require__(/*! ./lib/publishOnIpfs */ "./lib/publishOnIpfs.js");

const modalDialogCustom = __webpack_require__(/*! ./app/ui/modal-dialog-custom */ "./app/ui/modal-dialog-custom.js");

function publish(storage, fileProvider, fileManager, contract) {
  if (contract) {
    if (contract.metadata === undefined || contract.metadata.length === 0) {
      modalDialogCustom.alert('This contract may be abstract, may not implement an abstract parent\'s methods completely or not invoke an inherited contract\'s constructor correctly.');
    } else {
      if (storage === 'swarm') {
        publishOnSwarm(contract, fileManager, function (err, uploaded) {
          if (err) {
            try {
              err = JSON.stringify(err);
            } catch (e) {}

            console.log(`Failed to publish metadata file to swarm, please check the Swarm gateways is available ( swarm-gateways.net ) ${err}`);
          } else {
            var result = yo`<div>${uploaded.map(value => {
              return yo`<div><b>${value.filename}</b> : <pre>${value.output.url}</pre></div>`;
            })}</div>`;
            modalDialogCustom.alert(`Published ${contract.name}'s Metadata`, yo`<span>Metadata of "${contract.name.toLowerCase()}" was published successfully.<br> <pre>${result}</pre> </span>`);
          }
        }, item => {
          // triggered each time there's a new verified publish (means hash correspond)
          fileProvider.addExternal('swarm/' + item.hash, item.content);
        });
      } else {
        publishOnIpfs(contract, fileManager, function (err, uploaded) {
          if (err) {
            try {
              err = JSON.stringify(err);
            } catch (e) {}

            modalDialogCustom.alert(yo`<span>Failed to publish metadata file to ${storage}, please check the ${storage} gateways is available.<br />
            ${err}</span>`);
          } else {
            var result = yo`<div>${uploaded.map(value => {
              return yo`<div><b>${value.filename}</b> : <pre>${value.output.url}</pre></div>`;
            })}</div>`;
            modalDialogCustom.alert(`Published ${contract.name}'s Metadata`, yo`<span>Metadata of "${contract.name.toLowerCase()}" was published successfully.<br> <pre>${result}</pre> </span>`);
          }
        }, item => {
          // triggered each time there's a new verified publish (means hash correspond)
          fileProvider.addExternal('ipfs/' + item.hash, item.content);
        });
      }
    }
  }
}

/***/ }),

/***/ "./registry.js":
/*!*********************!*\
  !*** ./registry.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// const moduleID = require('./module-id.js')
module.exports = class registry {
  constructor() {
    this.state = {};
  }

  put({
    api,
    name
  }) {
    // const serveruid = moduleID() + '.' + (name || '')
    if (this.state[name]) return this.state[name];
    const server = {
      // uid: serveruid,
      api
    };
    this.state[name] = {
      server
    };
    return server;
  }

  get(name) {
    // const clientuid = moduleID()
    const state = this.state[name];
    if (!state) return;
    const server = state.server;
    return server;
  }

};

/***/ }),

/***/ "./remixAppManager.js":
/*!****************************!*\
  !*** ./remixAppManager.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNative = isNative;
exports.canActivate = canActivate;
exports.RemixAppManager = void 0;

var _engine = __webpack_require__(/*! @remixproject/engine */ "../../../node_modules/@remixproject/engine/dist/index.js");

var _events = __webpack_require__(/*! events */ "../../../node_modules/events/events.js");

var _queryParams = _interopRequireDefault(__webpack_require__(/*! ./lib/query-params */ "./lib/query-params.js"));

var _persmissionHandler = __webpack_require__(/*! ./app/ui/persmission-handler */ "./app/ui/persmission-handler.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global localStorage, fetch */
const requiredModules = [// services + layout views + system views
'manager', 'compilerArtefacts', 'compilerMetadata', 'contextualListener', 'editor', 'offsetToLineColumnConverter', 'network', 'theme', 'fileManager', 'contentImport', 'web3Provider', 'scriptRunner', 'fetchAndCompile', 'mainPanel', 'hiddenPanel', 'sidePanel', 'menuicons', 'fileExplorers', 'terminal', 'settings', 'pluginManager'];

function isNative(name) {
  const nativePlugins = ['vyper', 'workshops'];
  return nativePlugins.includes(name) || requiredModules.includes(name);
}

function canActivate(name) {
  return ['manager', 'debugger', 'ethdoc'].includes(name);
}

class RemixAppManager extends _engine.PluginManager {
  constructor(plugins) {
    super();
    this.event = new _events.EventEmitter();
    this.pluginsDirectory = 'https://raw.githubusercontent.com/ethereum/remix-plugins-directory/master/build/metadata.json';
    this.pluginLoader = new PluginLoader();
    this.permissionHandler = new _persmissionHandler.PermissionHandler();
  }

  async canActivate(from, to) {
    return canActivate(from.name);
  }

  async canDeactivate(from, to) {
    return from.name === 'manager';
  }

  async canCall(from, to, method, message) {
    // Make sure the caller of this methods is the target plugin
    if (to !== this.currentRequest.from) {
      return false;
    } // skipping native plugins' requests


    if (isNative(from)) {
      return true;
    } // ask the user for permission


    return await this.permissionHandler.askPermission(this.profiles[from], this.profiles[to], method, message);
  }

  onPluginActivated(plugin) {
    this.pluginLoader.set(plugin, this.actives);
    this.event.emit('activate', plugin);
  }

  getAll() {
    return Object.keys(this.profiles).map(p => {
      return this.profiles[p];
    });
  }

  getIds() {
    return Object.keys(this.profiles);
  }

  onPluginDeactivated(plugin) {
    this.pluginLoader.set(plugin, this.actives);
    this.event.emit('deactivate', plugin);
  }

  onRegistration(plugin) {
    this.event.emit('added', plugin.name);
  }

  async ensureActivated(apiName) {
    await this.activatePlugin(apiName);
    this.event.emit('ensureActivated', apiName);
  }

  async ensureDeactivated(apiName) {
    await this.deactivatePlugin(apiName);
    this.event.emit('ensureDeactivated', apiName);
  }

  deactivatePlugin(name) {
    if (requiredModules.includes(name)) return;
    super.deactivatePlugin(name);
  }

  isRequired(name) {
    return requiredModules.includes(name);
  }

  async registeredPlugins() {
    const res = await fetch(this.pluginsDirectory);
    const plugins = await res.json();
    return plugins.map(plugin => new _engine.IframePlugin(plugin));
  }

}
/** @class Reference loaders.
 *  A loader is a get,set based object which load a workspace from a defined sources.
 *  (localStorage, queryParams)
 **/


exports.RemixAppManager = RemixAppManager;

class PluginLoader {
  get currentLoader() {
    return this.loaders[this.current];
  }

  constructor() {
    const queryParams = new _queryParams.default();
    this.donotAutoReload = ['remixd']; // that would be a bad practice to force loading some plugins at page load.

    this.loaders = {};
    this.loaders['localStorage'] = {
      set: (plugin, actives) => {
        if (!this.donotAutoReload.includes(plugin.name)) {
          localStorage.setItem('workspace', JSON.stringify(actives));
        }
      },
      get: () => {
        return JSON.parse(localStorage.getItem('workspace'));
      }
    };
    this.loaders['queryParams'] = {
      set: () => {},
      get: () => {
        const {
          plugins
        } = queryParams.get();
        if (!plugins) return [];
        return plugins.split(',');
      }
    };
    this.current = queryParams.get()['plugins'] ? 'queryParams' : 'localStorage';
  }

  set(plugin, actives) {
    this.currentLoader.set(plugin, actives);
  }

  get() {
    return this.currentLoader.get();
  }

}

/***/ }),

/***/ "./universal-dapp-styles.js":
/*!**********************************!*\
  !*** ./universal-dapp-styles.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var csjs = __webpack_require__(/*! csjs-inject */ "../../../node_modules/csjs-inject/index.js");

var css = csjs`
  .instanceTitleContainer {
    display: flex;
    align-items: center;
  }
  .calldataInput{
    height: 32px;
  }
  .title {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    width: 100%;
    overflow: hidden;
    word-break: break-word;
    line-height: initial;
    overflow: visible;
    padding: 0 0 8px;
    margin: 0;
    background: none;
    border: none;
  }
  .title button {
    background: none;
    border: none;
  }
  .titleLine {
    display: flex;
    align-items: baseline;
  }
  .titleText {
    word-break: break-word;
    width: 100%;
    border: none;
  }
  .spanTitleText {
    line-height: 12px;
    padding: 0;
    font-size: 11px;
    width:100%;
    border: none;
    background: none;
    text-transform: uppercase;
  }
  .inputGroupText {
    width: 100%;
  }
  .title .copy {
    color: var(--primary);
  }
  .titleExpander {
    padding: 5px 7px;
  }
  .nameNbuts {
    display: contents;
    flex-wrap: nowrap;
    width: 100%;
  }
  .instance {
    display: block;
    flex-direction: column;
    margin-bottom: 12px;
    background: none;
    border-radius: 2px;
  }
  .instance.hidesub {
    border-bottom: 1px solid;
  }
  .instance.hidesub .title {
      display: flex;
  }
  .instance.hidesub .udappClose {
      display: flex;
  }
  .instance.hidesub > * {
    display: none;
  }
  .methCaret {
    min-width: 12px;
    width: 12px;
    margin-left: 4px;
    cursor: pointer;
    font-size: 16px;
    line-height: 0.6;
    vertical-align: middle;
    padding: 0;
  }
  .cActionsWrapper {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0.25rem;
    border-top-rightt-radius: 0;
    border-bottom-right-radius: 0.25rem;
    padding: 8px 10px 7px;
  }
  .group:after {
    content: "";
    display: table;
    clear: both;
  }
  .buttonsContainer {
    margin-top: 2%;
    display: flex;
    overflow: hidden;
  }
  .instanceButton {
    height: 32px;
    border-radius: 3px;
    white-space: nowrap;
    font-size: 11px;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .closeIcon {
    font-size: 12px;
    cursor: pointer;
    margin-left: 5px;
  }
  .udappClose {
    display: flex;
    justify-content: flex-end;
  }
  .contractProperty {
    width:100%;
  }
  .contractProperty.hasArgs input {
    padding: .36em;
    border-radius: 5px;
  }
  .contractProperty .contractActionsContainerSingle input{
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }
  .contractProperty button {
    min-width: 100px;
    width: 100px;
    margin:0;
    word-break: inherit;
  }
  .contractProperty button:disabled {
    cursor: not-allowed;
    background-color: white;
    border-color: lightgray;
  }
  .contractProperty.constant button {
    min-width: 100px;
    width: 100px;
    margin:0;
    word-break: inherit;
    outline: none;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .contractProperty > .value {
    box-sizing: border-box;
    float: left;
    align-self: center;
    margin-left: 4px;
  }
  .contractActionsContainer {
    width: 100%;
    margin-bottom: 8px;
  }
  .contractActionsContainerSingle {
    display: flex;
    width: 100%;
  }
  .contractActionsContainerSingle i {
    line-height: 2;
  }
  .contractActionsContainerMulti {
    display:none;
    width: 100%;
  }
  .contractActionsContainerMultiInner {
    width: 100%;
    padding: 16px 8px 16px 14px;
    border-radius: 3px;
    margin-bottom: 8px;
  }
  .multiHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    text-align: left;
    font-size: 10px;
    font-weight: bold;
  }
  .contractActionsContainerMultiInner .multiTitle {
    padding-left: 10px;
  }
  .contractProperty .multiTitle {
    padding: 0;
    line-height: 16px;
    display: inline-block;
    font-size: 12px;
    font-weight: bold;
    cursor: default;
  }
  .contractProperty .contractActionsContainerMultiInner .multiArg label{
    text-align: right;
  }
  .multiHeader .methCaret {
    float: right;
    margin-right: 0;
  }
  .contractProperty.constant .multiTitle {
    display: inline-block;
    width: 90%;
    /* font-size: 10px; */
    height: 25px;
    padding-left: 20px;
    font-weight: bold;
    line-height: 25px;
    cursor: default;
  }
  .multiArg {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    margin-top: 4px;
  }
  .multiArg input{
    padding: 5px;
  }
  .multiArg label {
    width: auto;
    padding: 0;
    margin: 0 4px 0 0;
    font-size: 10px;
    line-height: 12px;
    text-align: right;
    word-break: initial;
  }
  .multiArg button {
    max-width: 100px;
    border-radius: 3px;
    border-width: 1px;
    width: inherit;
  }
  .multiHeader button {
    display: inline-block;
    width: 94%;
  }
  .hasArgs .multiArg input {
    border-left: 1px solid #dddddd;
    width: 67%;
  }
  .hasArgs input {
    display: block;
    height: 32px;
    border: 1px solid #dddddd;
    padding: .36em;
    border-left: none;
    padding: 8px 8px 8px 10px;
    font-size: 10px !important;
  }
  .hasArgs button {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
    border-right: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 11px;
  }
  .hasArgs .contractActionsContainerMulti button {
    border-radius: 3px;
  }
  .contractActionsContainerMultiInner .multiArg i {
    padding-right: 10px;
  }
  .hideWarningsContainer {
    display: flex;
    align-items: center;
    margin-left: 2%
  }
`;
module.exports = css;

/***/ }),

/***/ 0:
/*!***********************!*\
  !*** multi ./main.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /home/circleci/remix-project/apps/remix-ide/src/main.js */"./main.js");


/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 10:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 11:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 12:
/*!*************************************!*\
  !*** decompress-response (ignored) ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 4:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 5:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 6:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 7:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 8:
/*!*****************************!*\
  !*** ./leveldown (ignored) ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 9:
/*!****************************!*\
  !*** ./nextTick (ignored) ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

},[[0,"runtime","vendor"]]]);
//# sourceMappingURL=main.js.map